---
layout: post
title: Leetcode 31：下一个排列（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-10-19 00:00:00
---

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须**原地**修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
`1,2,3` → `1,3,2`
`3,2,1` → `1,2,3`
`1,1,5` → `1,5,1`

**解题思路**

一个简单的想法是将所有的排列结果得到，然后当前排列的后一个。但是这种做法太蠢了，而且实际操作起来也很困难，我们当然希望一个更快的。对于下面这个例子

```
1  5  6  4  3  2  1
```

上面例子的`下一个排列`是`1 6 1 2 3 4 5`，我是怎么得到它的呢？首先，我们定义一个右指针`i`

```
1  5  6  4  3  2  1
                  |
                  i
```

然后我们向左移，找到第一个数下降位置。接着定义一个右指针`j`。

```
1  5  6  4  3  2  1
   |              |
   i              j
```

此时我们从`j`向`i`找第一个大于`nums[i]`的位置

```
1  5  6  4  3  2  1
   |  |
   i  j
```

接着我们交换`nums[i]`和`nums[j]`。

```
1  6  5  4  3  2  1
   |  |
   i  j
```

接着将`nums[i+1:]`的元素`reverse`即可。

```
1  6  1  2  3  4  5
   |  |
   i  j
```

上述过程转换为代码为

```python
class Solution:
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        i = j = r = len(nums) - 1
        while i > 0 and nums[i] <= nums[i-1]:
            i -= 1
            
        i -= 1
        if i >= 0:
            while j >= i and nums[j] <= nums[i]:
                j -= 1

            nums[i], nums[j] = nums[j], nums[i]
        
        i += 1
        while i < r:
            nums[i], nums[r] = nums[r], nums[i]
            i += 1
            r -= 1
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**
