---
layout: post
title: Leetcode 654：最大二叉树（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-2-24 00:00:00
---

给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

1. 二叉树的根是数组中的最大元素。
2. 左子树是通过数组中最大值左边部分构造出的最大二叉树。
3. 右子树是通过数组中最大值右边部分构造出的最大二叉树。

通过给定的数组构建最大二叉树，并且输出这个树的根节点。

**Example 1:**

```
输入: [3,2,1,6,0,5]
输入: 返回下面这棵树的根节点：

      6
    /   \
   3     5
    \    / 
     2  0   
       \
        1
```

**注意:**

1. 给定的数组的大小在 [1, 1000] 之间。

**解题思路**

这个问题太简单了，直接使用递归。我们先找到最大值以及最大值的位置`max_index`，然后对于`nums[:max_index]`递归调用函数，返回值为`root.left`；对于`nums[max_index+1:]`递归调用函数，返回值为`root.right`。

```python
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
        if nums:
            max_val = max(nums)
            max_index = nums.index(max_val)
            root = TreeNode(max_val)
            root.left = self.constructMaximumBinaryTree(nums[:max_index])
            root.right = self.constructMaximumBinaryTree(nums[max_index+1:])
            return root
```

我们也可以通过递归来解决这个问题，不过需要使用**递减栈**。当遍历到的元素值`cur`大于栈顶元素的话，我们就将栈中所有小于`cur`节点弹出，那么此时全部弹出的值一定在`cur`的左子树，我们只需要将最后一个弹出的值记录为`node`，令`cur.left=node`即可构造树（此时的`node`一定是左子树的根）。如果当前遍历到的元素`cur`小于栈顶元素的话，我们首先将栈顶元素`stack[-1].right=cur`，然后将其加入栈中（注意对于当前遍历到的元素来说，此时的`cur`一定是右子树的根）。

```python
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
        stack = list()
        for n in nums:
            cur = TreeNode(n)
            while stack and stack[-1].val < n:
                cur.left = stack.pop()
                
            if stack:
                stack[-1].right = cur
            stack.append(cur)
            
        return stack[0]
```

这个算法要怎么理解呢？假如此时我们通过`nums[0] ~ nums[i - 1]`构成了最大二叉树，此时如果在添加一个元素`nums[i]`，该添加到哪里呢？我们假设前面的最大二叉树是这样的

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/654/2019_2_24_1.png" width="150">
</center>

此时我们要添加的元素是`d`。如果`d>a`，那么`a`一定是`d`的左子树根节点（因为`a`在`d`的左边，而且`a`是左边最大值）

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/654/2019_2_24_2.png" width="150">
</center>

如果`d<a`，那么`d`一定在`a`的右子树，至于在哪？我们只需要找到`node<d`的节点，那么以`node`为根的子树，一定在`d`的左边。（假设`node=c`）

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/654/2019_2_24_3.png" width="150">
</center>

从上面可知，当我们新加入一个节点的时候一定要知道前面大于`node`的第一个元素是谁？根据之前文章[ Leetcode 单调栈问题总结（超详细！！！）](https://blog.csdn.net/qq_17550379/article/details/86519771)，所以我们不难知道这里要使用**递减栈**。最后栈首元素一定是全局最大的，也就是根节点，我们返回它就好啦！

reference:

https://leetcode.com/problems/maximum-binary-tree/discuss/106156/Java-worst-case-O(N)-solution

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**