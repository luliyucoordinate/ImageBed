---
layout: post
title: 乘除运算及浮点数运算（1）
category : 计算机系统原理
tags : [notes, 原理]
stickie: true
---


整数的乘法运算
===

整数的乘法运算
---
通常，高级语言中两个n位整数相乘得到的结果通常也是一个n位整数，也即结果只取2n位乘积中的低n位。  
在计算机内部，一定有$x^2>=0$吗？  
若x是带符号整数，则不一定；若x为浮点数，则不一定。原因就是只取低n位元素。  
如何判断返回的值z是正确的值？  
当$!x || z/x==y$为真  
编译器是如何判断结果是不是真确的？  
当$-2^{(n-1)}≤x*y≤2^{(n-1)}​$（不溢出），即乘积的高n位为全0或全1，并等于低n位的最高位。即乘积的高n+1位全0或全1  
若x和y都是unsigned类型，则判断方式是乘积的高n位全0，则不溢出。  
要注意的是硬件不判断溢出，所以如果程序不采用防止溢出的措施，且编译器也不生成用于溢出处理的代码，就会发生一些由于整数溢出而带来的问题。  

整数乘法溢出漏洞
---

```c
int copy_array(int *array,int count)
{
	int i;
	int *myarray = (int*) malloc(count*sizeof(int));
	if(myarray == NULL)
		return -1;
	for(i = 0; i < count; ++i)
	{
		myarray[i] = array[i];
	}
	return count;
}
```
如果count很大的时候，如$count=2^{32}+1$时，count*sizeof(int)=4.攻击者可以构造特殊参数来触发整数溢出，以一段预设信息覆盖一个已分配的对缓冲区，造成远程服务器崩溃或者改变内存数据并执行任意代码。

变量与常数之间的乘运算
---
编译器在处理变量与常数相乘时，往往以移位、加法、和减法的组合运算来代替乘法运算。因为乘法运算就是重复的加若干次实现的，所以非常耗时间。  
例如，对于表达式$x*20$，编译器可以利用$20=16+4=2^4+2^2$，将$x*20$转换为$(x<<4)+(x<<2)$，这样，一次乘法转换成了两次移位和一次加法。  
不管是无符号数还是带符号数得乘法，即使乘积溢出时，利用移位和加减运算组合的方式得到的结果都是和采用直接项城的结果是一样的。

整数的除法运算
===

整数的除法运算
---
对于带符号整数来说，n位整数除以n位整数，除$-2^{(n-1)}/(-1)=2^{(n-1)}$会发生溢出外，其他情况不会发生。因为$2^{(n-1)}$无法表示。  
因为整数除法，其商也是整数，所以，再不能整除的时候需要进行舍入，通常按照朝0方向舍入，即正数商取比自身小的最接近整数，负数商取比自身大的最接近整数。  
整除0的结果无法使用一个、机器数表示。整数除法时，除数不能为0，否则会发生异常，此时，需要调出操作系统中的异常处理程序。  
代码段一：

```c
int a = 0x80000000;
int b = a/-1;
printf("%d\n", b);//-2147483648
```
原因在于编译器对于除-1优化为neg  
代码段二：

```c
int a = 0x80000000;
int b = -1;
int c = a/b;
printf("%d\n", b);//floating point execption
```

变量与常数之间的除运算
---
除法运算是非常耗时间的，所以最好少使用除法运算。为了缩短除法运算的时间，编译器在处理一个变量与一个2的幂次形式的整数相除时，常采用右移运算实现。  
无符号数：逻辑右移  
带符号数：算术右移  
能整除时，直接右移得到结果，移出的全为0；不能整除时，右移移除的位中有非0，需要进行相应处理。  
例如：  
$12/4 = 3:0000 1100>>2=0000 0011$  
不能整除时，采用朝0舍入，即截断的方式。无符号数、带符号正整数，移出的低位直接丢弃。带符号负整数，加偏移量$（2^k-1）$，然后在右移k位，低位截断（这里k是右移位数）  
例如：  
无符号数 $14/4=3:0000 1110>>2 = 0000 0011$  
带符号负整数$ -14/4=(-14+2^2-1)/4=(1111 0010+0000 0011)>>2=1111 0101>>2=1111 1101$

```c
int div32(int x)
{
	int b = (x >> 31)&0x1f;//偏移量
	return (x+b) >> 5;
}
```