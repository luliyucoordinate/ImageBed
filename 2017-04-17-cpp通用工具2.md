---
layout: post
title: cpp通用工具(2)
category : cpp
tags : [cpp, notes, cpp标准库]
stickie: true
---


Class unique_ptr
===

可确保一个对象和其相应资源同一时间之辈一个pointer占有。
unique_ptr是“其所指对象”的唯一拥有者。当unique_ptr被销毁，其所指的对象也就自动销毁。unique_ptr的必要条件是，他指的对象只有一个拥有者。

```c++
#include<memory>
void f()
{
	std::unqiue_ptr<ClassA> ptr(new ClassA);
}
```
这样就够了，不需要delete语句和catch语句。如果是普通的指针的话，会出现这样的问题，可能会忘记delete对象，特别是如果你在函数中有个return语句。


使用unique_ptr
---
```c++
//create and initialize string
std::unique_ptr<std::string> up(new std::string("nico");
(*up)[0] = 'N';//replace first character
up->append("fjdk");//append some characters
std::cout << *up << std::endl;
```
此外你可以调用release,获得unique_ptr拥有的对象并放弃拥有权，于是调用者对该对象有了使用权：

```c++
std::unique_ptr<std::string> up(new std::string("nico");
std::string* sp = up.release();
```


转移unique_ptr的拥有权
---
不可以对unique_ptr执行copy和assign，如果你要的是寻常的copy语句。然而你可以使用move。这种情况下上述的copy构造函数或assignment操作符拥有权交给另一个unique_ptr。  
举个例子:

```c++
std::unique_ptr<ClassA> up1(new ClassA);
std::unique_ptr<ClassA> up2(up1);//ERROR
//transfer ownership  of the unique_ptr
std::unique_ptr<ClassA> up3(std::move(up1));//OK
```
assignment操作符的行为和上面所说的类似:

```c++
std::unique_ptr<ClassA> up1(new ClassA);
std::unique_ptr<ClassA> up2;
up2 = up1;//ERROR 
up2 = std::move(up1);//assign the unique_ptr
```
如果上述的复制动作之前up2原本拥有对象，会有一个delete动作被调用。删除该对象：

```c++
std::unique_ptr<ClassA> up1(new ClassA);
std::unique_ptr<ClassA> up2(new ClassA);
up2 = std::move(up1);//assign the unique_ptr
//delete object owned by up2
```


对于array
---
对于array应该是用delete[]而不是delete，所以下面的做法是错误的：

```c++
std::unique_ptr<std::string> up(new std::string[10]);
```
很幸运，C++标准可提供了一个派诺特话版本用来处理array，对该对象调用delete[]。
你只要这样申明：

```c++
std::unique_ptr<std::string[]> up(new std::string[10]);
```
然而要注意的是，他不提供操作符*和->，提供[]，用于访问其所执行的array中的某个对象：

```c++
std::unique_ptr<std::string[]> up(new std::string[10]);
std::cout << *up << std::endl;//ERROR
std::cout << up[0] << std::endl;//OK
```


其他相应资源的deleter
---
当你所指向的对象要求的不只是delete或delete[]，你就只好自己制定deleter。但是与shared_ptr不同的是，你必须指定deleter的类型作为第二个template实参。该类型可以是reference to function，或是个function pointer或function object。如果是function object的话，其function call操作符()应该接受一个“指向对象”的pointer。

```c++
class ClassADeleter
{
public:
	void operator() (ClassA* p)
	{
		delete p;
	}
};
std::unique_ptr<ClassA,ClassADeleter> up(new ClassA());
```
如果你给的是个函数或lambda，你必须声明deleter的类型位void(*)(T*)或std::function<void(T*)>，要不就是使用decltype

```c++
std::unique_ptr<int,void(*)(int*)> up(new int[10],
					[](int* p)
					{
						...
						delete [] p;
					});
std::unique_ptr<int,std::function<void(int*)> up(new int[10],
						[](int* p)
						{
							...
							delete [] p;
						});
auto l = [](int *p)
	{
		...
		delete [] p;
	});
std::unique_ptr<int,decltype(l)> up(new int[10],l);
```

Type Trait 和Type Utility
===

Type trait 的目的
---
所谓的type trait，提供一种用来处理type属性的办法。他是个template，可以在编译期根据一个或多个template实参产生一个type或value。

```c++
template<typename T>
void foo(const T& val)
{
	if(std::ispointer<T>::value)
	{
		std::cout << "foo() called for a pointer " << std::endl;
	}
	else
	{
		std::cout << "foo() called for a value " << std::endl;
	}
}
```
针对整数类型的重载

```c++
template<typename T>
void foo_impl(T val,true_type);
template<typename T>
void foo_impl(T val, false_type);
template<typename T>
void foo(T val)
{
	foo_impl(val, std::is_integral<T>());
}
```

细究Type Trait
===
Type trait定义于<type_traits>

(unary) Type Predicate
---
Trait中的大部分都是unary，也就是说他们使用一个template实参。例如is_const<>，它用来检查传入的类型是否为const：

```c++
is_const<int>::value //false
is_const<const volatile int> ::value //true
is_const<int* const>::value //true
is_const<const int*>;:value //false
```
用于检验type relation的trait

```c++
is_assignable<T,T2> //可以将类型T2复制给类型T
```
is_assignable<>的第一个类型若是nonclass，永远获得false_type。但是对于class，ordinary type作为第一类型是可以的
例如：

```c++
is_assignable<int,int>::value //false
is_assignable<int&，void*>::value //false
is_assignable<void*,int&>::value //false
is_assignable<int&,int>::value //true
is_constructible<T,Args...> //可以运用类型Args初始化T
```
例如：

```c++
is_constructiable<int>::value //true
is_constructiable<int, int>::value //true
```

Type Modifier
---
所有这一类trait为类型添加一个属性，前提是该属性尚未存在，或移除一个属性，前提是这个属性已经存在。例如：

```c++
typedef int T;
add_const<T>::type //const int
remove_const<T>::type //int
```
而类型const int&可被降级或扩展

```c++
typedef const int& T;
add_rvalue_reference<T>::type //const int&
remoce_const<T>::type //const int&
remoce_reference<T>::type //const int
```
要注意的是，一个“指向某常量类型”的reference本身并不是常量。add_lvalue_reference<>把一个rvalue reference转换为一个lvalue reference,然而add_rvalue_reference并不会把lvalue reference转化为rvalue reference。必须使用下面的做法：

```c++
add_rvalue_reference<remove_reference<T>::type>::type
```

Function Type Wrapper
---
使用member function时，“借以调用他们”的那个对象必须被当作第一参数：

```c++
class C
{
public:
	void memfunc(int x, int y) const;
};
std::function<void (const C&,int,int)> mf;
mf = &C::memfunc;
mf(C(), 42,77);
```
