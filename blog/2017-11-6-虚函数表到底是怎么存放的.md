---
layout: post
title: 虚函数表到底是怎么存放的
category : cpp
tags :  [cpp, vfptr]
stickie: true 
---

- "when VTABLE is get created in Memory , In compiletime or runtime?"

  Compile time. The vtable is simple an array of function pointers that gets stored in the executable. It never changes and this array is shared by all instances of a given class. Each instance of a class that has virtual methods contains one vtable pointer (for single inheritance), usually stored at offset 0, before all data members. This pointer is initialized at construction time to point to the vtable for that class.

“当VTABLE被创建在内存中，在编译时或运行时？“

编译时。 vtable是一个简单的函数指针数组，存储在可执行文件中。 它永远不会改变，并且这个数组被给定类的所有实例共享。 具有虚拟方法的类的每个实例都包含一个vtable指针（用于单个继承），通常存储在所有数据成员之前的偏移量0处。 这个指针在构造时被初始化，指向该类的虚表。

- "If the class contain one virtual function , then what is the size of class?"

  The class has the same size if it has 1 or 100 virtual functions, size of the class data members + size of the vtable pointer (4 bytes for x86, 8 bytes for x64) (for single inheritance).

“如果这个类包含一个虚拟函数，那么类的大小是多少？”

如果具有1或100个虚拟函数，类数据成员的大小+ vtable指针的大小（x86为4个字节，x64为8个字节）（单个继承），则该类具有相同的大小。

- "Heap or Stack?"

  As I said, the vtable is stored in the executable. The executable is memory mapped so basically it's stored in the same place where the code is, in memory that belongs to a memory mapped section, that's neither heap nor stack.

“堆或堆？”

正如我所说的，vtable存储在可执行文件中。 可执行程序是内存映射的，所以基本上它存储在代码所在的同一个地方，属于内存映射部分的内存中，既不堆也不堆栈。

- And one more thing initialization of v-table  take place under default constructor.The vtable is built at compile time( statically allocated).Each of the type instances contains a pointer to this table Because this pointer is initialized at construction time, a virtual member function should never be called from the constructor

还有一件事是在默认的构造函数下进行v-table的初始化。vtable是在编译时建立的（静态分配的）。每个类型实例都包含一个指向这个表的指针因为这个指针在构造时被初始化， 一个虚成员函数不应该被构造函数调用。

