---
layout: post
title: oracle配置
category : 数据库
tags : [oracle]
stickie: true
---


管理oracle
===


启动和停止oracle
---

停止和启动oracle需要切换到oracle用户才可以，其他用户都没有权限启动和停止oracle（包括root也没有权限）  
运行sqlplus但不登录到oracle:  
sqlplus /nolog  
以系统管理权的权限连接到oracle服务器  
conn /as sysdba;  
启动oracle服务  
startup  
停止oracle服务  
shutdown immediate; 立即关闭  
-normal 真正关闭  
-tarnsactional 尽量少影响客户端  
abort 放弃一切事物，立即关闭  



listener
---

oracle的listener,相当于oracle的TCPserver，liestener会在1521这个端口listen。  
所有的oracle client端都需要通过listener才能连接到oracle server。  
启动和停止listener  
进入listener的管理界面  
lsnrctl  
启动listener  
start  
停止listener  
stop  




sqlplus
---

sqlplus是一个最常用的工具，具有很强的功能，主要有：  
数据库的维护，一般在服务器上操作，不可以远程  
执行sql语句执行pl/sql  
执行sql脚本  
数据的导出，报表  
用户管理级权限维护  
生成新的sql脚本  



conn
---

conn 用户名/密码@网络服务名  
show user  
显示当前用户  
@script.sql  
执行当前sql脚本文件  
quit  
断开数据库连接，退出sqlplus  



spool
---

该命令可以将sqlplus屏幕上的内容输出到指定文件中去  
例子

```sql
sql>spool a.txt
select * from tablename;
sql>spool off;
```


linesize
---

显示行的宽度，默认80字符

```sql
sql>show linesize
sql>set linesize 90
```
pagesize  
设置每页显示的行数目，默认14，用法和linesize一样，至于其他环境参数的使用也是大同小异



NLS_LANG环境变量
---

sqlplus通过.bash_profile中的NLS_LANG环境变量决定显示语言  
中文gbk  
NLS_LANG=”SIMPLIFIED CHINESE_CHINA.ZHS16GBK”  
简体中文utf8  
NLS_LANG=”SIMPLIFIED CHINESE_CHINA.AL32UTF8”  
在sqlplus中的oracle server短的字符集  

```sql
SQL> select userenv('language') from dual;
```


创建用户create user
---

在oracle中创建一个新的用户使用create user语句，一般是具有dba(数据库管理员)的权限才能使用  
基本语法：create user 用户名 identified by dbuser1;

```sql
create user dbuser1 identified by dbuser1;
```


用户赋权grant
---

创建的新用户是没有任何权限的，需要为其指定相应的权限，赋权使用grant，回收权限使用revoke  
基本语法：grant 权限/角色 to 用户

```sql
grant connect, resource to dbuser1;
```


删除用户
---
```sql
drop user username
```
一般以dba的身份去删除莫个用户  
基本语法：drop user 用户名

```sq;
drop user dbuser1;
```
所有对表的修改，都是在一个事务中，commit后才会有效  
如果操作失误的话  
使用rollback命令可以回去  



返回指定行数的SELECT查询数据语句
---

ROWNUM的语法

```sql
SELECT * FROM TABLENAME WHERE ROWNUM CONDITIONAL n;
```
CONDITIONAL 代表条件( <, <= ,>, >=)，其中n是返回数  
SELECT * FROM table1 WHERE ROWNUM <= 5;可以=1但是别的数不可以



主键与序列
===


CREATE TABLE
---

建立表的时候同时可以指定一个字段为主键  
CONSTRAINT 主键名 PRIMARY KEY 主键字段名  
例子：

```sql
CREATE TABLE table1 (id int, name varchar2(100), CONSTRAINT pk_id PRIMARY KEY(id));
```


ORACLE 创建序列语句
---

CREATE SEQUENCE 序列名  
increment by 序列步长 
sart with 序列起始值  
mxvalue 序列最大值  
例子：

```sql
CREATE SEQUENCE seql
increment by 1
start with 1
maxvalue 9999999；
insert into table1 (id,name) values (0,'sd');
```
出现如下错误  
ORA-01950: 对表空间 'USERS' 无权限  
解决方案：  
在sys用户下 

```sql
SQL> alter user c##dbuser1 quota unlimited on USERS;
```


删除序列
---

DROP SEQUENCE 序列名  
得到序列的下一个值  
序列名.nextval  
例子：

```sql
INSERT INTO table1 (id,name) VALUES (seql.nextval,’tom’);
```
要注意的是这个nextval是个全局变量，所以往不同的表插都会增加  
在oracle下，如果用varchar这个数据类型，推荐用varchar2  



Oracle编程
===


Proc程序设计
---

通过在过程化编程语言中嵌入sql语句而开发出的应用程序成为pro程序,在c/c++语言中嵌入sql语句而开发出的应用程序成为pro*c/c++程序。  
Proc常用选项

<a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fe3y4bhm0ij20ft06bwjd.jpg" data-lightbox="roadtrip">
<img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fe3y4bhm0ij20ft06bwjd.jpg" class="img-fluid">
</a>


Makefile文件例子

```shell
.SUFFIXES:.c .o

CC=gcc
PROC=proc

PROCSRCS=oracle.pc
SRCS=$(PROCSRCS:.pc=.c)
OBJS=$(SRCS:.c=.o)
ORACLE_HOME=/opt/oracle/product/12.2.0/dbhome_2
ORAFLAGS1=/usr/include/linux
ORAFLAGS2=/usr/lib/gcc/x86_64-redhat-linux/4.8.2/include
EXEC=abc

start: $(OBJS)
	$(CC) -o $(EXEC) $(OBJS) -L$(ORACLE_HOME)/lib -lclntsh
	@echo '----------------ok-----------------'

.c.o: $(SRCS)
	$(CC) -Wall -g -o $@ -c $<
	
$(SRCS):
	$(PROC) INAME=$(PROCSRCS) INCLUDE=$(ORAFLAGS1) INCLUDE=$(ORAFLAGS2) CPOOL=YES MODE=ANSI CODE=ANSI_C PARSE=PARTIAL THREADS=YES ONAME=$(SRCS)

clean:
	rm -f $(OBJS)
	rm -f $(SRCS)
	rm -f core*
```
```c++
//pc文件中，如果是嵌入式的sql语句要增加的话
//proc PARSE=PARTIAL ,变量必须在begin和end之间定义
EXEC SQL BEGIN DECLARE SECTION;
	sql_context pContext;
	long SQLCODE; //变量的类型和名称都不可以变
EXEC SQL END DECLARE SECTION;

extern void sqlglmt(void*, char*, size_t*, size_t* ); 
//安装错误处理函数
void sql_error()
{
	char sErrorString[512];//自定义一个数组，数组的名字可以自定义
	size_t tMessageSize = 0;
	size_t tErrorSize = sizeof(sErrorString);
	memset(sErrorString, 0, sizeof(sErrorString));
	sqlglmt(pContext, sErrorString, &tErrorSize, &tMessageSize);//调用sqlglmt这个函数得到具体错误描述
	sErrorString[tMessageSize] = 0;//设置错误描述字符串最后以0结尾
	printf("%s\n", sErrorString);//打印错误描述
}

//初始化数据库
void sql_init()
{
	SQLCODE = 0;
	pContext = NULL;
	EXEC SQL ENABLE THREADS;//可以在代码当中生成线程相关代码
	EXEC SQL CONTEXT ALLOCATE :pContext;//为pContext分配内存
	EXEC SQL CONTEXT USE :pContext;//使用pContext
}
```
连接到数据库

```sql
int sql_connect(const char *user, const char *passwd, const char *dbname)
{
	EXEC SQL BEGIN DECLARE SECTION;
		const char *sUser;
		const char *sPasswd;
		const char *sDBname;
	
	EXEC SQL END DECLARE SECTION;
	SQLCODE = 0;
	sUser = user;
	sPasswd = passwd;
	sDBname = dbname;
//在嵌入式SQL语句里面 冒号代表要用输入变量
	EXEC SQL CONNECT :sUser IDENTIFIED BY :sPasswd USING :sDBname;
	
	if (SQLCODE != 0)
	{
		sql_error();
		return 1;
	}else
	{
		return 0;
	}
}

int sql_disconnect()
{
	SQLCODE = 0;
	EXEC SQL ROLLBACK WORK RELEASE;
	if (SQLCODE != 0)
	{
		sql_error();
		return 1;
	}else
	{
		return 0;
	}
}

int sql_free()
{
	SQLCODE = 0;
	EXEC SQL CONTEXT FREE :pContext;
	if (SQLCODE != 0)
	{
		sql_error();
		return 1;
	}else
	{
		return 0;
	}	
}
```


积累
===

drop user  ×× ； 仅仅是删除用户  
如果用户下有对象，那么drop user  ×× ；会报错  
ORA-01922: 必须指定 CASCADE 以删除 ××  
drop user ×× cascade ；会删除此用户名下的所有表和视图  
使用cascade参数可以删除该用户的全部objects。  
如果用户的schema中有表，则在删除表的时候自动删除与该表相关的主键和外键。  
如果用户的schema中有表，则在删除表的时候自动删除与该表相关的索引。  


oracle 12g创建用户必须加c##吗  
你是建成了CDB导致 用户必须加C##，  dbca重新建一个库 然后不要选择CDB 就会和以前的版本一样没有这个限制， CDB不适合新手或者初学者

