---
layout: post
title: python和C语言中的全局变量的区别
category : python
tags : [python, c]
---

问题的引出：

```python
x = 5
def Func():
	x *= x
	print(x)
Func()
```

报错信息

```
Traceback (most recent call last):
  File "new 2.py", line 5, in <module>
    Func()
  File "new 2.py", line 3, in Func
    x *= x
UnboundLocalError: local variable 'x' referenced before assignment
```

这里为什么说x在赋值前被引用错误呢？明明我声明了一个全局变量x啊(这是一个c/c++程序员的想法^_^!!!)，在c语言中这样做确实没有问题。如下：

```c
int x = 5;
void fun(void)
{
    x *= x;
    print("%d", x);
}
int main(void)
{
    fun();
}
```

但是为什么在python里面就行不通了呢？

python里面的变量有些类似于C语言中的指针变量，你这样一想的话，有些问题就明白了。比如说为什么python里面的list可以容纳不同类型的变量？又比如说python里面变量声明时不区分类型？另外，还要知道的一点是，python在赋值时，会为数值分配一块内存空间，然后通过变量去指向这块内存空间。如果修改变量的值，实际上就是变量指向了不同的内存空间。如下：

```python
>>> a = 1
>>> id(a)
1802679360
>>> a = 3
>>> id(a)
1802679424
```

ok，回到原来的问题。`x*=x` 相当于`x = x*x` ，也就是左边的x指向了右边生成的内存空间，这里要注意，前后x指向的内存发生了变化，如下

```python
x = 5
def Func():
	global x
	print(id(x))
	x*=x
	print(id(x))
	print(x)
Func()
```

结果是

```
1802679488
1802680128
25
```

当这个变量在右边的时候相当于取内存操作，python里面如果要对一个全局变量取内存操作的话，必须要提前声明这个变量是`global` 的，也就是上面代码里的做法。关键问题来了，我函数里的x不可以取外面x的内存里的东西吗？可以！！！

```python
x = 5
print(id(x))
def Func():
	print(id(x))
	print(x)
Func()
```

结果是

```python
1802679488
1802679488
5
```

并没有出现问题，而且前后的x是同一个，而且我没有声明global。分析这个例子和上面的例子不难发现问题所在，问题出现在这个**赋值操作**上。所以我们大致总结为以下几点：

- 如果函数中出现赋值操作，则左边的变量会被标记为局部变量，如果变量名和函数外的变量名重名，函数外的变量将会被屏蔽。这时如果想要使用函数外的变量的话，要做global声明。
- 如果函数中没有出现复制操作，那么函数中可以直接使用全局变量