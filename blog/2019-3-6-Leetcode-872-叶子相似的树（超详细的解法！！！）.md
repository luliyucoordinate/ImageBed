---
layout: post
title: Leetcode 872：叶子相似的树（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-3-6 00:00:00
---

请考虑一颗二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 *叶值序列* 。

<center class="half">
    <img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png" width="200">
</center>

举个例子，如上图所示，给定一颗叶值序列为 `(6, 7, 4, 9, 8)` 的树。

如果有两颗二叉树的叶值序列是相同，那么我们就认为它们是 *叶相似* 的。

如果给定的两个头结点分别为 `root1` 和 `root2` 的树是叶相似的，则返回 `true`；否则返回 `false` 。

**提示：**

- 给定的两颗树可能会有 `1` 到 `100` 个结点。

**解题思路**

这个问题非常简单，我们通过前序遍历将所有的叶子节点加入到一个数组中，然后比较数组中的元素是不是相同即可。参看前面问题[Leetcode 144:二叉树的前序遍历（最优雅的解法！！！）](https://mp.csdn.net/postedit/80731041)

```python
class Solution:
    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:
        def preOrder(root, res):
            if root:
                if not root.left and not root.right:
                    res.append(root.val)
                preOrder(root.left, res)
                preOrder(root.right, res)
        
        res1, res2 = list(), list()
        preOrder(root1, res1)
        preOrder(root2, res2)
        return res1 == res2
```

一个`pythonic`的写法

```python
class Solution:
    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:
        def preOrder(node):
            if root:
                if not node.left and not node.right: 
                    yield node.val
                for i in preOrder(node.left): 
                    yield i
                for i in preOrder(node.right): 
                    yield i
        return all(a == b for a, b in itertools.zip_longest(preOrder(root1), preOrder(root2)))
```

这样的话我们就使用了更少的空间复杂度。

reference:

https://leetcode.com/problems/leaf-similar-trees/discuss/152329/C%2B%2BJavaPython-O(logN)-Space

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**