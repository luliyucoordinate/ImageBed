---
layout: post
title: Leetcode 938：二叉搜索树的范围和（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-13 00:00:00
---

给定二叉搜索树的根结点 `root`，返回 `L` 和 `R`（含）之间的所有结点的值的和。

二叉搜索树保证具有唯一的值。 

**示例 1：**

```
输入：root = [10,5,15,3,7,null,18], L = 7, R = 15
输出：32
```

**示例 2：**

```
输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10
输出：23
```

**提示：**

1. 树中的结点数量最多为 `10000` 个。
2. 最终的答案保证小于 `2^31`。

**解题思路**

这个问题非常简单。我们首先想到的做法就是，先通过中序遍历得到中序遍历数组，然后遍历这个数组得到`L`和`R`的位置，然后计算这两个位置中所有元素的和即可。

想要如何写出优雅的中序遍历，看这篇文章[Leetcode 94:二叉树的中序遍历（最优雅的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/80809930)

```python
class Solution:
    def rangeSumBST(self, root, L, R):
        """
        :type root: TreeNode
        :type L: int
        :type R: int
        :rtype: int
        """
        tmp,result = list(), 0
        self.inorder(root, tmp)
        left, right = 0, 0
        for i, val in enumerate(tmp):
            if val == L:
                left = i
            if val == R:
                right = i
                break

        return sum(tmp[left:right+1])

    def inorder(self, root, result):
        if root:
            self.inorder(root.left, result)
            result.append(root.val)
            self.inorder(root.right, result)
```

另一种非常简单的思路就直接遍历整棵二叉树，然后对`L <= val <= R`的元素做加法。我们这里使用迭代版本的前序遍历。

想要如何写出优雅的前序遍历，看这篇文章[Leetcode 144:二叉树的前序遍历（最优雅的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/80731041)

```python
class Solution:
    def rangeSumBST(self, root, L, R):
        """
        :type root: TreeNode
        :type L: int
        :type R: int
        :rtype: int
        """
        result, stack = 0, [root]
        while stack:
            node = stack.pop()
            if node:
                if L <= node.val <= R:
                    result += node.val
                if node.val < R:
                    stack.append(node.right)
                if L < node.val:
                    stack.append(node.left)
                
        return result
```

还有一种比较简洁的思路就是直接使用递归。我们要知道以`root`为根区间在`[L,R]`的和，我们只需要知道以`root.left`为根区间在`[L,root.val-1]`这个区间的元素和加上以`root.right`为根区间在`[root.val+1,R]`这个区间的元素和再加上`root.val`即可。也就是将`[L,R]`拆借为`[L,root.val-1]`、`[root.val]`和`[root.val+1, R]`三个区间。

```python
class Solution:
    def rangeSumBST(self, root, L, R):
        """
        :type root: TreeNode
        :type L: int
        :type R: int
        :rtype: int
        """
        if not root or L > R:
            return 0
        
        if root.val < L:
            return self.rangeSumBST(root.right, L, R)

        if root.val > R:
            return self.rangeSumBST(root.left, L, R)

        return root.val + self.rangeSumBST(root.left, L, root.val - 1)+\
            self.rangeSumBST(root.right, root.val + 1, R)
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**