---
layout: post
title: Leetcode 1003：检查替换后的词是否有效（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-3-4 00:00:00
---

给定有效字符串 `"abc"`。

对于任何有效的字符串 `V`，我们可以将 `V` 分成两个部分 `X` 和 `Y`，使得 `X + Y`（`X` 与 `Y` 连接）等于 `V`。（`X` 或 `Y` 可以为空。）那么，`X + "abc" + Y` 也同样是有效的。

例如，如果 `S = "abc"`，则有效字符串的示例是：`"abc"`，`"aabcbc"`，`"abcabc"`，`"abcabcababcc"`。**无效**字符串的示例是：`"abccba"`，`"ab"`，`"cababc"`，`"bac"`。

如果给定字符串 `S` 有效，则返回 `true`；否则，返回 `false`。

**示例 1：**

```
输入："aabcbc"
输出：true
解释：
从有效字符串 "abc" 开始。
然后我们可以在 "a" 和 "bc" 之间插入另一个 "abc"，产生 "a" + "abc" + "bc"，即 "aabcbc"。
```

**示例 2：**

```
输入："abcabcababcc"
输出：true
解释：
"abcabcabc" 是有效的，它可以视作在原串后连续插入 "abc"。
然后我们可以在最后一个字母之前插入 "abc"，产生 "abcabcab" + "abc" + "c"，即 "abcabcababcc"。
```

**示例 3：**

```
输入："abccba"
输出：false
```

**示例 4：**

```
输入："cababc"
输出：false
```

**提示：**

1. `1 <= S.length <= 20000`
2. `S[i]` 为 `'a'`、`'b'`、或 `'c'`

**解题思路**

这个问题有一个纯暴力的解法，在比赛的时候同学就是用的这种方法过的。就是遍历字符串`S`查找第一个`"abc"`，然后把它删掉，再接着查找第二个第三个。

```python
class Solution:
    def isValid(self, S: str) -> bool:
        S2 = ""
        while S != S2:
            S, S2 = S.replace("abc", ""), S
        return S == ""
```

当时我看到我们的字符长度是`20000`所以就没有考虑这种解法了。但是后来查看测试用例发现这种解法可以通过的原因在于`20000`左右的测试用例太`Easy`了。

另外一个很容易想到的思路就是通过栈。我们首先建立一个栈`s`，然后遍历字符串`S`，判断输入的字符是不是`"c"`，如果是的话，此时我们就需要判断栈顶元素是不是`"ab"`，如果是的话我们就要将`"ba"`弹出（因为此时我们构成了一个`"abc"`组合）如果栈顶元素不是`"ab"`，那么无法构成组合，所以我们返回`False`。如果遍历到的元素不是`"c"`，我们直接压栈即可。最后我们只需要判断栈是不是空就行了。

```python
class Solution:
    def isValid(self, S: str) -> bool:
        s = list()
        for i in S:
            if i == 'c':
                if len(s) >= 2 and s[-1] == 'b' and s[-2] == 'a':
                    s.pop()
                    s.pop()
                else:
                    return False
            else:
                s.append(i)
        return len(s) == 0
```

这是一个不错的解法。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**