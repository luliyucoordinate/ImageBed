---
layout: post
title: Leetcode 1100：长度为 K 的无重复字符子串（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-6-30 00:00:00
---

给你一个字符串 `S`，找出所有长度为 `K` 且不含重复字符的子串，请你返回全部满足要求的子串的 **数目**。 

**示例 1：**

```
输入：S = "havefunonleetcode", K = 5
输出：6
解释：
这里有 6 个满足题意的子串，分别是：'havef','avefu','vefun','efuno','etcod','tcode'。
```

**示例 2：**

```
输入：S = "home", K = 5
输出：0
解释：
注意：K 可能会大于 S 的长度。在这种情况下，就无法找到任何长度为 K 的子串。
```

**提示：**

1. `1 <= S.length <= 10^4`
2. `S` 中的所有字符均为小写英文字母
3. `1 <= K <= 10^4`

**解题思路**

由于数据量很小，所以首先不难想到暴力解法。也就是枚举所有的长度为`K`的字符串，然后判断该字符串是不是有重复元素即可。

```python
class Solution:
    def numKLenSubstrNoRepeats(self, S: str, K: int) -> int:
        res = 0
        for i in range(len(S) - K + 1):
            res += len(set(S[i:i + K])) == K
        return res
```

这题和之前的问题[Leetcode 3:无重复字符的最长子串（最详细解决方案！！！）](https://blog.csdn.net/qq_17550379/article/details/80547777)非常类似。我们只需遍历一遍字符串即可，我们每次遍历的过程中记录当前遍历到的元素之前，离当前位置最近的重复元素位置。例如

```
h a v e f o n o n l e e t c o d e
            ↑     ↑
            l     i
```

当我们遍历到第`i`个元素的时候，我们知道前面`n`重复了，并且重复的`n`最后一个出现在`l`的位置。当然此时`o`也出现了重复，但是我们需要记录离`i`最近的是谁。那么我们只需的判断`i-l`是不是大于等于`K`？如果是的话，我们将`res++`。

```python
class Solution:
    def numKLenSubstrNoRepeats(self, S: str, K: int) -> int:
        res, usedChar, low = 0, {}, -1
        for i, v in enumerate(S):
            if v in usedChar and usedChar[v] >= low:
                low = usedChar[v]
            if i - low >= K:
                res += 1
            usedChar[v] = i
        return res
```

非常漂亮的一个解法！！！

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**