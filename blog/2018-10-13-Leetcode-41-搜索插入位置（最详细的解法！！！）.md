---
layout: post
title: Leetcode 41：缺失的第一个正数（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-10-13 00:00:00
---

给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

**示例 1:**

```
输入: [1,2,0]
输出: 3
```

**示例 2:**

```
输入: [3,4,-1,1]
输出: 2
```

**示例 3:**

```
输入: [7,8,9,11,12]
输出: 1
```

**说明:**

你的算法的时间复杂度应为O(*n*)，并且只能使用常数级别的空间。

**解题思路**

我们首先想到的做法是对`nums`排序，然后遍历`[min(nums),max(nums)]`区间内的所有数，找到第一个不在`nums`中的正整数即可。

```python
class Solution:
    def firstMissingPositive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 1

        nums.sort()
        for i in range(1, nums[-1]+1):
            if i not in nums:
                return i

        return nums[-1] + 1
```

但是问题中说了只能是`O(n)`级别的算法，所以我们不能使用排序算法。而且算法又是`O(n)`级别，所以我们很容易猜到做法就是通过遍历一遍数组就可以得到答案。但是要怎么做呢？我们首先想到的做法是这样，我们先定义一个很大的数组`mem`，然后遍历`nums`中的每个元素`num`，对`mem[num]=1`，这样我们只要再次遍历`mem`，找到第一个`mem[i]==0`的元素，那么`i`就是我们要找的值。很不错的想法是不是？但是我们这里还有一个问题，这个数组要定义多大呢？`max(nums)+1`即可。

```python
class Solution:
    def firstMissingPositive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 1

        max_len = max(nums)+1
        mem = [0]*max_len
        mem[0] = 1
        for num in nums:
            if num > 0:
                mem[num] = 1

        for i, val in enumerate(mem):
            if val != 1:
                return i

        return max_len
```

但是我们只能使用常数级别的空间复杂度，所以这种解法又被我们排除了。基于上面思想，我们稍加改进就得到了这样的算法。我们知道如果`nums`不空缺任何数字的话，那么`nums`排序号后，数字就应该和索引对应。所以对于

```
[3,4,-1,1]
```

我们遍历`nums`首先碰到`3`，而`3`应该放在`nums[2]`上，所以我们交换两个数的位置。

```
[-1,4,3,1]
```

重复此操作，直到所有数都遍历完。

```
[-1,1,3,4]
```

然后我们再此遍历`nums`，如果`nums`的值和索引不对应的话，那么那个索引就是我们需要的结果了。我们这里有几个细节要注意，我们需要交换的数必须要`>0`并且要`<=len(nums)`。

```python
class Solution:
    def firstMissingPositive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums_len = len(nums)
        for i in range(nums_len):
             while nums[i] > 0 and nums[i] <= nums_len\
                        and nums[nums[i]-1]!=nums[i]:
                nums[nums[i]-1],nums[i] = nums[i],nums[nums[i]-1]

        for i in range(nums_len):
            if nums[i] != i + 1:
                return i + 1

        return nums_len + 1
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**