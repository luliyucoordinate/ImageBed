---
layout: post
title: Leetcode 154：寻找旋转排序数组中的最小值 II（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-03 00:00:00
---

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

请找出其中最小的元素。

注意数组中可能存在重复的元素。

**示例 1：**

```
输入: [1,3,5]
输出: 1
```

**示例 2：**

```
输入: [2,2,2,0,1]
输出: 0
```

**说明：**

- 这道题是 [寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/) 的延伸题目。
- 允许重复会影响算法的时间复杂度吗？会如何影响，为什么？

**解题思路**

这是之前[Leetcode 153：寻找旋转排序数组中的最小值（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/83684249)问题的提高。处理思路实际上是一样的。可以分成和之前一样的三种情况

- $l<=mid>r$
- $l>mid<=r$
- $l<=mid<=r$

但是我们在处理最后一种情况时有所变化，不再是直接返回`nums[low]`，因为我们会碰到这样的情况

```
3 3 1 3
```

我们采用之前问题的第二种处理思路，也就是压缩空间，那么怎么压缩呢？我们知道对于第三种情况最小值可能出现在`mid`的右侧，也可能出现在`low`或者恰好在`mid`位置，所以对于这种情况我们直接`high--`即可。

```python
class Solution:
    def findMin(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        low, high = 0, len(nums) - 1
        while low <= high:
            mid = (low + high) // 2
            if nums[low] <= nums[mid]:
                if nums[mid] <= nums[high]:
                    high -= 1
                else:
                    low = mid + 1
            else:
                if nums[mid] <= nums[high]:
                    high = mid

        return nums[low]
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**