---
layout: post
title: opencv读取图片和视屏
category : cpp
tags : [opencv, cpp]
stickie: true
---

显示一幅图片
---

我们首先将图片文件用`imread`读取然后存储到`Mat`类的对象中。

```c++
#include <iostream>  
#include <opencv2\opencv.hpp>
using namespace cv;
int main() {  
	Mat img = imread("avatar.jpg");
	// 在窗口中显示avatar  
	imshow("avatar", img);
	// 等待按下任意键  
	waitKey(0);
}
```

Mat类是用于保存图像以及其他矩阵数据的数据结构，默认情况下大小为0.我么可以为其设置初始值，例如

```c++
Mat picture(320, 640, Scalar(100));
```

imread函数
---

关于`imread`函数，函数原型如下：

```c++
Mat imread(const string& filename, int flag = 1);
```

它的第一个参数`filename`，填入我们需要读取图片的路径。在windows下支持如下类型的加载：

- Windows bitmaps - *.bmp, *.dib (always supported)
- JPEG files - *.jpeg, *.jpg, *.jpe (see the *Notes* section)
- JPEG 2000 files - *.jp2 (see the *Notes* section)
- Portable Network Graphics - *.png (see the *Notes* section)
- WebP - *.webp (see the *Notes* section)
- Portable image format - *.pbm, *.pgm, *.ppm *.pxm, *.pnm (always supported)
- Sun rasters - *.sr, *.ras (always supported)
- TIFF files - *.tiff, *.tif (see the *Notes* section)
- OpenEXR Image files - *.exr (see the *Notes* section)
- Radiance HDR - *.hdr, *.pic (always supported)
- Raster and Vector geospatial data supported by Gdal (see the *Notes* section)

第二个参数flag的设置，我们通过查看`imgcodecs.hpp`（opencv3.3）可以知道如下的枚举变量，默认情况下设置为1（IMREAD_COLOR）。

```c++
enum ImreadModes {
       IMREAD_UNCHANGED            = -1, //!< If set, return the loaded image as is (with alpha channel, otherwise it gets cropped).
       IMREAD_GRAYSCALE            = 0,  //!< If set, always convert image to the single channel grayscale image.
       IMREAD_COLOR                = 1,  //!< If set, always convert image to the 3 channel BGR color image.
       IMREAD_ANYDEPTH             = 2,  //!< If set, return 16-bit/32-bit image when the input has the corresponding depth, otherwise convert it to 8-bit.
       IMREAD_ANYCOLOR             = 4,  //!< If set, the image is read in any possible color format.
       IMREAD_LOAD_GDAL            = 8,  //!< If set, use the gdal driver for loading the image.
       IMREAD_REDUCED_GRAYSCALE_2  = 16, //!< If set, always convert image to the single channel grayscale image and the image size reduced 1/2.
       IMREAD_REDUCED_COLOR_2      = 17, //!< If set, always convert image to the 3 channel BGR color image and the image size reduced 1/2.
       IMREAD_REDUCED_GRAYSCALE_4  = 32, //!< If set, always convert image to the single channel grayscale image and the image size reduced 1/4.
       IMREAD_REDUCED_COLOR_4      = 33, //!< If set, always convert image to the 3 channel BGR color image and the image size reduced 1/4.
       IMREAD_REDUCED_GRAYSCALE_8  = 64, //!< If set, always convert image to the single channel grayscale image and the image size reduced 1/8.
       IMREAD_REDUCED_COLOR_8      = 65, //!< If set, always convert image to the 3 channel BGR color image and the image size reduced 1/8.
       IMREAD_IGNORE_ORIENTATION   = 128 //!< If set, do not rotate the image according to EXIF's orientation flag.
     };
```

imshow函数
---

函数原型为：

```c++
void imshow(const string& winname, InputArray mat);
```

函数第一个参数代表的是显示窗口的标题名。函数第二个参数表示要输入的Mat数据对象，但是这里的类型时`InputArray`。

查看`InputArray`的定义

```c++
typedef const _InputArray& InputArray;
class CV_EXPORTS _InputArray
{
public:
    enum {
        KIND_SHIFT = 16,
        FIXED_TYPE = 0x8000 << KIND_SHIFT,
        FIXED_SIZE = 0x4000 << KIND_SHIFT,
        KIND_MASK = 31 << KIND_SHIFT,

        NONE              = 0 << KIND_SHIFT,
        MAT               = 1 << KIND_SHIFT,
        MATX              = 2 << KIND_SHIFT,
        STD_VECTOR        = 3 << KIND_SHIFT,
        STD_VECTOR_VECTOR = 4 << KIND_SHIFT,
        STD_VECTOR_MAT    = 5 << KIND_SHIFT,
        EXPR              = 6 << KIND_SHIFT,
        OPENGL_BUFFER     = 7 << KIND_SHIFT,
        CUDA_HOST_MEM     = 8 << KIND_SHIFT,
        CUDA_GPU_MAT      = 9 << KIND_SHIFT,
        UMAT              =10 << KIND_SHIFT,
        STD_VECTOR_UMAT   =11 << KIND_SHIFT,
        STD_BOOL_VECTOR   =12 << KIND_SHIFT,
        STD_VECTOR_CUDA_GPU_MAT = 13 << KIND_SHIFT,
        STD_ARRAY         =14 << KIND_SHIFT,
        STD_ARRAY_MAT     =15 << KIND_SHIFT
    };

    _InputArray();
    _InputArray(int _flags, void* _obj);
    _InputArray(const Mat& m);
    _InputArray(const MatExpr& expr);
    _InputArray(const std::vector<Mat>& vec);
    template<typename _Tp> _InputArray(const Mat_<_Tp>& m);
    template<typename _Tp> _InputArray(const std::vector<_Tp>& vec);
    _InputArray(const std::vector<bool>& vec);
    template<typename _Tp> _InputArray(const std::vector<std::vector<_Tp> >& vec);
    _InputArray(const std::vector<std::vector<bool> >&);
    template<typename _Tp> _InputArray(const std::vector<Mat_<_Tp> >& vec);
    template<typename _Tp> _InputArray(const _Tp* vec, int n);
    template<typename _Tp, int m, int n> _InputArray(const Matx<_Tp, m, n>& matx);
    _InputArray(const double& val);
    _InputArray(const cuda::GpuMat& d_mat);
    _InputArray(const std::vector<cuda::GpuMat>& d_mat_array);
    _InputArray(const ogl::Buffer& buf);
    _InputArray(const cuda::HostMem& cuda_mem);
    template<typename _Tp> _InputArray(const cudev::GpuMat_<_Tp>& m);
    _InputArray(const UMat& um);
    _InputArray(const std::vector<UMat>& umv);

#ifdef CV_CXX_STD_ARRAY
    template<typename _Tp, std::size_t _Nm> _InputArray(const std::array<_Tp, _Nm>& arr);
    template<std::size_t _Nm> _InputArray(const std::array<Mat, _Nm>& arr);
#endif

    Mat getMat(int idx=-1) const;
    Mat getMat_(int idx=-1) const;
    UMat getUMat(int idx=-1) const;
    void getMatVector(std::vector<Mat>& mv) const;
    void getUMatVector(std::vector<UMat>& umv) const;
    void getGpuMatVector(std::vector<cuda::GpuMat>& gpumv) const;
    cuda::GpuMat getGpuMat() const;
    ogl::Buffer getOGlBuffer() const;

    int getFlags() const;
    void* getObj() const;
    Size getSz() const;

    int kind() const;
    int dims(int i=-1) const;
    int cols(int i=-1) const;
    int rows(int i=-1) const;
    Size size(int i=-1) const;
    int sizend(int* sz, int i=-1) const;
    bool sameSize(const _InputArray& arr) const;
    size_t total(int i=-1) const;
    int type(int i=-1) const;
    int depth(int i=-1) const;
    int channels(int i=-1) const;
    bool isContinuous(int i=-1) const;
    bool isSubmatrix(int i=-1) const;
    bool empty() const;
    void copyTo(const _OutputArray& arr) const;
    void copyTo(const _OutputArray& arr, const _InputArray & mask) const;
    size_t offset(int i=-1) const;
    size_t step(int i=-1) const;
    bool isMat() const;
    bool isUMat() const;
    bool isMatVector() const;
    bool isUMatVector() const;
    bool isMatx() const;
    bool isVector() const;
    bool isGpuMatVector() const;
    ~_InputArray();

protected:
    int flags;
    void* obj;
    Size sz;

    void init(int _flags, const void* _obj);
    void init(int _flags, const void* _obj, Size _sz);
};
```

我们可以发现，其中的一个构造函数是用`Mat`类型进行初始化的。注意这里的一个小细节`class CV_EXPORTS _InputArray`，为什么会有这样的定义出现呢？查看`CV_EXPORTS`的定义发现

```c++
#if (defined _WIN32 || defined WINCE || defined __CYGWIN__) && defined CVAPI_EXPORTS
#  define CV_EXPORTS __declspec(dllexport)
#elif defined __GNUC__ && __GNUC__ >= 4
#  define CV_EXPORTS __attribute__ ((visibility ("default")))
#else
#  define CV_EXPORTS
#endif
```

这样做的目的主要是为了适应不同编译器的需求。以上的内容纯属闲扯，看不懂无所谓，可以跳过，不过我相信有人会对这些东西感兴趣，所以就写出来，^_^！！！

ok，我们再看一下如何读取一个视屏。

显示一段视屏
---

```c++
#include <iostream>  
#include <opencv2\opencv.hpp>
using namespace cv;
int main()
{  
	VideoCapture capture("video.flv");
	while (1)
	{
		Mat frame;				//定义一个Mat变量
		capture >> frame;		//读取当前帧
		imshow("video", frame);	//显示当前帧
		waitKey(30);			//延时30ms
	}
}
```

同样非常简单的一个程序。我们先初始化一个视屏对象(VideoCapture)capture，然后在一个无限循环里面不断地读取每一帧的内容再以图片的方式显示出来。这里要注意的是，这个程序一旦启动是无法停止的。也就是你只可以通过VS2015的菜单栏上的停止按钮去停止它，通过关闭窗口的形式是无法做到的（具体原因前面已经说明了，循环中不断读取每一帧图像并显示）。

如果你的计算机中有摄像头这个硬件设备的话，那么将VideoCapture对象初始化为0，就可以调用摄像头了。
