---
layout: post
title: Leetcode 66：加一（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-10-22 00:00:00
---

给定一个由**整数**组成的**非空**数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

**示例 1:**

```
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
```

**示例 2:**

```
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
```

**解题思路**

这个问题最简单的思路就是先`list to int`，接着`+1`，然后再`int to list`。

```python
class Solution:
    def plusOne(self, digits):
        """
        :type digits: List[int]
        :rtype: List[int]
        """
        num = 0
        for i,val in enumerate(reversed(digits)):
            num += val*10**i
        
        num += 1
        result = list()
        while num:
            tmp = num%10
            num //= 10
            result.append(tmp)

        result.reverse()
        return result
```

但是这种解法是如此的`low`。如果我们能直接对`list`做操作就好了，这实际上是一个`大数计算`的问题。这个问题和[Leetcode 2:两数相加（最详细解决方案！！！）](https://blog.csdn.net/qq_17550379/article/details/80435080)很像，其实关键在于解决什么时候进位以及怎么进位的问题。

实际上这个问题非常简单，因为只有`+1`操作，那么其实输入的数据会成两种情况，一种是全部是`9`的情况（输出的`list`比输入的`list`长`1`），另外一种是除了前面那种的其他所以情况（输出的`list`和输入的`list`一样长）。前面那种情况很简单，我们输出的`list`一定是`[1,0,0...]`形式。对于后者我们就要考虑`list`的每个元素是不是`==9`，如果是的话，那么对应元素变成`0`，否则的话`+1`即可。那么什么时候返回呢？循环中只要出现`+1`就退出循环。

```python
class Solution:
    def plusOne(self, digits):
        """
        :type digits: List[int]
        :rtype: List[int]
        """
        i = len(digits) - 1
        while i >= 0:
            if digits[i] == 9:
                digits[i] = 0
            else:
                digits[i] += 1
                return digits
            i -= 1
        
        digits[0] = 1
        digits.append(0)
        return digits
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**