---
layout: post
title: 	python中的反斜杠问题
category : python
tags : [python, 反斜杠, 正则表达式]
stickie: true
---

0x01 问题引入
---

首先我们要弄清楚，什么是转义字符，以下文字摘自[百度百科](https://baike.baidu.com/item/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/86397?fr=aladdin)

**所有的[ASCII码](https://baike.baidu.com/item/ASCII%E7%A0%81)都可以用“\”加数字（一般是8进制数字）来表示。而C中定义了一些字母前加"\"来表示常见的那些不能显示的ASCII[字符](https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6)，如\0,\t,\n等，就称为转义字符，因为后面的[字符](https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6)，都不是它本来的ASCII字符意思了。**

如果我们要在字符串中使用`\`，必须在前面加上转义符`\\` ，当然在python中也可以这样写`r'\'` ，只要在字符串前面加r即可。

这里我们要注意一个细节**当反斜杠及其紧接字符无法构成一个具有特殊含义的序列('recognized escape sequences')时,Python选择保留全部字符.**

```python
>>> '\c'
'\\c'
>>> '\\c'
'\\c'
>>> '\n'
'\n'
>>> r'\n'
'\\n'
>>> '\\n'
'\\n'
```

0x02 正则表达式中的'\'
---

如果我们想在目标中匹配`\` ，我们根据前面的只是可以轻松写出这样的代码

```python
import re
data = '目标\数据'		#其实是'目标\\数据'
if re.findall('\\', data):
    print 'OK'
else:
    print 'Fail'
```
可是运行时报错：`sre_constants.error: bogus escape: '\\'` ， 这是为什么呢？

原因在于正则表达式中存在一种转义，例如`'\d'`代表数字，`'\s'`代表空白符。也就是说在正则表达式中要做两次转义（一个是字符串，一个是正则表达式）。那上面的错误就很好理解了`\\` 经过字符串转义后变为了`\` ，但是这个时候还要做一次正则转义，自然就报错了。解决办法也很简单`r'\\'` 。

接下来又会想到这样一个问题，我们怎么匹配字符串中的`'\n'` 呢？是这样做吗？

```python
import re
data = r'目标\n数据'	#其实是'目标\\n数据'
if re.findall(r'\\n', data):
    print 'OK'
else:
    print 'fail'
```
结果是OK，也就是说我们的理解是正确的。如果这里我们把`\n`理解为换行符的话代码就要变味

```python
import re
data = '目标\n数据'		#其实是'目标\n数据'
if re.findall('\\n', data):
    print 'OK'
else:
    print 'fail'
```

但是这样问题又来了，如果字符串转义后的字符在正则表达式中有意义怎么办？

```python
>>> '\b'
'\x08'
>>> re.findall('\\b','\b')	#这里的结果是['\x08']吗？
```

结果不是，结果是`[]` 。记下这句话**`b0123456789`比较特殊,它们在Python字面量和re正则中都能和反斜杠构成作用不同的特殊序列.例如`\b`,在python 字面量中解释为"退格键".re正则中解释为'单词边界'。python 字面量有优先解释权。**

在正则表达式中有这样一个细节，**当反斜杠及其紧接字符无法构成一个具有特殊含义的序列(special sequences)时,re选择忽略反斜杠** 。

例如:

```python
>>> re.findall('\e','eee')	#注意还是上面的法则这里'\e'其实是'\\e'
['e', 'e', 'e']
>>> re.findall('e','eee')
['e', 'e', 'e']
```
最后一个非常好的例子：

```python
>>> re.findall('\n','\n\n')
['\n', '\n']
>>> re.findall('\\n','\n\n')
['\n', '\n']
>>> re.findall('\\\n','\n\n')
['\n', '\n']
>>> re.findall('\\\\n','\n\n')
[]
>>> re.findall('\b','\b\b')
['\x08', '\x08']
>>> re.findall('\\b','\b\b')
[]
>>> re.findall('\\\b','\b\b')
['\x08', '\x08']
>>> re.findall('\\\\b','\b\b')
[]
>>> re.findall('\c','\c\c')	#只有这个不同，实际上是'\\c'，但由于re的规则变为了c
['c', 'c']
>>> re.findall('\\c','\c\c')
['c', 'c']
>>> re.findall('\\\c','\c\c')
['\\c', '\\c']
>>> re.findall('\\\\c','\c\c')
['\\c', '\\c']
```
这里就我现在的理解看来是无法匹配出`'\c'`的，当然我的理解有限，欢迎指正。