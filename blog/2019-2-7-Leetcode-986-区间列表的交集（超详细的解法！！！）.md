---
layout: post
title: Leetcode 986：区间列表的交集（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-2-7 00:00:00
---

给定两个由一些**闭区间**组成的列表，每个区间列表都是成对不相交的，并且已经排序。

返回这两个区间列表的交集。

*（形式上，闭区间 [a, b]（其中 a <= b）表示实数 x 的集合，而 a <= x <= b。两个闭区间的交集是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3]。）*

**示例：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2019/01/30/interval1.png" width=500" >
</center>


```
输入：A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]
输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]
注意：输入和所需的输出都是区间对象组成的列表，而不是数组或列表。
```

**提示：**

1. `0 <= A.length < 1000`
2. `0 <= B.length < 1000`
3. `0 <= A[i].start, A[i].end, B[i].start, B[i].end < 10^9`

**解题思路**

这个问题非常简单，类似问题

[Leetcode 56：合并区间（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/83272413)

我们只需要搞清楚哪几种情况就可以非常快速的解决这个问题。我们假设遍历到的区间分别是`ia`和`ib`，那么区间主要分为以下几种可能性

- `ib.end < ia.start`，此时我们应该继续判断`B`的下一个区间
- `ib.start > ia.end`，此时我们应该继续判断`A`的下一个区间
- `ia.start > ib.start and ia.end < ib.end`，此时`ib`包含`ia`，那么交集就是`ia`。
- `ia.start < ib.start and ia.end > ib.end`，此时`ia`包含`ib`，那么交集就是`ib`。
- 剩下就是`ia`和`ib`相交的情况，那么我们取`max(ia.start, ib.start), min(ia.end, ib.end)`即可。

```python
class Solution:
    def intervalIntersection(self, A: 'List[Interval]', B: 'List[Interval]') -> 'List[Interval]':
        res = list()
        for ia in A:
            for ib in B:
                if ib.end < ia.start:
                    continue
                if ib.start > ia.end:
                    break
                if ia.start > ib.start and ia.end < ib.end:
                    res.append(Interval(ia.start, ia.end))
                elif ia.start < ib.start and ia.end > ib.end:
                    res.append(Interval(ib.start, ib.end))
                else:
                    res.append(Interval(max(ia.start, ib.start), min(ia.end, ib.end)))
                    
        return res
```

参考答案的写法更加简洁，所以我在这里直接引用

```python
class Solution:
    def intervalIntersection(self, A: 'List[Interval]', B: 'List[Interval]') -> 'List[Interval]':
        res = list()
        i = j = 0
        while i < len(A) and j < len(B):
            l = max(A[i].start, B[j].start)
            r = min(A[i].end, B[j].end)
            if l <= r:
                res.append(Interval(l, r))
                
            if A[i].end < B[j].end:
                i += 1
            else:
                j += 1
                
        return res
```

reference:

https://leetcode.com/problems/interval-list-intersections/solution/

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**