---
layout: post
title: 深度探索c++对象模型(7)
category : cpp
tags : [cpp]
---

dynamic_cast深入
---

我在之前的文章里面有介绍过[dynamic_cast](http://www.coordinate.wang/cpp/2017/04/08/cast.html) ，但是对于它背后的实现原理一直没有探究，所以我会在本文中深入探究他背后的东西。

之所以要使用dynamic_cast，主要就是解决downcast不安全的问题。

```c++
class node{};
class type:public node {};
class fct: public type{};
class gen: public type{};
typedef type* ptype;
typedef fct* pfct;
simplify_conv_op(ptype pt)
{
    if(pfct pf = dynamic_cast<pfct>(pt)){}
    else{}
}
```

pt指向的class object类型描述器必须在执行期通过vptr取得，下面是一种可能的编译器转换形式

```c++
((type_info*)(pt->vptr[0]))->_type_descriptor;
```

type_info是c++ standard所定义的类型描述器的class名称，virtual的第一个slot内含type_info object的地址。你可能对于这里有疑问了，我在之前有写过[深度探索c++对象模型(4)](http://www.coordinate.wang/cpp/2017/08/07/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B(4).html) ，我在最后留有一个还没有解决的问题？对，之前那个没有解决的问题 `_meta`  ，就是type_info，而且最后画的那张图应该就要变成这样


<a href="http://wx4.sinaimg.cn/mw690/af2d2659ly1fjtn38c0akj20je0f04f9.jpg" data-lightbox="roadtrip">
<img src="http://wx4.sinaimg.cn/mw690/af2d2659ly1fjtn38c0akj20je0f04f9.jpg" class="img-fluid">
</a>

当然这里我又再次忘记了左边的两个后面补0  ): 。

references和pointers并不同
---

如果你对这个标题感到非常的疑惑，你认为这两个就是不同的。好吧，接下去的内容你都可以忽略了。因为如果你是一个菜鸟，你当然理解不了他们之间何其相似；如果你对c++很熟悉的话，那你一定知道这两个之间的区别。

程序执行中对一个 class 指针类型施以 dynamic_cast 运算符,会获得 true 或 false:

- 如果传回真正的地址，表示这个object的动态类型被确认了，一些与类型有关的操作现在可以作用于其上。
- 如果传回0，表示没有指向任何object，意味着应该以另一种逻辑施行于这个动态类型未确定的object上。

很多时候我也是觉得reference和pointer没有区别，确实，这两者确实在一般的情况下可以看成等同。但是，dynamic_cast运算符用在reference上面就会出一些问题。为什么？一个reference不可以像pointer那样把0当作no object看待。如果把一个reference设为0，会引起一个临时对象，如下：

```c++
const point<float> &ref = 0;
```

它会instantiate一个point的float的实体。

```c++
point<float> temporary(float(0));
const point<float> &ref = temporary;
```

因为reference并不是no object的代名词。0被视为整数，必须别转换为一下类型的对象：

```c++
point<float>
```

因此当dynamic_cast运算符运用一个reference时，不能够提供对等于指针情况下的那一组true/false。取而代之会发生下面的事：

- 如果reference真正参考到适当的derived class，downcast会被执行。
- 如果reference并不是真正的是某种derived class，那么，由于不能传回0，所以丢出一个bad_cast execption

如下：

```c++
simplify_conv_op(const type &rt)
{
    try
    {
        fct &rf = dynamic_cast<fct&>(rt);
    }
    catch(bad_cast)
    {}
}
```

结果也是很显然的表现出某种execption failure

那我么要怎么才可以使用reference呢？

Typeid运算符
---

```c++
simplify_conv_op(const type &rt)
{
    if(typeid(rt) == typeid(fct))
    {
		fct &rf = dynamic_cast<fct&>(rt);
    }
	else{}
}
```

这样做就可以了。

typeid运算符返回一个const reference，类型是*type_info*。