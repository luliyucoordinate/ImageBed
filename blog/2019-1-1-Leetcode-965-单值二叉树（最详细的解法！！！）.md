---
layout: post
title: Leetcode 965：单值二叉树（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-1 00:00:00
---

如果二叉树每个节点都具有相同的值，那么该二叉树就是*单值*二叉树。

只有给定的树是单值二叉树时，才返回 `true`；否则返回 `false`。

**示例 1：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2018/12/28/unival_bst_1.png" width="250">
</center>

```
输入：[1,1,1,1,1,null,1]
输出：true
```

**示例 2：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2018/12/28/unival_bst_2.png" width="200">
</center>

```
输入：[2,2,2,5,2]
输出：false
```

**提示：**

1. 给定树的节点数范围是 `[1, 100]`。
2. 每个节点的值都是整数，范围为 `[0, 99]` 。

**解题思路**

这个问题非常简单，首先想到的解法就是遍历二分搜索树的结果，将结果存放到`list`中，然后遍历`list`查看是够有重复元素即可。

[Leetcode 144:二叉树的前序遍历（最优雅的解法！！！）](https://mp.csdn.net/postedit/80731041)

[Leetcode 94:二叉树的中序遍历（最优雅的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/80809930)

[Leetcode 145:二叉树的后序遍历（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/81044345)

```python
class Solution:
    def isUnivalTree(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        
        tree = list()
        self.inOrder(root, tree)
        pre = root.val
        for i in tree:
            if i != None and i != pre:
                return False
            
        return True
            
    def inOrder(self, root, tree):
        if root:
            self.inOrder(root.left, tree)
            tree.append(root.val)
            self.inOrder(root.right, tree)
```

更简洁的写法。

```python
class Solution:    
    def isUnivalTree(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        
        if (root.left and root.val != root.left.val) or (root.right and root.val != root.right.val):
            return False
        
        return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)
```

最简洁的写法。

```python
class Solution:
    def isUnivalTree(self, root, val=-1):
        """
        :type root: TreeNode
        :rtype: bool
        """      
        return root == None or ((val == -1 or root.val == val) and \
        self.isUnivalTree(root.left, root.val) and self.isUnivalTree(root.right, root.val))
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**