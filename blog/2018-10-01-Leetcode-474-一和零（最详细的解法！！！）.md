---
layout: post
title: Leetcode 474：一和零（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-10-01 00:00:00
---

在计算机界中，我们总是追求用有限的资源获取最大的收益。

现在，假设你分别支配着 **m** 个 `0` 和 **n** 个 `1`。另外，还有一个仅包含 `0` 和 `1` 字符串的数组。

你的任务是使用给定的 **m** 个 `0` 和 **n** 个 `1` ，找到能拼出存在于数组中的字符串的最大数量。每个 `0` 和 `1` 至多被使用**一次**。

**注意:**

1. 给定 `0` 和 `1` 的数量都不会超过 `100`。
2. 给定字符串数组的长度不会超过 `600`。

**示例 1:**

```
输入: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
输出: 4

解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 "10","0001","1","0" 。
```

**示例 2:**

```
输入: Array = {"10", "0", "1"}, m = 1, n = 1
输出: 2

解释: 你可以拼出 "10"，但之后就没有剩余数字了。更好的选择是拼出 "0" 和 "1" 。
```

**解题思路**

首先想到的解法依旧是暴力解法。我们首先将输入的`strs`建立成一个`nx2`的数组，将`0`个`1`的个数填入其中。例如

```
Array = {"10", "0001", "111001", "1", "0"}
counter = [[1, 1], [3, 1], [2, 4], [0, 1], [1, 0]]
```

接下来问题就很容易了，我们要知道`m=5 n=3`由哪些元素构成，我们对于`array[0]`来说只需要知道`m=4 n=2`最少由哪些元素构成，对于`array[1]`来说只需要知道`m=2 n=2`最少由那些元素构成。以此类推下去，我们只要取其中的最小值即可。

```
f(m, n) = max(f(m-counter))
```

通过这个过程写出下面的代码

```python
class Solution:
    def findMaxForm(self, strs, m, n):
        """
        :type strs: List[str]
        :type m: int
        :type n: int
        :rtype: int
        """
        counter = list()
        for i in strs:
            counter.append([i.count('0'), i.count('1')])

        result = float('-inf')

        def _findMaxForm(counter, index, m, n, count):
            nonlocal result
            if m == 0 and n == 0:
                result = max(result, count)

            for i in range(index, len(counter)):
                if m - counter[i][0] >= 0 and n - counter[i][1] >= 0:
                    _findMaxForm(counter, index + 1, m - counter[i][0], n - counter[i][1], count + 1)

        _findMaxForm(counter, 0, m, n, 0)
        return result
```

我们也可以通过另外一种思维，思考这个问题。我们只要考虑`counter`种的每个元素，加或者不加对最后的结果影响是怎么样的即可。也就是

```
f(m, n, i+1) = max(f(m, n, i), f(m - counter[i][0], n - counter[i][1], i))
```

我们可以写出这样的代码

```python
class Solution:
    def findMaxForm(self, strs, m, n):
        """
        :type strs: List[str]
        :type m: int
        :type n: int
        :rtype: int
        """
        counter = list()
        for i in strs:
            counter.append([i.count('0'), i.count('1')])

        def _findMaxForm(counter, index, m, n):
            if m < 0 or n < 0:
                return -1

            if index == len(counter):
                return 0

            select = _findMaxForm(counter, index + 1, m - counter[index][0], n - counter[index][1]) + 1
            noselect = _findMaxForm(counter, index + 1, m, n)

            return max(select, noselect)

        return _findMaxForm(counter, 0, m, n)
```

对于上面这个代码，我们就可以通过记忆化搜索的方式进行优化。这里的方式和之前的一些问题不同，我们不能仅仅建立一个`mem[index]`的记忆数组，因为`m&n`都对后续状态有影响，所以我们这里应当建立`mem[m][n][index]`这样的数组。

```python
class Solution:
    def findMaxForm(self, strs, m, n):
        """
        :type strs: List[str]
        :type m: int
        :type n: int
        :rtype: int
        """
        counter = [[i.count('0'), i.count('1')] for i in strs]
        mem = [[[-1]*len(counter) for _ in range(n+1)] for _ in range(m+1)]
        return self._findMaxForm(counter, 0, m, n, mem)

    def _findMaxForm(self, counter, index, m, n, mem):
        if m < 0 or n < 0:
            return -1

        if index == len(counter):
            return 0

        if mem[m][n][index] != -1:
            return mem[m][n][index]

        select = self._findMaxForm(counter, index + 1, m - counter[index][0], \
                                            n - counter[index][1], mem) + 1
        noselect = self._findMaxForm(counter, index + 1, m, n, mem)

        mem[m][n][index] = max(select, noselect)
        return mem[m][n][index]
```

但是这种做法在`leetcode`上没有通过，超时了，嗯~ o(*￣▽￣*)o，这是目前碰到的为数不多的通过记忆化搜索优化后依然超时的题目。

我们看看这个问题可不可以用动态规划，这里的转移方程也很容易写出

```
mem[m][n] = max(mem[m][n], mem[m-counter[i][0]][n-counter[i][1]]+1)
```

其实和上面是一样的，只是代码书写上一些区别。借此，我们可以写出下面代码

```python
class Solution:
    def findMaxForm(self, strs, m, n):
        """
        :type strs: List[str]
        :type m: int
        :type n: int
        :rtype: int
        """
        mem = [[0]*(n+1) for _ in range(m+1)]
        counter = [[i.count('0'), i.count('1')] for i in strs]
        for c in range(len(counter)):
            for i in range(m, counter[c][0]-1, -1):
                for j in range(n, counter[c][1]-1, -1):
                    mem[i][j] = max(mem[i][j], mem[i-counter[c][0]][j-counter[c][1]] + 1)

        return mem[m][n]
```

同样超时了，意料之中，毕竟思想和前面的一样，也就是说这个问题继续使用这种思想肯定是不行了。

我们有一种更快的做法，我们首先将我们前面得到的`counter`按照`-min(m-counter[i][0], n-counter[i][1])`排序，我们就得到了

```python
arr1 = [[1, 0], [1, 1], [3, 1], [0, 1], [2, 4]] 
```

我们将`counter`按照`min(counter[i][0], counter[i][1])`排序，我们就得到了

```python
arr2 = [[0, 1], [1, 0], [1, 1], [3, 1], [2, 4]]
```

然后我们分别将`arr1`和`arr2`的每个元素放入到`m n`中，也就是通过`m n`减去`arr1`和`arr2`对应的每个元素中的`index:0 & 1`，最后只要比较`arr1`放入的元素多还是`arr2`放入的元素多，取最大值即可。

```python
class Solution:
    def findMaxForm(self, strs, m, n):
        """
        :type strs: List[str]
        :type m: int
        :type n: int
        :rtype: int
        """
        counter = [[i.count('0'), i.count('1')] for i in strs]
        arr1 = sorted(counter, key=lambda s: -min(m - s[0], n - s[1]))
        arr2 = sorted(counter, key=lambda s: min(s[0], s[1]))
        return max(self._findMaxForm(arr1, m, n), self._findMaxForm(arr2, m, n))

    def _findMaxForm(self, arr, m, n):
        result = 0

        for per in arr:
            if m >= per[0] and n >= per[1]:
                result += 1
                m -= per[0]
                n -= per[1]

        return result
```

通过这个算法我们在`c++`分区打出了暴击，耗时仅仅`4ms`，最少应该是`Top 10`那种级别的，非常不错！！！

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**