---
layout: post
title: Go语言分布式网络爬虫（3）
category : go
tags : [go]
stickie: true
date: 2019-6-28 00:00:00
---

继续上次没有处理完的问题，也就是字体的处理。我大概知道一些处理思路（通过`go`的`freetype`这个包，不过需要改写一些代码），由于本人现在水平有限（毕竟才学一个星期的`golang`，QAQ），而且`font`的这个编码规范也没搞懂，所以暂时放一放，现将功能实现再说。所以我通过查看一些博客，找到了一个[折中的处理办法](https://blog.csdn.net/weixin_42654444/article/details/89279741)，就是通过`go`调用`python`的`fonttools`包。O(∩_∩)O哈！感觉贼蠢，但是没有办法啊！！！

我们首先将`font`目录移动到`engine`目录下，然后编写`font`转换函数

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/Tiny-Go-Spider/lesson4/2019_6_28_1.png" width="300">
</center>

```go
// engine/font/font.go
func BuildFontFile() {
	cmd := exec.Command("ttx", fontName)
	_, err := cmd.CombinedOutput()
	if err != nil {
		log.Printf("Font: build font error: %v", err)
	}
}
```

我们需要处理转换后得到`xml`文件（实际中为`ttx`文件），所以我们先安装`dom4g`

```shell
gopm get -g -v github.com/donnie4w/dom4g
```

接着编写最后的处理函数

```go
// engine/font/font.go
func GetFontMap(contents []byte) map[string]string {
	GetFontFile(contents)
	BuildFontFile()

	res := make(map[string]string)
	file, err := os.Open(ttxFile)
	if err != nil {
		log.Printf("Font: get font map error: %v", err)
	}
	ele, err := dom4g.LoadByStream(file)
	if err != nil {
		log.Printf("Font: get font map error: %v", err)
	}

	eles := ele.Node("cmap").Node("cmap_format_4").Nodes("map")

	for _, v := range eles {
		code, _ := v.AttrValue("code")
		name, _ := v.AttrValue("name")

		num, err := strconv.Atoi(name[len(name)-2:])

		if err != nil {
			log.Printf("Font: get font map error: %v", err)
		}
		res[code] = strconv.Itoa(num-1)
	}
	return res
}
```

我们测试一下，编写一个简单的测试函数`font_test.go`

```go
// engine/font/font_test.go
func TestFont(t *testing.T) {
	file, _ := fetcher.Fetch("https://hf.58.com/hezu/38560664837252x.shtml?shangquan=datonglu")
	fmt.Println(GetFontMap(file))
}
```

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/Tiny-Go-Spider/lesson4/2019_6_28_2.png" width="600">
</center>

ok!工作了。但是我们发现出现了一个小问题，就是`font`目录下出现了很多`.ttx`文件，所以我们需要处理这个问题

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/Tiny-Go-Spider/lesson4/2019_6_28_3.png" width="200">
</center>

首先我们需要对`ttf`文件取名字，这是一个比较麻烦的问题，因为很多个`ttf`，我们需要将他们区分开。我们想到了`hash`，我们可以对之前`base64`解码前的文件进行`hash`

```go
// engine/font/font.go
func GetFontFile(contents []byte) {
	re := regexp.MustCompile(`base64,(.*?)'`)
	bs4 := re.FindSubmatch(contents)

	fontName = strconv.FormatUint(uint64(crc32.ChecksumIEEE(bs4[1])), 10)
	...
}
```

并且我们在使用完文件后需要将它们删除，使用`defer`轻松完成

```go
// engine/font/font.go
func GetFontMap(contents []byte) map[string]string {
	GetFontFile(contents)
	BuildFontFile()
	defer os.Remove(fontName)
	defer os.Remove(fontName+".ttx")
    ...
}
```

当然你也可以使用临时文件的方式处理这个问题，我这里为了简单起见就这么做了。

好的，一切就绪，我们测试一下现在的代码！！！go!go!go!

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/Tiny-Go-Spider/lesson4/2019_6_28_4.png" width="600">
</center>
好的，工作的不错，O(∩_∩)O哈哈~

至此我们这一小节的内容完成，我们提交代码到`github`。现在我们这个爬虫的基本功能已经完成，接下来我们需要做一个高并发的本版。

**如果你觉得上述过程对你有一点困难，没关系，可以查看我的[Tiny-Go-Crawler lesson3](https://github.com/luliyucoordinate/Tiny-Go-Crawler/tree/master/lesson3)代码。**

**如有问题，希望大家指出！！！**

reference:

https://blog.csdn.net/weixin_42654444/article/details/89279741