---
layout: post
title: QT
category : QT
tags : [QT , cpp]
stickie: true
---


Qt
===


Qt图形界面
---

界面设计，双击dialog.ui进入

<a href="http://wx2.sinaimg.cn/mw690/af2d2659gy1fdq5vuoq99j21f60u0436.jpg" data-lightbox="roadtrip">
<img src="http://wx2.sinaimg.cn/mw690/af2d2659gy1fdq5vuoq99j21f60u0436.jpg" class="img-fluid">
</a>


属性窗口

<a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fdq5vv8mb2j209a0ef0t4.jpg" data-lightbox="roadtrip">
<img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fdq5vv8mb2j209a0ef0t4.jpg" class="img-fluid">
</a>


右点击控件Go to slot，点击clicked

<a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fdq5vwbyg5j20ec06ajrd.jpg" data-lightbox="roadtrip">
<img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fdq5vwbyg5j20ec06ajrd.jpg" class="img-fluid">
</a>

头文件中增加
```c++
private slots:
    void on_pushButton_clicked();
```
cpp文件中增加

```c++
void Widget::on_pushButton_clicked()
{
    QString s1 = ui->lineEdit->text();
    QString s2 = ui->lineEdit_2->text();
    int a = s1.toInt() + s2.toInt();
    ui->label->setText(QString::number(a));
}
```
再把文件打包给别人使用时，要删除文件夹内的pro文件


qt代码实现界面
---

头文件
```c++
#include <QDialog>
#include <QPushButton>
#include <QLineEdit>
#include <QLabel>
#include <QGridLayout>
```
Cpp文件

```c++
btn1 = new QPushButton(this);
edit1 = new QLineEdit(this);
edit2 = new QLineEdit(this);
label1 = new QLabel(this);
btn1->setText("sum");
QGridLayout *layout = new QGridLayout(this);
// QGridLayout *layout = new QGridLayout();
//this->setLayout(layout);
layout->addWidget(edit1, 0, 0);
layout->addWidget(edit2, 0, 1);
layout->addWidget(btn1, 1, 0);
layout->addWidget(label1, 1, 1);
connect(btn1, SIGNAL(clicked()), this, SLOT(add()));
```

在qt中使用相关的容器控件不需要delete  
要注意的是如果控件变量没有附加到widget  
如btn1 = new QPushButton();  
并且没有写layout->addWidget(btn1, 0, 0);  
那就要写delete



控件的事件响应函数
---

头文件

```c++
private slots:
void add();
```
cpp文件

```c++
connect(btn1, SIGNAL(clicked()), this, SLOT(add()));

QString().isNULL();             //true
QString().isEmpty();            //true
QString(“”).isNULL();           //false
QString(“”).isEmpty();          //true
```

一个NULL字符串一定是一个空字符串，但一个空字符串不一定是一个NULL字符串  
null表示未指向任何对象  
而""，表示一个没有内容的字符串



QDateTime类
---
```
<QDateTime>
```
可以使用这个类获取系统时间。通过QDateTime::currentDateTime()来获取本地系统的时间和日期信号。  
可以通过date()和time()来返回datetime中的日期和时间

```c++
QDateTime *dateTime = new QDateTime(QDateTime::currentDateTime());
QString s = dataTime->date().toString();
```


QTimer类
---

新建定时器

```c++
QTimer *time_clock = new QTimer(this);
```
链接这个定时期的信号和槽，利用定时器的timeout()

```c++
connect(time_clock, SIGNAL(timeout()), this, SLOT(slottimedone()));
time_clock->start(2000);
```
开启定时器，并设置定时周期  
定时器定时有两种，start(int time)和setSingleShot(true)。  
其中第一个函数表示每隔”time”秒就会重启定时器，利用stop()将定时器关掉，而后者表示近启动一次。前者比较常用。


创建窗口
---

如果Widget未使用父级进行创建，则在显示视为窗口或顶层Wiget。  
由于顶层Widget没有父级对象类来确保对其不再使用时就删除，所以需要开发人员在应用程序中对其进行追踪。  
在本例中，使用QWiget创建和显示具有默认大小的窗口

```c++
QWidget *window = new QWidget();    //注意一个问题，此时是在堆里面的
window->resize(320, 240);
window->show();
QPushButton *button = new QPushButton(tr(“press me”), window);
button->move(100, 100);
button->show();
```
针对于上面的问题  
下面的方式，是在栈里面，所以效果是一闪而过

```c++
QWidget window;
window.resize(320, 240)
window.show();
```
widget适合非模式的对话框，dialog适合模式的对话框



字符图形界面
===

-lcurses 编译时要加这个库文件
```c++
int main(){
       initscr();         //begin graphic model
       neocho();              //not echo
       chartemp[128];
       chars[128];
       intseq = 0;
       while(scanf("%s",s)){
              if(stramp(s,"exit") == 0){
                     break;
              }
              clear();    //cls
              sprintf(temp,"please input:\n");
              mvaddstr(0,0, temp);   //print at the specifiedcoordinate
              inti = 0;
              for(;i < 10; ++i){
                     sprintf(temp,"%s %d %s ",s seq++,s);
                     mvaddr(i+ 1, 0, temp);
	     	   }
              movd(0,13);  //move cursor to the specifiedcoordinate
              refresh();        //refresh 
       }
       endwin();
       return0;
}
```


积累
===
```
iconv --list                 //查看字符编码
<iconv.h>
iconv_t iconv_open(const char *tocode,const char *fromcode);      //linux转化字符集
size_t iconv(iconv_t cd, char **inbuf,size_t *inbytesleft,
             char **outbuf, size_t *outbytesleft);
```
iconv_close()       最后要调用close函数  
第一步  
iconv_open(目标字符集，源字符集)  
第二步  
iconv()实现字符集转化  
第三部  
iconv_close()关闭iconv  
 

建立文件链接  
ln libGL.so.1 libGL.so
 
```c++
class abc{
	public:
	const char*getp(){    //注意要返回const，以防别人外部修改私有变量
   		 return p;
	}
	private:
	char *p;
}
```
如果将const char *强转为char *，c++会复制一个空间出来  
如char *s = (char *)p;  
p是一个const char *类型，则p与s所指向的空间不同

