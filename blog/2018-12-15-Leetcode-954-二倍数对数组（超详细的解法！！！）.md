---
layout: post
title: Leetcode 954：二倍数对数组（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-12-15 00:00:00
---

给定一个长度为偶数的整数数组 `A`，只有对 `A` 进行重组后可以满足 “对于每个 `0 <= i < len(A) / 2`，都有 `A[2 * i + 1] = 2 * A[2 * i]`” 时，返回 `true`；否则，返回 `false`。

**示例 1：**

```
输入：[3,1,3,6]
输出：false
```

**示例 2：**

```
输入：[2,1,2,6]
输出：false
```

**示例 3：**

```
输入：[4,-2,2,-4]
输出：true
解释：我们可以用 [-2,-4] 和 [2,4] 这两组组成 [-2,-4,2,4] 或是 [2,4,-2,-4]
```

**示例 4：**

```
输入：[1,2,4,16,8,4]
输出：false
```

**提示：**

1. `0 <= A.length <= 30000`
2. `A.length` 为偶数
3. `-100000 <= A[i] <= 100000`

**解题思路**

我们首先统计输入数组中所有元素出现的次数。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/954/2018_12_17_1.png" width="300" hegiht="200">
</center>

将统计后的字典按照`key`的绝对值排序。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/954/2018_12_17_2.png" width="300" hegiht="200">
</center>

此时我们只要判断字典中的当前数字的个数`dict[i]`是不是大于`dict[2*i]`，如果是的话，那么显然不能构成二倍数对数组，如果不是的话，我们更新`dict[2*i] -= dict[i]`。为什么呢？因为可能出现这种情况`{1:1, 2:2, 4:1}`。

```python
from collections import Counter
class Solution:
    def canReorderDoubled(self, A):
        """
        :type A: List[int]
        :rtype: bool
        """
        A_dict = Counter(A)
        
        for x in sorted(A_dict, key=lambda x: abs(x)):
            if A_dict[x] > A_dict[2*x]:
                return False
            
            A_dict[2*x] -= A_dict[x]
        return True  
```

reference:

https://leetcode.com/problems/array-of-doubled-pairs/discuss/203183/JavaC++Python-Match-from-the-Smallest-or-Biggest-100

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**