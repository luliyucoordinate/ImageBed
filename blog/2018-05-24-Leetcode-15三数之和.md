---
layout: post
title: Leetcode 15:三数之和
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-05-24 00:00:00
---

给定一个包含 *n* 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 ？找出所有满足条件且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

```
例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，
满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

**解题思路**

我们首先想到的解法是通过三重循环，于是我就写出了如下代码：

```python
class Solution:
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        result = []
        for i, a in enumerate(nums):
            for j, b in enumerate(nums[i + 1:]):
                for _, c in enumerate(nums[j + i + 2:]):
                    if a + b + c == 0:
                        result.append([a, b, c])
        return result
```

但是上面这个代码是有问题的，因为我们没有考虑`结果重复的问题`。接着我们想到可以通过`collections.Counter`记录所有数字出现的次数，如果前后有相同的话，我们就不添加到`result`中去。于是就有了下面的写法

```python
class Solution:
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        from collections import Counter
        k = []
        result = []
        for i, a in enumerate(nums):
            for j, b in enumerate(nums[i + 1:]):
                for _, c in enumerate(nums[j + i + 2:]):
                    if a + b + c == 0 and Counter([a, b, c]) not in k:
                        k.append(Counter([a, b, c]))
        for i in k:
            result.append(list(i.elements()))
        return result
```

但是这种写法的缺点很明显，算法的时间复杂度是`O(n^3)`这个级别的。我们能不能优化到`O(n^2)`这个级别呢？我们可以参考[Leetcode 1:两数之和（最详细解决方案！！！）](https://blog.csdn.net/qq_17550379/article/details/80435039)文中的方法，通过一个`hash`表来记录`nums`中所有元素出现的次数。

```python
class Solution:
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        nums_hash = {}
        result = list()
        for num in nums:
            nums_hash[num] = nums_hash.get(num, 0) + 1
        if 0 in nums_hash and nums_hash[0] >= 3:
            result.append([0, 0, 0])

        nums = sorted(list(nums_hash.keys())) # trick

        for i, num in enumerate(nums):
            for j in nums[i+1:]:
                if num*2 + j == 0 and nums_hash[num] >= 2:
                    result.append([num, num, j])
                if j*2 + num == 0 and nums_hash[j] >= 2:
                    result.append([j, j, num])
                
                dif = 0 - num - j
                if dif > j and dif in nums_hash: # trick
                    result.append([num, j, dif])
                    
        return result
```

注意上面写法中的`trick`，我们通过对`nums_key`的排序，这样我们就可以确定存入结果中的`list`中元素的顺序，这样就可以避免重复存入相同的元素。（大多数避免重复的问题，思路都是排序）

当然这个算法还有优化的空间，我们知道三个数和为`0`，那么在三个数不全为`0`的情况下，必然有一个正数和一个负数，那么我们可以通过两个`list`去存取`nums`中含有`不重复元素的正数和负数`。那样我们就不用`O(n^2)`（`n=len(nums)`）的时间，而只需要`O(n*m)`（`n+m=len(nums)`）的时间复杂度。

另外我们还知道一个条件，对于`a,b,c`三个数，如果`a`是正数，`b`是负数，那么`-c`一定比`b`大，或者比`a`小。

例如：

```
a = 1
b = -2 
c = 1    -c = -1

a = 3
b = -2
c = -1   -c = 1
同时也很好证明
-c = (a + b)即-c - a = b a>0  -> -c > b
-c = (a + b)即-c - b = a b<0  -> -c < a
```

所以我们可以这样去解这个问题。

```python
class Solution:
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        nums_hash = {}
        result = list()
        for num in nums:
            nums_hash[num] = nums_hash.get(num, 0) + 1
        if 0 in nums_hash and nums_hash[0] >= 3:
            result.append([0, 0, 0])

        neg = list(filter(lambda x: x < 0, nums_hash))
        pos = list(filter(lambda x: x>= 0, nums_hash))

        for i in neg:
            for j in pos:
                dif = 0 - i - j
                if dif in nums_hash:
                    if dif in (i, j) and nums_hash[dif] >= 2:
                        result.append([i, j, dif])
                    if dif < i or dif > j:
                        result.append([i, j, dif])
                    
        return result
```

此处应有掌声，非常好的解法是不是O(∩_∩)O

另外这个问题我们也可以使用[Leetcode 167:两数之和 II - 输入有序数组（最详细解决方案！！！）](https://blog.csdn.net/qq_17550379/article/details/80512745)这篇文章中提到的对撞指针的思路。我们首先要将`nums`排序。

```
-4 -1 -1  0  1  2
i   l           r
l = i+1
```

我们先要对`nums`排序，然后我们只要考虑`nums[i] <= 0`的部分，因为当`nums[i] > 0`时，必然会造成`nums[i], nums[l], nums[r]`全部`>0`，这显然不对。当`i > 0`时，我们要考虑`nums[i - 1] == nums[i]`，如果成立，我们要跳出本次循环，执行`++i`，直到不成立为止。

所以我们就有了如下的做法

```python
class Solution:
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        result = list()
        nums_len = len(nums)
        if nums_len < 3:
            return result
        l, r, dif = 0, 0, 0
        nums.sort()
        for i in range(nums_len - 2):
            if nums[i] > 0: 
                break
            if i > 0 and nums[i - 1] == nums[i]:
                continue

            l = i + 1
            r = nums_len - 1
            dif = -nums[i]
            while l < r:
                if nums[l] + nums[r] == dif:
                    result.append([nums[l], nums[r], nums[i]])
                    while l < r and nums[l] == nums[l + 1]:
                        l += 1
                    while l < r and nums[r] == nums[r - 1]:
                        r -= 1
                    l += 1
                    r -= 1
                elif nums[l] + nums[r] < dif:
                    l += 1
                else:
                    r -= 1
        
        return result
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**