---
layout: post
title: Leetcode 287：寻找重复数（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-09 00:00:00
---

给定一个包含 *n* + 1 个整数的数组 *nums*，其数字都在 1 到 *n* 之间（包括 1 和 *n*），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

**示例 1:**

```
输入: [1,3,4,2,2]
输出: 2
```

**示例 2:**

```
输入: [3,1,3,4,2]
输出: 3
```

**说明：**

1. **不能**更改原数组（假设数组是只读的）。
2. 只能使用额外的 *O*(1) 的空间。
3. 时间复杂度小于 *O*(*n*2) 。
4. 数组中只有一个重复的数字，但它可能不止重复出现一次。

**解题思路**

我们首先想到的解法就是先将数组`nums`排序，建立`pre`和`cur`两个指针，分别指向前面一个元素和当前元素，然后对于排序好的`nums`从头到尾的遍历，判断`nums[pre]==nums[cur]`，如果成立，返回`nums[pre]`即可，否则的话继续遍历。

```python
class Solution:
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums.sort()
        for i in range(len(nums)-1):
            if nums[i] == nums[i+1]:
                return nums[i]
```

但是我们这种做法改变了原有的数组，所以这种做法就被我们排除了。由于是查找问题，我们不难想到通过二分搜索法，但是这里我们要将原来的二分搜索法做一些调整。我们首先计算`mid`，然后我们统计数组中小于等于`mid`元素的个数`k`，如果`k<=mid`的话，那么说明重复值在`[mid+1,n]`之间，否则的话重复值在`[1,mid]`之间。为什么这样子做是合理的呢？实际上这个问题的思想来源于抽屉原理，我们将包含重复元素的所有数放到一个可以容纳所有数的数组中去，如下

```
1  2  3  4
__________
1  2  3  4
   2
```

如果采用下整除策略，此时我们的`mid=2`，我们发现此时**左边元素个数大于右边元素个数**，这就是由于重复元素造成的两边不平衡，如果没有重复元素，两边数的个数应该是一样的。我们现在再回到我们的算法，看它是怎么和抽屉原理联系起来的。

```
1  3  4  2  2
mid=2
```

我们此时的`mid=2`（也就是中间抽屉的位置），我们接着统计小于等于`2`的数的个数（统计抽屉左边元素个数），也就是`k=3`，而`3>2`，所以我们在`[1,2]`这个区间中找重复元素（抽屉左边找重复元素），再次计算`mid=1`，我们发现`k=1<=1`，此时我们就知道了`2`即为重复元素。

```python
class Solution:
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        low, high = 1, len(nums)-1
        
        while low < high:
            mid = (high+low)//2
            count = sum(num <= mid for num in nums)
            if count <= mid:
                low = mid+1
            else:
                high = mid
        return low
```

这个问题有一个非常巧妙的解法，我们看上面的例子

```
1  3  4  2  2
```

如果我们使用`t=nums[t]`这样的前进方式，我们首先令`t=0`

```
t=nums[0]=1
t=nums[1]=3
t=nums[3]=2
t=nums[2]=4
t=nums[4]=2
t=nums[2]=4
...
```

我们发现进入了循环。我们再使用`t=nums[nums[t]]`这样的前进策略

```
t=nums[nums[0]]=3
t=nums[nums[3]]=4
t=nums[nums[4]]=4
....
```

其实就是比前面快了一倍。这就变成了之前[Leetcode 142：环形链表 II（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/83866910)的问题，我们可以使用快慢指针解决。

reference:

http://keithschwarz.com/interesting/code/?dir=find-duplicate

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**