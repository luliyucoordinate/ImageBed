---
layout: post
title: linux Day9
category : linux
tags : [linux, network, c]
stickie: true
---


TCP/IP与套接字
===

通过进程通信可以实现同一计算机上不同进程之间的通信  
通过网络编程可以实现在网络中的各个计算机之间的通信  
进程能过通过套接字实现与其他进程或者其他计算机通信  
套接字是通信段点的抽象  
与文件描述符一样，套接字需要使用套接字描述符  
一对对接的套接字接口构成了进程间的数据交流的一个通道  
这些进程在不同平台都可以使用  
Internet域套接字用于用于联网通信，他们给可以支持几乎任何TCP/IP的网络通信程序上。  
1.  TCP先连接（三次握手）  
client->server:发送SYN a  
server->client:回复SYN b,ack a+1  
client->server:ack b+1

2.  链接通了，双方可以互相收发消息

3.  断开连接  
client->server:FIN m  
server->client:ack m+1  
server->client:FIN n  
client->server:ack n+1

```c
<sys/types.h>
<sys/socket.h>
<arpa/inet.h>
<netinet/in.h>
int socket(int domain, int type, int ptotocol)
```
成功返回套接字描述符，失败返回-1，并设置errno  
protocol一般为0  
domain说明  
AF_UNIX        unix内部使用  
AF_INET        TCP/IP协议  
AF_ISO         网络标准组织协议  
AF_NS          Xerox网络协议  
type说明  
SOCK_STREAM       使用TCP可靠连接  
SOCK_DGRAM        使用UDP不可靠连接 

```c
int bind(int sockfd, const struct sockaddr *my_addr, socklen_t addrlen);
```
Bind将进程和一个套接字联系起来，bind通常用于服务器进程为接入客户链接建立一个套接字。  
参数sockfd是函数socket调用返回套接口值  
参数my_addr式结构sockaddr的地址  
参数addrlen设置my_addr能容纳的最大字节  
成功返回0，失败返回-1，并设置errno   
对于客户端只需要connect即可  
对于服务端，要建立自己的套接口等待来自客户端的连接，调用listen和accept函数

```c
int listen(int sockfd, int backlog)
```
创建了套接口并且使用bind将它和一个进程关联起来，服务端就需要调用listen来监听指定端口的客户端连接。  
参数sockfd是调用socket返回的套接口描述符  
参数backlog设置接入队列大小，通常把这个值设置的足够大就可以了  
成功返回0，失败返回-1，设置errno  

```c
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```
当有客户端链接到服务端，他们会派入队列，直到服务端准备好处理他们，accept会返回一个新的套接口，同时原来的套接口继续listen指定端口号。  
参数sockfd是调用socket返回的套接口描述符  
参数addr指向结构sockaddr地址  
参数addrlen设置了addr能容纳的最大字节数。  
成功返回新的套接字，失败返回-1，设置errno  

```c
int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);
```
客户端调用connect与服务端连接  
参数sockfd是调用socket返回的套接口描述符  
参数addr指向结构sockaddr地址  
参数addrlen设置了addr能容纳的最大字节数。  
成功返回新的套接字，失败返回-1，设置errno  

```c
ssize_t send(int s, const void *buf, size_t len, int flafs);
```
send函数用来发数据  
参数s是已经建立连接的套接口  
参数buf是接受数据内存buffer地址指针  
参数len指明buffer的大小，单位字节  
参数flags一般填0  
成功返回发送的字节数，失败返回-1，设置errno


```c
ssize_t recv(int s, void *buf, size_t len, int flags);
```
recv函数用来发数据  
参数s是已经建立连接的套接口  
参数buf是接受数据内存buffer地址指针  
参数len指明buffer的大小，单位字节  
参数flags一般填0  
成功返回收到的字节数，失败返回-1，如果对套接字已经关闭，返回0。

最后要关闭套接口，close

```c
int setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen);
```
setsockopt函数设置套接口  
常见方法

```c
int on = 1;
setsockopt(st, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on))
```
由于TCP套接字状态TIME_WAIT引起该套接字关闭后约保留2-4分钟。在此期间bind绑定该端口会失败。  
SO_REUSEADDR指示系统地址可重复绑定  
一般来说，一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。  
server程序总是应该在调用bind()之前设置SO_REUSEADDR套接字选项。  
这个套接字选项通知内核，如果端口忙，但TCP状态位于 TIME_WAIT ，可以重用端口。  
如果端口忙，而TCP状态位于其他状态，重用端口时依旧得到一个错误信息，指明"地址已经使用中"。  
如果你的服务程序停止后想立即重启，而新套接字依旧使用同一端口，此时SO_REUSEADDR 选项非常有用。  
必须意识到，此时任何非期望数据到达，都可能导致服务程序反应混乱，不过这只是一种可能，事实上很不可能。  
一个套接字由相关五元组构成，协议、本地地址、本地端口、远程地址、远程端口。  
SO_REUSEADDR 仅仅表示可以重用本地本地地址、本地端口，整个相关五元组还是唯一确定的。  
所以，重启后的服务程序有可能收到非期望数据。必须慎重使用SO_REUSEADDR 选项。  
  
redhat 接受buf为64k，超过512k发送就会阻塞



UDP与TCP
===

UDP是无连接协议  
TCP 是面向连接的协议  
UDP只是把数据发送出去  
UDP不能保证数据包的传递顺序  
选择使用哪种协议：  
一些消息重要性不高，或者有规律重复，可以使用UDP  
如果要传送一个特别重要的数据，丢失一点就会破会整个数据，就用TCP  
telnet，ssh，http基本都给予TCP  
流媒体为了保证很窄的网络带宽用来传更多的数据，基本使用UDP  
多数游戏中使用UDP  
设计局域网时你，应采用UDP，因为在局域网中丢失数据的概率很低  

```c
int socket(int domain, in type, int protocol);
```
type 代表SOCK_STREAM代表TCP,SOCK_STREAM代表UDP  
对于TCP与UDP都是用recvfrom函数，但是recv只能TCP使用

```c
ssize_t recvfrom(int s, void *buf, size_t len, int flags, 
                 struct sockaddr *from, socklen*fromlen);
```
UDP不需要listen，bind后就可以接受数据了。  
注意在多线程程序中不要使用inet_ntoa函数，可以自己书写一个程序

```c
void sockaddr_toa(const struct sockaddr_in *addr, char *IPAddr){
        unsigned char *p = (unsigned char *)_&(addr->sin_addr.s_addr);
        sprint(IPAddr, “%u.%u.%u.%u”, p[0], p[1], p[2], p[3]);
}
```
或者使用inet_ntop函数  
如何得到socket自身的sockaddr和socket连接的远端sockaddr

```c
Int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```
得到远端的sockaddr

```c
Int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```
得到自身的sockaddr



字节类型转化
===

网络中传递最小单位时字节  
short两个字节，大于一个字节的数据在网络中传输使用函数htons  
通过iner_addr将ip地址字符串转化为4字节整数



积累
===

127.0.0.1是回送地址，指本地机，一般用来测试使用。回送地址（127.x.x.x）是本机回送地址（Loopback Address），即主机IP堆栈内部的IP地址，主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回，不进行任何网络传输。  
如果本机真实IP，是要通过网络转一圈回来的，所以不可用于测试。

