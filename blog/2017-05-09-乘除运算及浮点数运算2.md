---
layout: post
title: 乘除运算及浮点数运算（2）
category : 计算机系统原理
tags : [notes, 原理]
stickie: true
---


浮点数运算
===

浮点数运算及结果
---
设置两个规格化的浮点数分别为$$A=M_a*2^{Ea} B=M_b*2^{Eb}$$,则：  
$$A+B=(M_a+M_b*2^{(-(Ea-Eb))*2^{Ea})}(假设Ea>=Eb)$$  
$$A*B=(M_a*M_b) 2^{(Ea+Eb)}$$  
$$A / B =(M_a/M_b)2^{(Ea-Eb)}$$  
会出现下面这种情况：  
阶码溢出：一个正指数超过了最大允许值，一个负指数超过了最小允许值。最高有效位有进位，出现尾数溢出（右归）。数值部分高位为0，出现非规格化尾数（左归）。右归或对阶时，右归有效位丢失，运算过程中允许添加有效位。  
IEEE建议实现时为每种情况提供有一个自陷允许位。若某异常对应的位为1，则发生相应异常时，就调用一个特定的异常处理程序。  

对于浮点数除以0的问题 
---
```c
#include <conio.h>
#include <stdio.h>
int main()
{
	int a = 1, b = 0;
	printf("Division by zero:%d\n", a/b);
	getchar();
	return 0;
}
int main()
{
	double x = 1,y = -1,z = 0.0;
	printf("division by zero:%f %f\n", x/z, y/z);
	getchar();
	return 0;
}
```
对于第一个函数出现异常，第二个结果是1.#INF00和-1.#INF00。因为浮点数可以表示无穷大，而整数不可以。  
浮点数加减运算  
计算$$1.123*10^5+2.56*10^2  $$  
过程如下：  
$$1.123*10^5+2.56*10^2 = 1.123*10^5+0.00256*10^5 = 1.125656*10^5 = 1.126*10^5 $$   
其中56是附加位，最后考虑，计算位数加减法前，必须对阶，最后考虑舍入。  
对阶操作，目的是使两数的阶数相同。小阶向大阶看齐，阶小的那个数的尾数右移。IEEE 754尾数右移时，要将隐含的“1”移到小数部分，高位补0，移出的低位保留到特定的“附加位”上。  
用二进制浮点数计算0.5+(-0.4375) = ?  
$$0.5 = 1.000*2^{(-1)}，-0.4375 = -0.111*2^{(-1)}  $$  
$$1.000*2^{(-1)}+(-0.111*2^{(-1)}) = 0.001*2^{(-1)}$$  
为何IEEE 754加减运算右归时最多只需要一次。因为即使是两个最大的尾数相加，得到的和的尾数也不会达到4，故尾数的整数部分最多有两位，保留一个隐含的“1”后，最多只有一位被右移到小数部分。  

Extra bits
---
IEEE 754规定：中间结果必须在右边加两个附加位（guard & round），guard（保护位）在significand右边的位，round（舍入位）在保护位右边的位。  
附加位的作用：用以保护对阶时右移的位或运算的中间结果。  
附加位的处理：左归时被移到significand中，作为舍入的依据。  
IEEE 754舍入方式  
就近舍入(default)：舍入为最近可表示的数。非中间值：0舍1入；中间值：强迫结果为偶数  
例如：  
1.110111-> 1.1110; 1.110101->1.1101；1.110110->1.1110  
01舍11入10强迫结果为偶数  

```c
#include <stdio.h>
main()
{
	float a;
	double b;
	a = 123456.789e4;
	b = 123456.789e4;
	printf("%f/n%f/n", a,b);
//1234567936.000000 1234567890.000000
}
```
float可以表示的7个十进制有效位，后面的数位是舍入后的结果，舍入后的结果可能会更大，也可能更小。  
float和double是IEEE 754的标准，和处理器、编译器没有关系。而long double类型的长度和格式随编译器和处理器类型的不同而有所不同。从int到float不会发生溢出，但可能数据被舍入。  
要注意的是浮点数不满足结合了率，原因是由于精度问题，会出现大数吃小数的问题。
