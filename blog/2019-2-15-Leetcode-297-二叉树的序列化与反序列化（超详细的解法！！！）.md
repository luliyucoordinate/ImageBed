---
layout: post
title: Leetcode 297：二叉树的序列化与反序列化（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-2-15 00:00:00
---

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

**示例:** 

```
你可以将以下二叉树：

    1
   / \
  2   3
     / \
    4   5

序列化为 "[1,2,3,null,null,4,5]"
```

**提示:** 这与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://leetcode-cn.com/faq/#binary-tree)。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

**说明:** 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。

**解题思路**

我们首先想到的做法就是通过树的前序、中序或者后续遍历获取字符串，然后在通过获得的字符串再反转回树。

这个问题实际和[Leetcode 105：从前序与中序遍历序列构造二叉树（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/83343535)、[Leetcode 106：从中序与后序遍历序列构造二叉树（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/83410424)是相同问题，显然我们可以通过获取两中遍历的字符串反转回树。但是这样做太麻烦了，我们有更好的做法，我们在存储字符串的时候，我们可以同时存储一些信息，通过这些信息，我们只需要一种字符串就可以得到我们的结果。

我们首先考虑前序遍历的解法

```python
class Codec:
    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        res = ""
        def preOrder(root):
            nonlocal res
            if not root:
                res += '# '
                return 
            res += str(root.val) + ' '
            preOrder(root.left)
            preOrder(root.right)
        preOrder(root)
        return res
            
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        datas = data.split()
        def deOrder():
            val = datas.pop(0)
            if val == '#':
                return 
            root = TreeNode(int(val))
            root.left = deOrder()
            root.right = deOrder()
            return root
        return deOrder()
```

后序遍历

```python
class Codec:
    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        res = ""
        def postOrder(root):
            nonlocal res
            if not root:
                res += '# '
                return 
            postOrder(root.left)
            postOrder(root.right)
            res += str(root.val) + ' '
        postOrder(root)
        return res
            
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        datas = data.split()
        def deOrder():
            val = datas.pop()
            if val == '#':
                return 
            root = TreeNode(int(val))
            root.right = deOrder()
            root.left = deOrder()
            return root
        return deOrder()
```

这个问题的中序遍历有一定的难度。





**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**