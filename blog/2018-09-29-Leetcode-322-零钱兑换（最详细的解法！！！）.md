---
layout: post
title: Leetcode 322：零钱兑换（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-09-29 00:00:00
---

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。

**示例 1:**

```
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```

**示例 2:**

```
输入: coins = [2], amount = 3
输出: -1
```

**说明**:
你可以认为每种硬币的数量是无限的。

**解题思路**

这实际上是一个完全背包问题，我们定义这样的方程`f(amount)`，我们将`n`个物品放入容量为`amount`的背包中，使得物品金额正好为`amount`是，所需的硬币数目最少。我们会考虑第`i`个物品放入后，所需硬币数目

- `f(amount)=min(f(amount-coins[i])+1)`

```
coins=[1, 2, 5]  amount=11
0  1  1  3  2  1  2  2  3  3  2  3
```

上述写法的前提是这个给定的`coins`和`amount`一定有解。我们初始化的时候，自然是`f(0)=0`，而`f(i)=float('inf') i>0`。如果最后解出的`f(amount)>amount`，那么表示无解，例如

```
coins=[0]
amount=1
```

所以我们最后的代码就是这样

```python
class Solution:
    def coinChange(self, coins, amount):
        """
        :type coins: List[int]
        :type amount: int
        :rtype: int
        """ 
        mem = [float('inf')]*(amount+1)
        mem[0] = 0
        for coin in coins:
            for j in range(coin, amount+1):
                mem[j] = min(mem[j], mem[j - coin] + 1)

        return -1 if mem[-1] > amount else mem[-1]
```

实际上这种问题也可以使用回溯法来解决，而且我们通过剪枝可以很大程度的提高代码的速度。

```python
class Solution:
    def coinChange(self, coins, amount):
        coins.sort(reverse=True)
        len_coins, result = len(coins), amount+1

        def countCoins(index, target, count):
            nonlocal result
            if not target:
                result = min(result, count)

            for i in range(index, len_coins):
                if coins[i] <= target < coins[i]*(result - count):
                    countCoins(i, target - coins[i], count+1)

        for i in range(len_coins):
            countCoins(i, amount, 0)
        return -1 if result > amount else result
```

这里我们首先将`coins`从大到小进行排序，这是因为我们希望硬币数量尽可能的少，那么就需要尽量将面值大的硬币加入结果中。中间的剪枝操作也很容易理解

- `if coins[i] <= target < coins[i]*(result - count):`

我们的目标值一定是要大于等于我们将要放入的硬币面额，而且本次使用的硬币数量一定要比上次少。

实际上这个问题我们可以通过一个循环来完成，我们只需要每次递归中判断，我们剩余的`target%nums[index]==0`，如果可以的话，表示当前的`coin`可以将`target`塞满，我们只需要计算有多少个`coin`即可。

```python
import math
class Solution:
    def coinChange(self, coins, amount):
        coins.sort(reverse=True)
        len_coins, result = len(coins), amount+1

        def countCoins(index, target, count):
            nonlocal result
            if count + math.ceil(target/coins[index]) >= result:
                return 

            if target % coins[index] == 0:
                result = count + target//coins[index]
                return

            if index == len_coins - 1:
                return

            for i in range(target//coins[index], -1, -1):
                countCoins(index+1, target - coins[index]*i, count+i)

        countCoins(0, amount, 0)
        return -1 if result > amount else result
```

上面这个代码依旧还有优化的空间，大家可以继续强化我们的代码，让它变得更加完善。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**