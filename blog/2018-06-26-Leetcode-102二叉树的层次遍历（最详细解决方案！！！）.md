---
layout: post
title: Leetcode 102:二叉树的层次遍历（最详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-06-26 00:00:00
---

给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。

例如:
给定二叉树: `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

**解题思路**

这是一个`BFS`问题，首先可以想到就是通常的解法。我们可以使用`queue`解决，在`python`中，我们可以通过`from queue import Queue`。也可以使用`list`来解决，不过在使用`list`的时候要注意，我们如果`pop`操作的话，要添加一个参数`pop(0)`，表示我们`pop`最前面的元素。

这里我们要注意一下，外部循环条件，我们不可以写成`while q:`，因为当输入是`[]`，这个时候`q=[[]]`，`python`对这个结果的判定是`True`，参看这篇文章[python中的and和or](https://blog.csdn.net/qq_17550379/article/details/78173227)。我们这里可以使用`while any(q)`，具体实现如下。

```python
class Solution:
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        q, res = [root], []
        while any(q):
            cur = list()
            len_q = len(q)
            for _ in range(len_q):
                node = q.pop(0)
                cur.append(node.val)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            res.append(cur)
        return res
```

当然了，我们也可以先使用`if root:`进行判断，而且我也更加推荐这种写法。

```python
class Solution:
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return list()
        
		......
```

这种解法非常无聊，没有新意。这个问题我们也可以通过`DFS`来解，我们只需要遍历的过程中记录深度信息即可。

首先我们将`root`入队，并且我们也要同时保存`root`的层信息，所以我这里使用了一个`tuple`

```
q : (root, 0)
```

接着我们进入一个循环体，我们判断`q.empty()`。如果非空，我们就执行循环体中的内容。

首先获取`q`的队首元素，接着我们要判断`level == len(ret)`（队首元素的`level`是不是等于`返回列表的长度`）

```
ret : []   
q : (root, 0)
```

我们发现相等，所以我们就要添加一个`list`

```
ret : [[]]
```

然后将`ret[level].append(队首元素first的val)`。

```
ret : [[3]]
```

接着我们判断队首元素的左右孩子是不是空，如果不是空，我们分别添加到`q`的后面，并且同时`tuple`中的`level+1`。

```
q : (9, 1) (20, 1)
```

以下是这个过程的完整代码（我们通过`queue`来实现）

```python
class Solution:
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        ret = list()
        if not root:
            return ret

        from queue import Queue
        q = Queue()
        q.put((root, 0))
        while not q.empty():
            node, level = q.get()
            if level == len(ret):
                ret.append([])
                
            ret[level].append(node.val)
            if node.left != None:
                q.put((node.left, level + 1))
            if node.right != None:
                q.put((node.right, level + 1))

        return ret
```

这个问题我们也可以写出递归的版本，而且非常简洁。

```python
class Solution:
    def _levelOrder(self, level, result, node):
        if node:
            if level == len(result):
                result.append([])
                
            result[level].append(node.val)
            self._levelOrder(level+1, result, node.left)
            self._levelOrder(level+1, result, node.right)

    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        level, result = 0, list()
        self._levelOrder(level, result, root)
        return result 
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**
