---
layout: post
title: Leetcode 1002：查找常用字符（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-3-4 00:00:00
---

给定仅有小写字母组成的字符串数组 `A`，返回列表中的每个字符串中都显示的全部字符（**包括重复字符**）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。

你可以按任意顺序返回答案。 

**示例 1：**

```
输入：["bella","label","roller"]
输出：["e","l","l"]
```

**示例 2：**

```
输入：["cool","lock","cook"]
输出：["c","o"]
```

**提示：**

1. `1 <= A.length <= 100`
2. `1 <= A[i].length <= 100`
3. `A[i][j]` 是小写字母

**解题思路**

一个很容易想到的思路就是遍历`A`中的所有字符串，然后统计所有字符串出现的频率，最后遍历`26`个字母表，取出所有字符串中对应字母出现的最少次数，如果没有出现的话，那么标记为`0`，将结果存入`list`即可。

```python
from string import ascii_lowercase
from collections import Counter
class Solution:
    def commonChars(self, A: List[str]) -> List[str]:
        d = list()
        for i in A:
            d.append(Counter(i))
                
        res = list()
        for c in ascii_lowercase:
            tmp = 100
            for i in d:
                if c in i:
                    tmp = min(i[c], tmp)
                else:
                    tmp = 0
                    break
            for j in range(tmp):
                res.append(c)
        return res
```

这个问题在写的时候其实有一个`trick`，我们的`collections.Counter`可以和`set`一样做交并补操作。所以代码可以变得非常简洁

```python
from collections import Counter
class Solution:
    def commonChars(self, A: List[str]) -> List[str]:
        res = collections.Counter(A[0])
        for a in A:
            res &= collections.Counter(a)
        return list(res.elements())
```

当然如果你对`reduce`和`map`很熟悉的话，上面过成可以继续简化为一行

```python
return list(reduce(collections.Counter.__and__, map(collections.Counter, A)).elements())
```

reference:

https://leetcode.com/problems/find-common-characters/discuss/247560/Python-1-line

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**