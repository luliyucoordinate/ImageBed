---
layout: post
title: Leetcode 935：骑士拨号器（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-04 00:00:00
---

国际象棋中的骑士可以按下图所示进行移动：

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2018/10/12/knight.png" width="200" hegiht="313">
    <img src="https://assets.leetcode.com/uploads/2018/10/30/keypad.png" width="190" hegiht="270">
</center>

这一次，我们将 “骑士” 放在电话拨号盘的任意数字键（如上图所示）上，接下来，骑士将会跳 N-1 步。每一步必须是从一个数字键跳到另一个数字键。

每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下 `N` 位数字。

你能用这种方式拨出多少个不同的号码？

因为答案可能很大，**所以输出答案模 10^9 + 7**。

**示例 1：**

```
输入：1
输出：10
```

**示例 2：**

```
输入：2
输出：20
```

**示例 3：**

```
输入：3
输出：46
```

**提示：**

- `1 <= N <= 5000`

**解题思路**

这个问题非常简单。我们看`1`，`1`可以到达`6,8`，依次我们按照`0~9`，可以得到这样的步骤列表

```
[[4,6],[6,8],[7,9],[4,8],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]
```

我们定义函数`f(k,N)`表示以`k`开始的`N`位数的不同号码数目。那么对于`0`

- $f(0,N)=f(4,N-1)+f(6,N-1)$

同理我们可以得到`0~9`的每个结果，最后的结果就是`sum(f(0~9,N))`。所以我们可以很快写出递归形式

```python
class Solution:
    def knightDialer(self, N):
        """
        :type N: int
        :rtype: int
        """
        mod = 10**9 + 7
        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]

        result = 0
        for i in range(10):
            result += self._knightDialer(i, N, moves)%mod

        return result
        
    def _knightDialer(self, k, N, moves):
        if N == 1:
            return 1

        tmp = 0
        for step in moves[k]:
            tmp += self._knightDialer(step, N-1, moves)

        return tmp
```

同样我们也可以通过记忆化搜索优化上述问题（可以参看我之前的文章），这里我就不再赘述了。我们看看通过动态规划怎么写

```python
class Solution:
    def knightDialer(self, N):
        """
        :type N: int
        :rtype: int
        """
        mod = 10**9 + 7
        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]

        result = [1]*10
        for _ in range(N-1):
            mem = [0]*10
            for i in range(10):
                for step in moves[i]:
                    mem[step] += result[i]
                    mem[step] %= mod
            
            result = mem

        return sum(result) % mod
```

其实我们还可以写的更简洁

```python
class Solution:
    def knightDialer(self, N):
        """
        :type N: int
        :rtype: int
        """
        mod = 10**9 + 7
        ret = [1]*10
        for _ in range(N-1):
            ret[0],ret[1],ret[2],ret[3],ret[4],ret[5],ret[6],ret[7],ret[8],ret[9]=\
            ret[4]+ret[6], ret[6]+ret[8], ret[7]+ret[9], ret[4] + ret[8], \
            ret[3]+ret[9]+ret[0],0,ret[1]+ret[7]+ret[0], ret[2]+ret[6],\
            ret[1]+ret[3],ret[2]+ret[4]

        return sum(ret) % mod
```

还有一种非常天才的解法。我们实际上可以用更少的状态来表示上述的过程

```
A: {1,3,7,9}
B: {4,6}
C: {2,8}
D: {0}
E: {5}
```

例如，状态`A`可以变成状态`B`和状态`C`，状态`D`可以变成状态`C`，而状态`E`我们其实可以去除（因为没有下一个状态），所以我们就将`N=1`单独考虑（也就是`N=1`的时候返回`10`）。现在我们只要考虑四种状态

```
A: {1,3,7,9}
B: {4,6}
C: {2,8}
D: {0}
```

所以我们的初始值就是`[4,2,2,1]`。然后`A=2(B+C)`、`B=2D+A`、`C=A`、`D=B`，不断递归即可。

```python
class Solution:
    def knightDialer(self, N):
        """
        :type N: int
        :rtype: int
        """
        if N == 1:
            return 10
        
        mod = 10**9 + 7
        H = [4, 2, 2, 1]
        for _ in range(0, N - 1):
            H[0], H[1], H[2], H[3] = 2*(H[1] + H[2]), 2*H[3] + H[0], H[0], H[1]

        return sum(H) % mod
```

最后我们通过一些`trick`优化上面的过程，最后我们的代码在`leetcode`上只用了`68ms`。

```python
from ctypes import c_uint32
class Solution:
    hops = [(c_uint32 * 4)(4, 2, 2, 1)]
    def knightDialer(self, N):
        """
        :type N: int
        :rtype: int
        """
        if N == 1:
            return 10
        
		mod = 10**9 + 7
        if N <= len(self.hops):
            H = self.hops[N - 1]
        else:
            H = self.hops[-1]
            for _ in range(len(self.hops), N):
                H = (c_uint32 * 4)(2*(H[1] + H[2]), 2*H[3] + H[0], H[0], H[1])
                for i in (0, 1, 2, 3):
                        H[i] %= mod
                self.hops.append(H)

        return sum(H) % mod
```

reference:

https://leetcode.com/problems/knight-dialer/discuss/189252/O(logN)

https://leetcode.com/problems/knight-dialer/discuss/190053/Java-O(N)-solution-state-compression-based-solution

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**