---
layout: post
title: Go语言面向对象
category : go
tags : [go]
stickie: true
date: 2019-6-20 00:00:00
---

# 0x01 结构体

`go`语言仅支持封装，不支持继承和多态（这和`c`语言非常类似）

`go`语言创建结构体，我们通过`type`关键字定义类型。

```go
type ListNode struct {
    Val int
    Next *ListNode
}
```

关于结构体的赋初值

```go
var root ListNode
root = ListNode{Val: 3}
root.Next = &ListNode{}
root.Next = new(ListNode)
nodes := []ListNode {
    {},
    {3}
}
```

在`go`语言中没有构造函数，但是我们通过工厂函数来管理我们的对象构造

```go
func createListNode(val int) *ListNode {
    return &ListNode(val)
}
```

这在`cpp`中很奇怪，因为我们返回了一个`局部变量的地址`。那么我们就会好奇这个局部变量是创建在堆上还是栈上呢？不用关心，因为`go`语言的垃圾回收机制。

在`go`语言中为结构体定义方法不是在结构体中，而是在结构体外

```go
func (node ListNode) print() {
    fmt.Print(node.Val)
}
```

在函数名的前面定义了一个接受者，也就是类似于`cpp`中的`this`。

我们知道`go`语言中的参数传递是通过值传递的，那么我们怎么修改一个对象中的内容呢？通过指针

```go
func (node *ListNode) setValue(val int) {
    node.Val = val
}
```

需要注意的是，在`go`语言中可以通过空指针调用方法。

```go
var n1 *ListNode
n1.print() //panic: runtime error: invalid memory address or nil pointer dereference
```

# 0x02 封装

`go`语言中也是支持访问权限的，但是和`cpp`使用`private`、`public`不同，`go`中首字母大写表示`public`，而首字母小写表示`private`。

`go`语言中每个目录一个包，`main`包包含了可执行入口。

结构定义的方法必须放到同一个包内，但是可以放到不同文件中。也就是我们可以将一个包看成一个类。

`GOROOT`就是`golang`的安装位置。

`GOPATH`可以理解为工作目录。它的下面会有三个子目录，分别是

- `bin`编译后可执行文件存放的路径
- `pkg`编译包时，`.a`文件存放的路径
- `src`代码路径

`go build`编译代码

`go install`产生`pkg`文件和`bin`文件

`go run`直接编译运行