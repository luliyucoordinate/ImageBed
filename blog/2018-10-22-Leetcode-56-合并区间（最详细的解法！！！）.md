---
layout: post
title: Leetcode 56：合并区间（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-10-22 00:00:00
---

给出一个区间的集合，请合并所有重叠的区间。

**示例 1:**

```
输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2:**

```
输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

**解题思路**

我们首先想到的做法是先将输入的区间按照第一个元素排序。然后我们建立一个`result`用来存储最后的结果。我们现将第一个区间放入`result`中，然后对于后面输入的区间的`item.start`和`result[-1].end`比，如果`result[-1].end < item.start `，我们就将`item`加入到`result`，否则话说明要放入的区间和`result[-1]`有重叠，那么我们取`result[-1].end = max(result[-1].end, item.end)`。

```python
class Solution:
    def merge(self, intervals):
        """
        :type intervals: List[Interval]
        :rtype: List[Interval]
        """
        intervals.sort(key=lambda x: x.start)
        result = list()
        for item in intervals:
            if not result or result[-1].end < item.start:
                result.append(item)
            else:
                result[-1].end = max(result[-1].end, item.end)

        return result
```

我们知道这个算法的时间复杂度是`O(nlogn)`级别，其实还有一个更快的解法，但是太复杂了，我们就不去谈它了。

我们不额外开辟空间可以吗？可以，我们可以直接在原地操作

```python
class Solution:
    def merge(self, intervals):
        """
        :type intervals: List[Interval]
        :rtype: List[Interval]
        """
        if not intervals:
            return []
        intervals.sort(key=lambda x: x.start)
        pre, cur, n = 0, 1, len(intervals)
        while cur < n:
            if intervals[pre].end < intervals[cur].start:
                pre += 1
                intervals[pre] = intervals[cur]
            else:
                intervals[pre].end = max(intervals[pre].end, intervals[cur].end)
            cur += 1

        return intervals[:pre+1]
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**