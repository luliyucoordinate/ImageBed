---
layout: post
title: Leetcode 852：山脉数组的峰顶索引（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-06 00:00:00
---

我们把符合下列属性的数组 `A` 称作山脉：

- `A.length >= 3`
- 存在 `0 < i < A.length - 1` 使得`A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]`

给定一个确定为山脉的数组，返回任何满足 `A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]` 的 `i` 的值。

**示例 1：**

```
输入：[0,1,0]
输出：1
```

**示例 2：**

```
输入：[0,2,1,0]
输出：1
```

**提示：**

1. `3 <= A.length <= 10000`
2. `0 <= A[i] <= 10^6`
3. A 是如上定义的山脉

**解题思路**

这个问题和之前问题[Leetcode 162：寻找峰值（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/83780912)很像，不过之前问题是求局部最优，而这个问题是求全局最优。实际上之前问题的解法就可以拿过来直接用，因为这个问题实际上局部最优解就是全局最优解。

```python
class Solution:
    def peakIndexInMountainArray(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        l, r = 0, len(A)-1
        while l < r:
            mid = (l + r)//2
            if A[mid] <= A[mid+1]:
                l = mid + 1
            else:
                r = mid

        return l
```

然而由于这个问题的特殊性（局部最优就是全局最优），所以我们就可以使用一维线搜索的方法。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**