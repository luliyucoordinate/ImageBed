---
layout: post
title: Leetcode 279:完全平方数（最详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-07-01 00:00:00
---

给定正整数 *n*，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 *n*。你需要让组成和的完全平方数的个数最少。

**示例 1:**

```
输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
```

**示例 2:**

```
输入: n = 13
输出: 2
解释: 13 = 4 + 9.
```

**解题思路**

很多人第一眼看到这个问题，想到的第一种做法就是使用贪心算法，但是对于这个问题是不适用的，例如：

```
12 = 9 + 1 + 1 + 1
```

我们根据题目中**完全平方数的个数最少**，我们在什么算法中用到过**最少**这个关键字？啊哈！**最短路径问题**。那么和这个问题有什么联系呢？

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/279/2019_6_29_1.jpg" width="400">
</center>

现在我们就可以用最短路径算法来解决这个问题。最短路径算法其实就是图的广度优先遍历。例如对于上图中的`5`，我们要前往`0`，我们的第一步有两种走法，先走`4`和先走`1`。所以我们需要建立一个队列或者栈，然后将第一步的走法压入队列或者栈中。如下（使用队列， 我们同时记录走的步数）

```
q : (4, 1) (1, 1)
```

我们将`4`出队，然后看`4`的下一步怎么走，发现只能走`3`，所以我们将`(3, 2)`入队

``` 
q : (1, 1) (3, 2)
```

接着我们将`(1, 1)`弹出，我们看`1`的下一步怎么走，发现只能走`0`，这个时候我们发现已经到达了`0`，那么我们更新`step+1`，然后出循环即可。以下是代码的全部过程：

```python
class Solution:
    def numSquares(self, n):
        """
        :type n: int
        :rtype: int
        """
        q = list()
        q.append([n, 0])
        visited = [False for _ in range(n+1)]
        visited[n] = True

        while any(q):
            num, step = q.pop(0)

            i = 1
            tNum = num - i**2
            while tNum >= 0:
                if tNum == 0:
                    return step + 1

                if not visited[tNum]:
                    q.append((tNum, step + 1))
                    visited[tNum] = True

                i += 1
                tNum = num - i**2
```

但是这个解法不是最优的解法，但是我认为是一个不错的思维方式。那么更加快速的解法是什么样的呢？我们就要用到数学知识了，这里使用的是**四平方和定理**。

> Lagrange 四平方定理： 任何一个正整数都可以表示成不超过四个整数的平方之和。 

那么我们这个问题的解法就变得很简单了，我们的结果只有`1,2,3,4`，四种可能。

另外还有一个非常重要的推论

> if and only if n is not of the form $n = 4^a(8b + 7)$ for integers a and b. 
>
> 满足四数平方和定理的数n（这里要满足由四个数构成，小于四个不行），必定满足 $n = 4^a(8b + 7)$ 

根据这个重要的推论，我们可以非常迅速的写出这样的代码。

我们首先将输入的`n`迅速缩小。然后我们再判断，这个缩小后的数是否可以通过`两个平方数的和或一个平方数`组成，不能的话我们返回`3`，能的话我们返回`平方数的个数`。

现在我们的问题已经缩减到了，怎么判断一个数是由一个还是由两个平方数的和构成？对于这个问题，我们当然可以暴力破解。

```python
class Solution:
    def numSquares(self, n):
        """
        :type n: int
        :rtype: int
        """
        while n % 4 == 0:
            n /= 4
        
        if n % 8 == 7: 
            return 4

        a = 0
        while a**2 <= n:
            b = int((n - a**2)**0.5)
            if a**2 + b**2 == n:
                return (not not a) + (not not b)

            a += 1

        return 3
```

另外这个问题还有一种经典的解法，就是使用动态规划。动态规划的问题关键在于状态转移方程，这里的思路还是和前面使用图的广度优先遍历一样。例如

我们要知道`12`最少有多少个数构成，实际上如果我们走了一步的话，我们需要知道`11、8、3`对应的步数，如果我们不走，我们就需要知道`12`的步数，我们只要通过比较是走`0`步小，还是走`1步`哪个更小即可。通过一个式子表示就是

```
num[n] = min(num[n], num[n-i**2] + 1)
```

所以我们可以先定义一个`n`大小的数组（static类型），这里我们要使数组初始化为无穷大，在`python`中我们可以使用`float('inf')`

```python
class Solution:
    _dp = list()
    def numSquares(self, n):
        """
        :type n: int
        :rtype: int
        """
        dp = self._dp
        dp = [float('inf') for i in range(n + 1)]
        dp[0] = 0
        for i in range(n + 1):
            j = 1
            while i + j**2 <= n:
                dp[i + j**2] = min(dp[i + j**2], dp[i] + 1)
                j += 1
                
        return dp[n]
```

但是这里写法我们在实际测试的时候超时了。

以下写法参考了[StefanPochmann](https://leetcode.com/problems/perfect-squares/discuss/71512/Static-DP-C++-12-ms-Python-172-ms-Ruby-384-ms?page=3) 

```python
class Solution:
    _dp = [0]
    def numSquares(self, n):
        dp = self._dp
        while len(dp) <= n:
            dp += list((min(dp[-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1,))
        return dp[n]
```

思路还是和上面一样，但是这里`,`不是乱加的。为什么要加？这是因为`int`无法初始化`list`，我们只有通过加上一个`,`，将`int`变成`tuple`才可以初始化。这里还有一个`trick`，`_dp`放到了全局，这有什么用？我们知道我们有很多的测试用例，而这么多的测试用例中肯定有许多相似的测试用例，那么这其中就会有很多相似的计算，如果我们将`_dp`放到全局，这样做的话，我们就会节省很多的时间。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**