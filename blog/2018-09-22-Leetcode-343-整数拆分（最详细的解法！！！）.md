---
layout: post
title: Leetcode 343：整数拆分（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-09-22 00:00:00
---

给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

**示例 1:**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

**说明:** 你可以假设 *n* 不小于 2 且不大于 58。

**解题思路**

这个问题很简单，可以通过递归解决。举个列子，对于正整数4，我们要知道将4拆分为哪几个正整数的和，并使这些整数的乘积最大化，那我们只要知道3、2、1的乘积最大化分别是多少，然后从中选出最大值即可，以此类推下去即可。

```python
class Solution:
    def integerBreak(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 1:
            return 1

        result = -1
        for i in range(1, n):
            result = max(result, i*(n - i), i * self.integerBreak(n - i))

        return result
```

很多人在写上面这个代码的时候会将

```python
max(result, i*(n - i), i * self.integerBreak(n - i)) ==>
max(result, i * self.integerBreak(n - i))
```

写成下面的那种形式，关键问题在于没有理解函数的定义。`integerBreak`是将一个正整数拆分为**至少**两个正整数的和，也就是说`i * self.integerBreak(n - i)`至少是三个整数的积，那么我们在比较最大值的时候自然要将`i*(n - i)`给加上啦。

上面这种算法中存在着大量的重复运算（在哪里呢？）。我们可以通过**记忆化搜索**的方式来优化上面的问题。

```python
class Solution:
    def integerBreak(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 1:
            return 1

        mem = [-1 for i in range(n + 1)]
        mem[1] = 1
        for i in range(2, n + 1):
            for j in range(1, i):
                mem[i] = max(mem[i], j*(i - j), j*mem[i - j])

        return mem[n]
```

实际上这个问题通过数学方法很快就可以解决。我们将一个整数拆分，往往这个拆分后的数中包含整数的话，那么这些数的乘积最大

```
2^3 < 3^2
4^3 < 3^4 > 3^3^1
5^3 < 3^5 < 3^3^2
6^3 < 3^6 < 3^3^3
```

通过上面的例子你会发现这样的规律：想要乘积最大，那么一定要将`3`作为基底，并且`<=4`的余数不再进行拆分。为什么会这样呢？

我们将`n`拆分成$\frac {n}{x}$个数值为`x`的整数，那么这些整数的乘积就是$x^{n/x}$，我们现在的目标就是计算$max(x^{n/x})$。我们对这个函数求导，得到

- $\frac{\delta{x^{\frac{n}{x}}}}{\delta x}=n*x^{\frac{n}{x} -2}*(1-ln(x))$

当`x=e`的时候取最大值。所以我们这里可以取的整数就是`2`和`3`，但是

```
6 = 2 + 2 + 2 = 3 + 3 but
2*2*2 < 3*3
```

所以就有了前面的结论。但是这里还有一个问题，就是为什么要取相同数的乘积，不同数不行吗？确实不行(～o￣3￣)～

基于上述的论点，我们可以写出这样的代码，非常的简洁。

```python
class Solution:
    def integerBreak(self, n):
        """
        :type n: int
        :rtype: int
        """  
        if n <= 3:
            return n - 1
        
        result = 1
        while n > 4:
            n -= 3
            result *= 3

        return n * result
```

这个问题同[Leetcode 279:完全平方数（最详细解决方案！！！）](http://blog.csdn.net/qq_17550379/article/details/80875782)一样，也可以通过最短路径算法解决。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**