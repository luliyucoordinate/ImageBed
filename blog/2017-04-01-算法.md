---
layout: post
title: 算法 algorithms
category : cpp
tags : [cpp, stl, 算法]
stickie: true
---



Algorithm 看不见containers，所以他需要的一切信息都必须从iterators取得，而iterators必须回答algorithm的所有问题，才能搭配这个algorithm的所有操作，可以看最前面的一个图。从语言层面看，algorithm是一个function template


算法accumulate
===
```c++
template <class InputIterator,
			class T>
T accumulate (InputIterator first,
				InputIterator last,
				T init)
{
	for( ; first != last; ++first)
//将元素累加至初值init身上
		init = init + *first;
	return init;
}
通常算法有两个版本，另一个允许增加函数
template <class InputIterator,
			class T,
			class BinaryOperation>
T accumulate(InputIterator first,
				InputIterator last,
				T init,
				BinaryOperation binary)
{
	for( ; first != last; ++first)
//将元素累加至初值init身上
		init = binary_op(init, *first);
	return init;
}
```

算法for_each
===
```c++
template <class InputIterator,
			class Function>
Function for_each(InputIterator first,
					InputIterator last,
					Function f)
{
	for( ; first != last ; ++first)
		f(*first);
	return f;
}
range-based for statement
since c++11
for( decl : coll )
{
	statement
}
```

算法replace，replace_if，replace_copy
===
```c++
关于算法的命名规则
template <class ForwardIterator, class T>
void replace (ForwardIterator first,
				ForwardIterator last,
				const T& old_value,
				const T& new_value)
{
	for( ;first != last; ++first)
		if(*first == old_value)
			*first = new_value;
}
template <class InputIterator, class OutputIterator, class T>
OutputIterator replace_copy(InputIterator first,
								InputIterator last,
								OutputIterator result,
								const T& old_value,
								const T& new_value)
//等于old_value的都以new_value放入新的存储空间
{
	for(; fisrt != last; ++first, ++result)
		*result = *first == old_value? new_value:*first;
	return result;
}
template <class ForwardIterator,class Predicate, class T>
void replace_if(ForwardIterator first,
				ForwardIterator last,
				predicate pred,
				const T& new_value)
{
	for (; first != last ; ++first)
		if(pred(*first))
			*first = new_value;
}
```

算法count，count_if
===
```c++
template <class InputIterator, class T>
typename iterator_traits<InputIterator>::difference_type
count(InputIterator first, InputIterator last,
		const T& value)
{
	typename iterator_traits<InputIterator>::difference_type n = 0;
	for(; first != last; ++first)
		if(*first == value)
			++n;
	return n;
}
template <class InputIterator, class Predicate>
typename iterator_traits<InputIterator>::difference_type
count_if( InputIterator first, InputIterator last,
			Predicate pred)
{
	typename iterator_traits<InputIterator>::difference_type n = 0;
	for( ; first != last; ++first)
		if(pred(*first))
			++n;
	return n;
}
```

容器不带成员函数count()
---
array，vector，list，forward_list，deque

容器带有成员函数
---
set/mutiset  
map/mutimap  
unordered_set/unordered_mutiset  
unordered_map/unordered_mutimap


算法find，find_if
===
```c++
template <class InputIterator, class T>
InputIterator find(InputIterator first,
					InputIterator last,
					const T& value)
{
	while(first != last && *first != value)
		++first;
	return first;
}
template <class InputIterator, class Precidate>
InputIterator find(InputIterator first,
					InputIterator last,
					Predicate pred)
{
	while( first != last && !pred(*first))
	{
		++first;
	}
	return first;
}
```
容器不带成员函数find()
---

array，vector，list，forward_list，deque

容器带有成员函数
---

set/mutiset  
map/mutimap  
unordered_set/unordered_mutiset  
unordered_map/unordered_mutimap


算法sort
===

STL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。

```c++
template <class _RandomAccessIter>
inline void sort(_RandomAccessIter __first, _RandomAccessIter __last) 
{
  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
  __STL_REQUIRES(typename iterator_traits<_RandomAccessIter>::value_type,
                 _LessThanComparable);
  if (__first != __last) 
  {
    __introsort_loop(__first, __last,
                     __VALUE_TYPE(__first),
                     __lg(__last - __first) * 2);
    __final_insertion_sort(__first, __last);
  }
}
template <class Size>
inline Size __lg(Size n)
 {
    Size k;
    for (k = 0; n > 1; n >>= 1) ++k;
    return k;
}
template <class _RandomAccessIter, class _Tp, class _Size>
void __introsort_loop(_RandomAccessIter __first,
                      _RandomAccessIter __last, _Tp*,
                      _Size __depth_limit)
{
	  while (__last - __first > __stl_threshold) 
	  {
		    if (__depth_limit == 0) 
		    {
			      partial_sort(__first, __last, __last);
			      return;
		    }
		    --__depth_limit;
		    _RandomAccessIter __cut =
		      __unguarded_partition(__first, __last,
		                            _Tp(__median(*__first,
		                                         *(__first + (__last - __first)/2),
		                                         *(__last - 1))));
		    __introsort_loop(__cut, __last, (_Tp*) 0, __depth_limit);
		    __last = __cut;
	  }
}
```

首先判断元素规模是否大于阀值__stl_threshold，__stl_threshold是一个常整形的全局变量，值为16，表示若元素规模小于等于16，则结束内省式排序算法，返回sort函数，改用插入排序。若元素规模大于__stl_threshold，则判断递归调用深度是否超过限制。若已经到达最大限制层次的递归调用，则改用堆排序。代码中的partial_sort即用堆排序实现。若没有超过递归调用深度，则调用函数__unguarded_partition()对当前元素做一趟快速排序，并返回枢轴位置。  
__unguarded_partition()函数采用的便是上面所讲的使用两个迭代器的方法，代码如下

```c++
template <class _RandomAccessIter, class _Tp>
_RandomAccessIter __unguarded_partition(_RandomAccessIter __first, 
                                    _RandomAccessIter __last, 
                                    _Tp __pivot) 
{
	while (true) 
	{
	    while (*__first < __pivot)
	        ++__first;
	    --__last;
	    while (__pivot < *__last)
	        --__last;
	    if (!(__first < __last))
	        return __first;
	    iter_swap(__first, __last);
	    ++__first;
	}
}
```

经过一趟快速排序后，再递归对右半部分调用内省式排序算法。然后回到while循环，对左半部分进行排序。源码写法和我们一般的写法不同，但原理是一样的，需要注意。 

容器不带成员函数sort()  
array，vector，deque

以下四个默认排好了  
set/mutiset  
map/mutimap  
unordered_set/unordered_mutiset  
unordered_map/unordered_mutimap

容器带有成员函数  
list，forward_list


算法binary_search
---
```c++
Test if value exits in sorted sequence
template <class ForwardIterator, class T>
bool binary_search( ForwardIterator first,
					ForwardIterator last,
					const T& val)
{
	first = std::lower_bound(first, last, val);
//获得的iterator所指的位置，既非end，目标val也不是小于首元素
	return (first != last && !(val <*first));
}
在lower_bound之前做一次!(val <*first)会更好
template <class ForwardIterator, class T>
ForwardIterator 
lower_bound(ForwardIterator first,
			ForwardIterator last,
			const T& val)
{
	ForwardIterator it;
	iterator_traits<ForwardIterator>::difference_type count,step;
	count = distance(first, last);
	while(count > 0)
	{
		it = first;step = count /2;
		if(*it <val)
		{
			first = ++it;
			count -= step +1;
		}
		else
			count = step;
	}
	return first;
}
```
关于lower_bound表示的是一个排好的序列里，相同的value的最低点，而upper_bound
则相反。


