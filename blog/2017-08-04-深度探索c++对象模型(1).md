---
layout: post
title: 深度探索c++对象模型(1)
category : cpp
tags : [cpp]
stickie: true
---

C++在布局以及存取时间上主要的额外负担是由`virtual`引起的，包括`virtual function`机制和`virtual base class`，此外，还有一些多重继承下的额外负担。

在C中将一个一个元素的数组放在`struct`的末尾，可以令每个`struct`的对象拥有可变数组。

```c++
struct mumble {  
    /* stuff */  
    char pc[ 1 ];  
};  
// grab a string from file or standard input  
// allocate memory both for struct & string  
struct mumble *pmumb1 = ( struct mumble* )  
    malloc(sizeof(struct mumble)+strlen(string)+1);  
strcpy(pmumb1->pc, string );
```
指针 `pmumb1` 指向的是 `malloc` 所分配的整个内存，而 `pmumb1->pc` 指向的是这块内存的第一个字节，因为 ` malloc`  操作为整个 `string` 分配了足够的内存，所以在 `strcpy` 时，虽然溢出了 `pc` 的内存范围，但没有溢出 `struct` 的内存范围，使得 `strcpy` 的结果是合理的和可控的。这样一来，相当于 `struct` 拥有了可变大小的数组，更加灵活。这是一个很有意思的小技巧，但是别在C++中使用。

C++通过下面的方法支持多态：

-  经由一组隐含的转化操作。例如把一个`derived class`指针转化为一个指向其`public base type`的指针
-  经由`virtual function`机制
-  经由`dynamic_cast`和`typeid`运算符