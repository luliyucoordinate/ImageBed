---
layout: post
title: 复杂数据类型的机器级表示（2）
category : 计算机网络
tags : [notes, 原理, 计算机网络]
stickie: true
---


数据的对齐方式
===

数据的对齐
---

Alignment:**要求数据的地址是相应的边界地址**  
各种不同长度的数据存放时，有两种处理方式：  
按边界存放（若一个字为32位）、不按边界存放（可能会增加访问次数）  
虽简单的策略是：按其数据长度进行对齐。例如，Windows采用策略，int型地址是4的倍数，short型地址是2的倍数，double和long long 型的是8的倍数，float型的是4的倍数，char不对齐；linux采用更宽松的策略，short型是2的倍数，其他类型如int、float、double和指针都是4的倍数。  
要注意的是不要讲数据类型的大小与对齐的倍数混淆，数据类型的大小linux和windows基本是一样的，只是对齐方式不一样。在linux中 long long 是8个字节但是他是按照4字节对齐的。  
例如：  

```c
struct SDT
{
	int i;
	short si;
	double d;
	char c;
}sa[10];
```
注意结构数组变量的最末可能需要插空，以使每个数组元素都按4字节边界对齐，但是如果不是数组的话，那就可以节省3个字节的空间  

对齐（Alignment）
---
如：int I,short k,double x,char c,short j  
如果是边界对齐的情况  
&i=0;&k=4;&x=8;&c=16;&j=18;  
x：2个周期  
j：1个周期  
如果边界不对齐的情况  
&i=0;&k=4;&x=6;&c=14;&j=15;  
x：3个周期  
j：2个周期  

对齐方式的设定
---

```c
#pragma pack(n)
```
为编译器指定结构体和类内部的成员变量的对齐方式  
当自然边界（如int型按4字节、short型按2字节、float按4字节）比n大时，按照n字节对齐。  
缺省或#pragma pack()，按自然边界对齐。  

```c
__attribute__((aligned(m)))
```
为编译器指定一个结构体或类或联合体或一个单独的变量的对齐方式 。  
按m字节对齐，且其占用空间大小也是m的整数倍，以保证在申请连续存储空间时各元素也按m字节对齐。  

```c
__attribute__((packed))
```
不对齐  

例如  

```c
#pragma pack(4)
typedef struct {
	uint32_t f1;
	uint8_t f2;
	uint8_t f3;
	uint32_t f4;
	uint64_t f5;
}__attribute__((aligned(1024)))ts;
sizeof(ts)==1024
f1 on address:0x0
f2 on address:0x4
f3 on address:0x5
f4 on address:0x8
f5 on address:0xc
```

越界访问和缓冲区溢出
===

C语言程序中对数组的访问可能会有意或无意地超越数组存储区范围而无法发现。数组存储区可以看成是一个缓冲区，超越数组存储区范围的写入操作称为缓冲区溢出。  
例子：  

```c
#include <stdio.h>
#include <string.h>
void outputs(char *str)
{
	char buffer[16];
	strcpy(buffer , str);
	printf("%s \n", buffer);
}
void hacker(void)
{
	printf("being hacked\n");
}
int main(int argc,char *argv[])
{
	outputs(argv[1]);
	return 0;
}
```
UNIX/Linux系统中，可通过调用execve函数来加载并执行程序  

```c
#include<unistd.h>
int execve(const char * filename,char * const argv[ ],char * const envp[ ]);
```
execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用指针数组来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组。  
在历史上，大多数UNIX系统对main函数提供了三个参数，原型如下：   

```c
int main(int argc, char *argv[], char *env[] );  
```
其中第三个参数是环境表地址。  
ANSI C规定main函数只有两个参数，而且第三个参数与全局变量environ相比也没有带来更多益处，所以POSIX.1也规定应使用environ而不使 用第三个参数。通常用getenv和putenv函数来存取特定的环境变量，而不是用environ变量。  

```c
//假设hacker首地址0x08048411
#include <stdio.h>
char shellcode[]=
"./ceshi"
"0123456789ABCDEFXXXX"
"\x11\x84\x04\x08"
"\x00";
int main(void )
{
	char *argv;
	argv = shellcode;
	execve(argv[0], argv, NULL);
	return 0;
}
```