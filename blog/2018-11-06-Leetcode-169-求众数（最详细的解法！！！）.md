---
layout: post
title: Leetcode 169：求众数（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-06 00:00:00
---

给定一个大小为 *n* 的数组，找到其中的众数。众数是指在数组中出现次数**大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在众数。

**示例 1:**

```
输入: [3,2,3]
输出: 3
```

**示例 2:**

```
输入: [2,2,1,1,1,2,2]
输出: 2
```

**解题思路**

首先想到的做法当然是统计`nums`中的所有元素个数，然后将最多的那个取出来即可。

```python
from collections import Counter
class Solution:
    def majorityElement(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums_dict = Counter(nums)
        most_val = nums_dict.most_common(1)
        return most_val[0][0]
```

这当然不是最快的方法。我们一直有一个条件没有使用**众数是指在数组中出现次数大于`⌊ n/2 ⌋` 的元素**。那么问题就很容易了，我们可以先将`nums`排序，然后返回中间元素的值即可（众数的个数大于一半，排好序的`nums`中间元素一定是众数）

```python
class Solution:
    def majorityElement(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums.sort()
        return nums[len(nums)//2]
```

这个问题最好的解法就是[摩尔投票法](https://blog.csdn.net/qq_17550379/article/details/83818965)

```python
class Solution:
    def majorityElement(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        res = cnt = 0
        for num in nums:
            if cnt == 0:
                res = num
                cnt += 1
            elif res == num:
                cnt += 1
            else:
                cnt -= 1
        return res
```

我们的时间复杂度就变成了`O(n)`，空间复杂度为`O(1)`。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**
