---
layout: post
title: Leetcode 65：有效数字（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-12-17 00:00:00
---

验证给定的字符串是否为数字。

例如:
`"0"` => `true`
`" 0.1 "` => `true`
`"abc"` => `false`
`"1 a"` => `false`
`"2e10"` => `true`

**说明:** 我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。

**更新于 2015-02-10:**
`C++`函数的形式已经更新了。如果你仍然看见你的函数接收 `const char *` 类型的参数，请点击重载按钮重置你的代码。

**解题思路**

类似问题

[Leetcode 8：字符串转换整数 (atoi)（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/84675410)

主要考虑这样的几种情况，首先我们将字符串两边的空格给去除。然后判断首个字符是不是`+-`其中之一，如果是的话，我们就要跳过。接下来我们就要判断字符串了，首先可以肯定的是，不能出现`'0123456789+-eE.'`之外的任何字符。我们分成以下几种情况考虑

- `'eE.'`只能出现一次
- `'eE'`不能出现在最后的位置，`'.'`可以出现在最后的位置
- `'eE.'`之前必须有数字
- 如果出现过了`'eE'`，那么`'.'`就不能再出现了
- 如果有`'+-'`，那么必须在`'eE'`之后的一位，并且出现在最后的位置

```python
class Solution:
    def isNumber(self, s):
        """
        :type s: str
        :rtype: bool
        """
        s = s.lstrip().rstrip()
        e, point, num = False, False, False
        i, s_len = 0, len(s)
        
        if s_len > 0 and s[i] in '+-':
            i += 1
            
        while i < s_len:
            c = s[i]
            if c in '0123456789':
                i += 1
                num = True
                continue
            elif c in 'eE':
                if not num or e or i == s_len - 1:
                    return False
                e = True
                if s[i+1] in '+-' and i < s_len - 2:
                    i += 1   
            elif c == '.':
                if point or e:
                    return False
                point = True
            else:
                return False                

            i += 1
        return num
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**