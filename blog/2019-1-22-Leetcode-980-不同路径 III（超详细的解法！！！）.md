---
layout: post
title: Leetcode 980：不同路径 III（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-22 00:00:00
---

在二维网格 `grid` 上，有 4 种类型的方格：

- `1` 表示起始方格。且只有一个起始方格。
- `2` 表示结束方格，且只有一个结束方格。
- `0` 表示我们可以走过的空方格。
- `-1` 表示我们无法跨越的障碍。

返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，**每一个无障碍方格都要通过一次**。

**示例 1：**

```
输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
输出：2
解释：我们有以下两条路径：
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
```

**示例 2：**

```
输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]
输出：4
解释：我们有以下四条路径： 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
```

**示例 3：**

```
输入：[[0,1],[2,0]]
输出：0
解释：
没有一条路能完全穿过每一个空的方格一次。
请注意，起始和结束方格可以位于网格中的任意位置。
```

**提示：**

1. `1 <= grid.length * grid[0].length <= 20`

**解题思路**

这是路径问题的第三个问题，之前问题

[Leetcode 62：不同路径（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82815121) 

[Leetcode 63：不同路径 II（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82826800)

通过提示，我们知道我们可以使用暴力法破解。我们首先需要找到开始和结束的位置，同时计算所有位置为`0`的数量（也就是我们必须要走的步数）。接下来问题就很简单了，就是通过`dfs`，边界条件是

- 所有位置都访问过了
- 到达终点了

```python
class Solution:
    def uniquePathsIII(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        start, end, p = None, None, 1
        row, col = len(grid), len(grid[0])
        for i in range(row):
            for j in range(col):
                if grid[i][j] == 1:
                    start = i, j
                elif grid[i][j] == 2:
                    end = i, j
                elif grid[i][j] == 0:
                    p += 1
                    
        def dfs(x, y, p):
            if not (0 <= x < row and 0 <= y < col and grid[x][y] >= 0):
                return 0
            if end == (x, y) and p == 0:
                return 1
            grid[x][y] = -1
            res = dfs(x+1, y, p-1) + dfs(x, y+1, p-1) + dfs(x-1, y, p-1) + dfs(x, y-1, p-1)
            grid[x][y] = 0
            return res
        
        return dfs(start[0], start[1], p)
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**