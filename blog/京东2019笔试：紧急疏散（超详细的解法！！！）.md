---
layout: post
title: 京东2019笔试：紧急疏散（超详细的解法！！！）
category : 算法
tags : [jingdong]
stickie: true
date: 2019-7-2 00:00:00
---

体育场突然着火了，现场需要紧急疏散，但是过道真的是太窄了，同时只能容许一个人通过。现在知道了体育场的所有座位分布，座位分布图是一棵树，已知每个座位上都坐了一个人，安全出口在树的根部，也就是1号结点的位置上。其他节点上的人每秒都能向树根部前进一个结点，但是除了安全出口以外，没有任何一个结点可以同时容纳两个及以上的人，这就需要一种策略，来使得人群尽快疏散，问在采取最优策略的情况下，体育场最快可以在多长时间内疏散完成。 

**输入描述:**

第一行包含一个正整数n，即树的结点数量（1<=n<=100000）。 接下来有n-1行，每行有两个正整数x，y，表示在x和y结点之间存在一条边。(1<=x，y<=n)

**输出描述:**

输出仅包含一个正整数，表示所需要的最短时间

**输入**

```
6
2 1
3 2
4 3
5 2
6 1
```

**输出**

```
4
```

**解题思路**

我们举一个例子

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/124/2018_12_28_1.png" width="200">
</center>

对于上图中节点`3`，我们不难发现最短需要用时就是`2`，因为`3`的右子树有`2`个节点，而左子树只有一个`1`。好，现在我们不难推测出，这个问题实际上在问**最大子树节点个数**。要注意一点该问题中没有说这是一颗二叉树，很有可能是一颗多叉树，那么就这就是一个图的遍历问题。图的遍历无非两种`dfs`和`bfs`。另外这个问题给我们的是一系列的边，那么我们可以通过数组模拟邻接表的方式去做。关于数组模拟邻接表，可以看我的另一篇文章[数组模拟邻接表（超详细！！！）](https://blog.csdn.net/qq_17550379/article/details/94871801)。

通过`dfs`

```cpp
#include <iostream>
#include <cstring>
using namespace std;
 
const int N = 1e5 + 10, M = N * 2;
struct Edge {
    int to, next;
} edge[M];
 
int head[N], idx, n;
 
void add(int a, int b)
{
    edge[idx].to = b;
    edge[idx].next = head[a];
    head[a] = idx++;
}
 
int dfs(int u, int fa)
{
    int res = 1;
    for (int i = head[u]; ~i; i = edge[i].next)
    {
        if (edge[i].to != fa) res += dfs(edge[i].to, u);
    }
    return res;
}
int main()
{
    cin >> n;
    memset(head, -1, sizeof head);
    for (int i = 0; i < n - 1; ++i)
    {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }
    int res = 0;
    for (int i = head[1]; ~i; i = edge[i].next)
        res = max(res, dfs(edge[i].to, 1));
    cout << res << endl;
    return 0;
}
```

通过`bfs`

```cpp
....

int q[N];
bool visited[N];
int bfs(int u)
{
    int hh = 0, tt = 0;
    q[0] = u;
    visited[u] = true;
    while (hh <= tt)
    {
        int t = q[hh++];
        for (int i = head[t]; ~i; i = edge[i].next)
        {
            int son = edge[i].to;
            if (!visited[son])
            {
                q[++tt] = son;
                visited[son] = true;
            }
        }
    }
    return tt + 1;
}
int main()
{
    ...
    visited[1] = true;
    for (int i = head[1]; ~i; i = edge[i].next)
        res = max(res, bfs(edge[i].to));
    cout << res << endl;
    return 0;
}
```

**如有问题，希望大家指出！！！**