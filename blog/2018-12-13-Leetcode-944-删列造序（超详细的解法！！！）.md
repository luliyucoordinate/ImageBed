---
layout: post
title: Leetcode 944：删列造序（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-23 00:00:00
---

给定由 `N` 个小写字母字符串组成的数组 `A`，其中每个字符串长度相等。

选取一个删除索引序列，对于 `A` 中的每个字符串，删除对应每个索引处的字符。 所余下的字符串行从上往下读形成列。

比如，有 `A = ["abcdef", "uvwxyz"]`，删除索引序列 `{0, 2, 3}`，删除后 `A` 为`["bef", "vyz"]`， `A` 的列分别为`["b","v"], ["e","y"], ["f","z"]`。（形式上，第 n 列为 `[A[0][n], A[1][n], ..., A[A.length-1][n]]`）。

假设，我们选择了一组删除索引 `D`，那么在执行删除操作之后，`A` 中所剩余的每一列都必须是 **非降序** 排列的，然后请你返回 `D.length` 的最小可能值。

**示例 1：**

```
输入：["cba", "daf", "ghi"]
输出：1
解释：
当选择 D = {1}，删除后 A 的列为：["c","d","g"] 和 ["a","f","i"]，均为非降序排列。
若选择 D = {}，那么 A 的列 ["b","a","h"] 就不是非降序排列了。
```

**示例 2：**

```
输入：["a", "b"]
输出：0
解释：D = {}
```

**示例 3：**

```
输入：["zyx", "wvu", "tsr"]
输出：3
解释：D = {0, 1, 2}
```

**提示：**

1. `1 <= A.length <= 100`
2. `1 <= A[i].length <= 1000`

**解题思路**

这个问题非常简单，最简单的思路就是先将`A`中的元素转置，然后判断每一行是不是有序即可。

```python
class Solution:
    def minDeletionSize(self, A):
        """
        :type A: List[str]
        :rtype: int
        """
        if not A:
            return 0
        A_len, s_len = len(A), len(A[0])
        tmp = [[0]*A_len for _ in range(s_len)]
        for i, s in enumerate(A):
            for j, ch in enumerate(s):
                tmp[j][i] = ch

        count = 0
        for s in tmp:
            for j in range(1, len(s)):
                if s[j-1] > s[j]:
                    count += 1
                    break

        return count
```

在`python`中转置操作可以使用`zip`快速实现。

```python
class Solution:
    def minDeletionSize(self, A):
        """
        :type A: List[str]
        :rtype: int
        """
        return sum(list(a) != sorted(a) for a in zip(*A))
```

当然我们也可以不进行转置，直接在对应位置元素上进行判断。

```python
class Solution:
    def minDeletionSize(self, A):
        """
        :type A: List[str]
        :rtype: int
        """
        if not A:
            return 0

        result = 0
        for c in range(len(A[0])):
            for r in range(len(A)-1):
                if A[r][c] > A[r+1][c]:
                    result += 1
                    break
        return result
```

对于这种做法，我们使用`zip`也可以快速实现。

```python
class Solution:
    def minDeletionSize(self, A):
        """
        :type A: List[str]
        :rtype: int
        """
        return sum(any(a > b for a, b in zip(col, col[1:])) for col in zip(*A))
```

reference:

https://leetcode.com/problems/delete-columns-to-make-sorted/discuss/194919/Python-Count-Unsorted-Columns

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**