---
layout: post
title: Leetcode 962：最大宽度坡（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-12-24 00:00:00
---

给定一个整数数组 `A`，*坡*是元组 `(i, j)`，其中  `i < j` 且 `A[i] <= A[j]`。这样的坡的宽度为 `j - i`。

找出 `A` 中的坡的最大宽度，如果不存在，返回 0 。

**示例 1：**

```
输入：[6,0,8,2,1,5]
输出：4
解释：
最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5.
```

**示例 2：**

```
输入：[9,8,1,0,1,9,4,0,4,1]
输出：7
解释：
最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1.
```

**提示：**

1. `2 <= A.length <= 50000`
2. `0 <= A[i] <= 50000`

**解题思路**

首先暴力破解，我们从大到小遍历所有的长度，然后判断相应长度是否存在符合条件的值，如果存在，我们返回对应长度即可。

```python
class Solution:
    def maxWidthRamp(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        for l in range(len(A), -1, -1):
            for i in range(len(A)-l):
                if A[i] <= A[i+l]:
                    return l
                
        return 0
```

显然这种方法太慢了。

对于这个问题我首先想到的就是索引堆。我们可以对输入的数组中的数编号。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/962/2018_12_24_1.png" width="200" hegiht="150">
</center>

此时我们再对输入的数组排序，那么编号也会随着变化。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/962/2018_12_24_2.png" width="200" hegiht="150">
</center>

这样我们只需要比较前后编号差，找到差值最大是多少。代码如下

```python
class Solution:
    def maxWidthRamp(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        a_list = list()
        for i, a in enumerate(A):
            a_list.append((a, i))
            
        a_list.sort(key=lambda x:x[0])
        res, l = 0, a_list[0][1]
        for it in a_list[1:]:
            res = max(res, it[1] - l)
            l = min(l, it[1])
            
        return res
```

这个问题我们可以通过单调栈来解决，关于**单调栈**在之前的一个问题[Leetcode 84：柱状图中最大的矩形（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/85093224)中使用过。只不过这里有一些特别，我们此时栈中存放的是元素的位置，并且我们这个是单调递减栈。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/962/2018_12_24_3.png" width="200" hegiht="150">
</center>

此时我们栈中的元素是`[0,1]`。

我们接着从后向前遍历数组中的元素，如果元素大于栈顶元素的话，我们就计算当前距离，并且栈顶元素出栈，直到栈空为止。

```python
class Solution:
    def maxWidthRamp(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        stack = list()
        res = 0
        for i, a in enumerate(A):
            if not stack or A[stack[-1]] > a:
                stack.append(i)
                
        for j in range(len(A))[::-1]:
            while stack and A[stack[-1]] <= A[j]:
                res = max(res, j - stack.pop())
                
        return res
```

reference:

https://leetcode.com/problems/maximum-width-ramp/discuss/208348/JavaC%2B%2BPython-O(N)-Using-Stack

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**