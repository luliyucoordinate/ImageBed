---
layout: post
title: Leetcode 377：组合总和 Ⅳ（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-09-30 00:00:00
---

给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

**示例:**

```
nums = [1, 2, 3]
target = 4

所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

请注意，顺序不同的序列被视作不同的组合。

因此输出为 7。
```

**进阶：**
如果给定的数组中含有负数会怎么样？
问题会产生什么变化？
我们需要在题目中添加什么限制来允许负数的出现？

**解题思路**

这是之前问题的变种

[Leetcode 39：组合总和（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82561538) 

[Leetcode 40：组合总和 II（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82591181) 

[Leetcode 216：组合总和 III（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82593989) 

注意，实际这里的问题和`39`更贴近，我们可以先尝试能不能从之前问题中得到启发。我们直接在原问题上修改

```python
class Solution:
    def combinationSum4(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """    
        if not nums:
            return 0
        
        result = list()
        nums.sort()
        self._combinationSum4(nums, target, list(), result)
        return len(result)

    def _combinationSum4(self, nums, target, path, res):
        if target == 0:
            res.append(path)
            return 

        if target < nums[0]:
            return

        for i in range(len(nums)):
            self._combinationSum4(nums, target-nums[i], path+[nums[i]], res)
```

但是这种解法的速度实在太慢了，我们每次都要重新遍历一次`nums`。所以我们可以通过记忆化搜索的方法对这个问题进行优化。

```python
class Solution:
    def combinationSum4(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """ 
        mem = [None]*(target+1)
        nums.sort()
        return self._combinationSum4(nums, target, mem)
        
    def _combinationSum4(self, nums, target, mem):
        if target == 0:
            return 1

        if mem[target] != None:
            return mem[target]

        mem[target] = 0
        for num in nums:
            if num > target:
                break
            mem[target] += self._combinationSum4(nums, target - num, mem)

        return mem[target]
```

我们处理使用上面的方法之外，还可以通过动态规划的方法解决这个问题。对于题目中的例子来说，我们要知道`target=4`有多少组解，我们只需要知道`target=3,2,1`个有多少组解，然后将它们加起来即可。也就是

```
f(i) = f(i) + f(i - num)   for num in nums and if i > num
```

基于此，我们可以快速的写出下面的代码

```python
class Solution:
    def combinationSum4(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """ 
        mem = [0]*(target + 1)
        mem[0] = 1
        for i in range(1, target +1):
            for num in nums:
                if i >= num:
                    mem[i] += mem[i - num]

        return mem[target]
```

但是这个问题到此还没有结束，我们因该思考一下这个进阶问题，如果有负数会怎么样？如果存在负数的话，我们就需要在问题中添加`nums`中个元素使用次数的限制，否则会出现无限种可能，例如`nums=[-1,1] target=0`。OK!!!所有问题解决。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**