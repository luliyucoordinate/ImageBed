---
layout: post
title: Leetcode 956：最高的广告牌（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-12-18 00:00:00
---

你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。

你有一堆可以焊接在一起的钢筋 `rods`。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。

返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。 

**示例 1：**

```
输入：[1,2,3,6]
输出：6
解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。
```

**示例 2：**

```
输入：[1,2,3,4,5,6]
输出：10
解释：我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。
```

**示例 3：**

```
输入：[1,2]
输出：0
解释：没法安装广告牌，所以返回 0。
```

**提示：**

1. `0 <= rods.length <= 20`
2. `1 <= rods[i] <= 1000`
3. `钢筋的长度总和最多为 5000`

**解题思路**

对于这个问题首先想到的解决思路是通过`DFS`。我们遍历`rods`中的元素，我们对每个元素都有如下三种考量。

- 放左边
- 放右边
- 不放

当我们左边钢筋的长度`left`和右边钢筋的长度`right`是一样的时候，我们就需要记录这种情况下的最大值`res`。我们在初始的时候需要记录一个最大容量`maxsum`（`sum(rods)`），我们每次遍历的过程中需要更新它，也就是我们每使用一个钢筋`i`，我们就要将`maxsum`减去相应的值`rods[i]`。我们接着思路递归到底的情况。

- 遍历完`rods`的最后一个元素
- $abs(left-right) > maxsum$
- $left+right+maxsum<=res*2$

第一种情况自然不用多说。第二种情况，我们最后无法得到`left==right`的情形，所以也要返回。对于第三种情况，我们此时`res`就是最大长度了，所以直接返回就可以了。

我们在一开始的时候，也就是放入第一根钢筋的时候，我们只要考虑放和不放，而不需要考虑放左还是放右。一切安排妥当，我们开始写代码

```python
class Solution:
    def tallestBillboard(self, rods):
        """
        :type rods: List[int]
        :rtype: int
        """
        if len(rods) == 0 or len(rods) == 1:
            return 0
        
        self.res = 0
        
        rods.sort(reverse=True)# add sort
        remain = sum(rods)
        self.dfs(rods, remain - rods[0], 0, rods[0], 0)
        self.dfs(rods, remain - rods[0], 0, 0, 0)
        
        return self.res
    
    def dfs(self, rods, remain, i, left, right):
        if abs(left - right) > remain or\
            (left + right + remain <= self.res*2):
            return
        
        if left == right and self.res < left:
            self.res = left
            
        i += 1
        if i == len(rods):
            return 
        
        remain -= rods[i]
        self.dfs(rods, remain, i, left + rods[i], right)
        self.dfs(rods, remain, i, left, right + rods[i])
        self.dfs(rods, remain, i, left, right)
```

但是我们这样做了之后超时了。我们需要一步优化，我们可以在开始的时候对`rods`按照从大到小排序（贪心策略）。

这个问题有个巧妙的方法，我们首先定义函数$f(a,b)$返回距离差是$abs(a-b)$的最大公共长度。例如

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/956/2018_12_18_1.png" width="250" hegiht="150">
</center>

我们此时知道两者长度相差$d$，那么此时$f(d)=len(red)$。此时如果我们新加入一个钢筋`x`，那么我们有两种策略，第一种是加在上面

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/956/2018_12_18_2.png" width="250" hegiht="150">
</center>

那么我们知道此时的$f(d+x)=max(f(d+x), len(red))$。我们也可以将它加入到下面

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/956/2018_12_18_3.png" width="250" hegiht="150">
</center>

那么我们知道此时的$f(d-x)=max(f(d-x),len(red)+x)$，或者也可以是下面这种

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/956/2018_12_18_4.png" width="250" hegiht="150">
</center>

那么我们知道此时的$f(x-d)=max(f(x-d),len(red)+d)$。

但是这样做有什么用呢？我们虽然能保证最大的公有长度，但是这个公有长度不一定可以通过所给的`rods`中的元素拼凑出来啊？是的，确实是这样。但是我们可以保证的是$f(0)$一定可以通过`rods`中的元素拼凑出来，而$f(0)$恰好就是我们所需要的结果，非常好的思路。

```python
class Solution:
    def tallestBillboard(self, rods):
        """
        :type rods: List[int]
        :rtype: int
        """
        mem = {0: 0}
        
        for i in rods:
            cur = mem.copy()
            for d, val in cur.items():
                mem[d + i] = max(mem.get(i + d, 0), val)
                mem[abs(d - i)] = max(mem.get(abs(d - i), 0), val + min(i, d))
                
        return mem[0]
```

reference:

https://leetcode.com/problems/tallest-billboard/discuss/203181/JavaC++Python-DP-min(O(SN2)-O(3N2-*-N)

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**