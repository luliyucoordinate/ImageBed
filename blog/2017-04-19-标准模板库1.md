---
layout: post
title: 标准模板库(1)
category : cpp
tags : [cpp, notes, cpp标准库]
stickie: true
---

容器(Container)
===
序列式容器(Sequence container):array,vector,deque,list and forward_list  
关联式容器(Associative container):set,multiset,map and multimap  
无序容器:(Unordered(associative)container):unordered_set,unordered_multiset,unordered_map,unordered_multimap

序列式容器(Sequence container)
---
自c++11开始，c++标准库提供另一个list容器：forward list。forward list是一个单向链表。  
因此，forward list原则上就是一个受限的list，你无法查找某个元素然后删除它，或是在他的前面安插另一个元素。因此，为了删除某个元素，你必须位于其前一个元素的位置上，因为正是那个元素，才决定一个新的后继元素。也因此，forward list对此提供了一个特殊的成员函数erase_after()  
例子：

```c++
#include <forward_list>
#include <iostream>
using namespace std;
int main()
{
    // create forward-list container for some prime numbers
    forward_list<long> coll = { 2, 3, 5, 7, 11, 13, 17 };
    // resize two times
    // - note: poor performance
    coll.resize(9);
    coll.resize(10,99);
    // print all elements:
    for (auto elem : coll) {
        cout << elem << ' ';
    }
    cout << endl;
}
```

关联式数组(Associative Array)
---
不论map或unordered map，都是key/value pair形成的集合，每个元素都带着独一无二的key。这样的集合也可以被视为一个关联式数组，也就是“索引并非整数”的array。也因此，刚才说的两个容器，都可以使用[]操作符。

```c++
#include <unordered_map>
#include <string>
#include <iostream>
using namespace std;

int main()
{
    // type of the container:
    // - unordered_map: elements are key/value pairs
    // - string: keys have type string
    // - float: values have type float
    unordered_map<string,float> coll;

    // insert some elements into the collection
    // - using the syntax of an associative array
    coll["VAT1"] = 0.16;
    coll["VAT2"] = 0.07;
    coll["Pi"] = 3.1415;
    coll["an arbitrary number"] = 4983.223;
    coll["Null"] = 0;

    // change value
    coll["VAT1"] += 0.03;

    // print difference of VAT values
    cout << "VAT difference: " << coll["VAT1"] - coll["VAT2"] << endl;
}
```
自C++11开始，你也可以使用at()访问元素的value，只要传给他key就行。这种情况下如果容器内找不到给定的key，会导致out_of_range异常:

```c++
coll.at("VAT1") = 0.1;
```
使用map与使用unordered_map的差异在于，元素在unordered_map的次序有各种可能，但元素在map内一定是排序过的。但由于unordered_map的操作属于“amortized constant”复杂度，map提供的是“对数复杂度”，所以通常宁可使用unordered_map而放弃map，除非你需要排序。  
容器适配器(Container Adapter)  
Stack 名字足以说明。Stack容器对元素采取的是LIFO(后进先出)管理策略。  
Queue 对元素采取FIFO(先进先出)管理策略。也就是说，他就是一个寻常的缓冲区(buffer)。  
Priority queue 其内的元素拥有各种优先权。所谓的优先权是基于程序员提供的排序准则(默认为操作符<)而定义。  
迭代器(Iterator)  
任何容器都定义两种迭代器类型：  
1.  container::iterator以“读/写”模式遍历元素。
2.  container::const_iterator以“只读”模式遍历元素。

我们可以使用关键字auto代替迭代器的精确类型。因此我们直接以begin初始化迭代器，就可以使用auto声明其类型：

```c++
for(auto pos = coll.begin(); pos != coll.end(); ++pos)
	cout << *pos << endl;
```
采用这种写法，万一容器类型发生变化，程序整体仍能保持较佳的健壮性。然而其缺点是，迭代器丧失常量性，可能引发“计划外的赋值”风险。因为

```c++
auto pos = coll.begin();
```
会使pos是一个非常量迭代器，因为begin()返回的是个类型为cont::iterator的对象。为确保仍可使用常量迭代器，自C++11起容器提供cbegin和cend，他们放回一个cont::const_iterator的对象。

算法(Algorithm)
===
区间(Range)
---
所有算法处理的都是半开区间(half-open range)—包括其实元素的位置但并不包括末尾元素的位置。  
半开区间的有点主要是单纯，可免除对空集做特殊处理。当然，金无足赤，世上没有完美的设计。  
例子：

```c++
#include <algorithm>
#include <list>
#include <iostream>
using namespace std;
int main()
{
    list<int> coll;
    // insert elements from 20 to 40
    for (int i=20; i<=40; ++i) {
        coll.push_back(i);
    }
    // find position of element with value 3
    // - there is none, so pos3 gets coll.end()
    auto pos3 = find (coll.begin(), coll.end(),    // range
                      3);                          // value
       // reverse the order of elements between found element and the end
    // - because pos3 is coll.end() it reverses an empty range
    reverse (pos3, coll.end());
    // find positions of values 25 and 35
    list<int>::iterator pos25, pos35;
    pos25 = find (coll.begin(), coll.end(),  // range
                  25);                       // value
    pos35 = find (coll.begin(), coll.end(),  // range
                  35);                       // value
    // print the maximum of the corresponding range
    // - note: including pos25 but excluding pos35
    cout << "max: " << *max_element (pos25, pos35) << endl;
    // process the elements including the last position
    cout << "max: " << *max_element (pos25, ++pos35) << endl;
}
```
查找元素3的任务失败后，find()返回区间的结束位置并赋值给pos3。所以reverse()的结果就是相当于：

```c++
reverse(coll.end(), coll.end());
```

处理多重区间(Multiple Ranges)
---
有数个算法可以同时处理多重区间。通常你必须设定第一区间的起点和终点，至于其他区间，只需设定起点即可，终点通常可由第一区间的元素数量推导出来。例如，equal从头开始比较coll1和coll2的所有元素：

```c++
if( equal(coll1.begin(), coll1,end(),
			coll.begin()){
	...
}
```
于是，coll2之中参与比较的元素数量，间接取决于coll1内的数量。  
这使得我们获得一个重要的心得：如果某个算法用来处理多重区间，那么当你调用它时，务必确保第二区间所拥有的元素个数至少和第一区间内的元素个数相同。
注意下面这个例子：

```c++
#include <algorithm>
#include <list>
#include <vector>
using namespace std;

int main()
{
    list<int>   coll1 = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    vector<int> coll2;

    // RUNTIME ERROR:
    // - overwrites nonexisting elements in the destination
    copy (coll1.cbegin(), coll1.cend(),   // source
          coll2.begin());                 // destination
    //...
}
```
想要避免上面的错误，你可以确定目标区间内有足够的元素空间，或是采用insert iterator。  
为了是目标区间足够大，你可以一开始给他一个正确的大小，也可以显示的变更他的大小。

```c++
#include <algorithm>
#include <list>
#include <vector>
#include <deque>
using namespace std;

int main()
{
    list<int>   coll1 = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    vector<int> coll2;

    // resize destination to have enough room for the overwriting algorithm
    coll2.resize (coll1.size());

    // copy elements from first into second collection
    // - overwrites existing elements in destination
    copy (coll1.cbegin(), coll1.cend(),   // source
          coll2.begin());                 // destination

    // create third collection with enough room
    // - initial size is passed as parameter
    deque<int> coll3(coll1.size());

    // copy elements from first into third collection
    copy (coll1.cbegin(), coll1.cend(),   // source
          coll3.begin());                 // destination
}
```
注意这两种做法都会产生新元素并赋初值。这些元素由default构造函数初始化，没有任何实参。你可以传递额外的实参给构造函数和resize()，这样就可以按你的意思将新元素初始化。

迭代器之适配器(Iterator Adapter)
===
C++11标准库提供了数个预定义的特殊迭代器，亦即所谓迭代器适配器(iterator adapter)。

Insert Iterator(安插型迭代器)
---
它可以使算法以安插方式而非覆写方式运作。使用它可以解决算法的“目标空间不足”问题。她会促使目标区间的大小按需求成长。  
Insert iterator内部将接口做了新的定义：  
如果你将某个元素赋值，会引发“对其所属集合的按插动作”。至于插入位置是在容器的最前或最后，或某特定位置上，要视三种不同的insert iterator而定。
单步前行不会构成任何动静。

```c++
#include <algorithm>
#include <iterator>
#include <list>
#include <vector>
#include <deque>
#include <set>
#include <iostream>
using namespace std;

int main()
{
    list<int> coll1 = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    // copy the elements of coll1 into coll2 by appending them
    vector<int> coll2;
    copy (coll1.cbegin(), coll1.cend(),    // source
          back_inserter(coll2));           // destination

    // copy the elements of coll1 into coll3 by inserting them at the front
    // - reverses the order of the elements
    deque<int> coll3;
    copy (coll1.cbegin(), coll1.cend(),    // source
          front_inserter(coll3));          // destination

    // copy elements of coll1 into coll4
    // - only inserter that works for associative collections
    set<int> coll4;
    copy (coll1.cbegin(), coll1.cend(),    // source
          inserter(coll4,coll4.begin()));  // destination
}
```
这个例子运用了三个预定义的insert iterator  
Back inserter其内部调用push_back()，在容器末尾插入元素。  
Front inserter其内部调用push_front()，将元素安插于容器最前端。  
General inserter这种一般性的inserter，简称inserter，它的作用是在“初始化时接受第二实参”所指位置的前方插入元素。其内部调用成员函数insert()，因此这是唯一可用于关联式容器身上的一种预定义inserter。

Stream Iterator(串流迭代器)
---
Stream Iterator被用来读写stream。他们提供了必要的抽象性，使得来自键盘的输入像是个集合，你能够从中读取内容。同样道理，你也可以把一个算法输出结果重新导向到某个文件或屏幕上。

```c++
#include <iterator>
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>
using namespace std;

int main()
{
    vector<string> coll;

    // read all words from the standard input
    // - source: all strings until end-of-file (or error)
    // - destination: coll (inserting)
    copy (istream_iterator<string>(cin),    // start of source
          istream_iterator<string>(),       // end of source
          back_inserter(coll));             // destination

    // sort elements
    sort (coll.begin(), coll.end());

    // print all elements without duplicates
    // - source: coll
    // - destination: standard output (with newline between elements)
    unique_copy (coll.cbegin(), coll.cend(),           // source
                 ostream_iterator<string>(cout,"\n")); // destination
}
```
istream_iterator<string>(cin)会产生一个可从“标准输入串流cin”读取数据的stream iterator。其中的template实参string表示这个stream iterator专门读取这个类型的元素。这些元素通过一般的operator >> 被读取出来。

Reverse Iterator(反向迭代器)
---
Reverse iterator会造成算法逆向操作。所有提供双向迭代器或随机访问迭代器的容器都可以通过他们的成员函数rbegin和rend产生一个反向迭代器。自C++11开始还提供一组对应成员函数crbegin和crend，它们会返回只读反向迭代器。  
Forward_list和所有无序容器都没有提供回向迭代接口，即rbegin和rend等等。原因是那些容器内部实现只是使用singly linked list传奇所有元素。

```c++
#include <iterator>
#include <algorithm>
#include <vector>
#include <iostream>
using namespace std;

int main()
{
    vector<int> coll;

    // insert elements from 1 to 9
    for (int i=1; i<=9; ++i) {
        coll.push_back(i);
    }

    // print all element in reverse order
    copy (coll.crbegin(), coll.crend(),      // source
          ostream_iterator<int>(cout," "));  // destination
    cout << endl;
}
```
采用reverse iterator，所有算法便可以不需特殊处理就以相反方向操作容器，这自然是美事一桩。
