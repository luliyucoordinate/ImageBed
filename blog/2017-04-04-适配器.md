---
layout: post
title: 适配器 adapters
category : cpp
tags : [cpp, stl, 适配器]
stickie: true
---


容器的适配器：stack，queue
===
```c++
template <class T, class Sequence=deque<T>>
class stack
{
...
public:
	typedef typename Sequence::value_type value_type;
	typedef typename Sequence::size_type size_type;
	typedef typename Sequence::reference reference;
	typedef typename Sequence::const_reference const_reference;
protected:
	Sequence c;//底层容器deque
public:
	bool empty() const { return c.empty(); }
	size_type size() const { return c.size(); }
	reference top() { return c.back(); }
	const_reference top() const { return c.back(); }
	void push(const value_type& x) { c.push_back(x); }
	void pop() { c.pop_back(); }
};
```


函数适配器binder2nd
===
```c++
template <class Operation, class T>
inline binder2nd<Operation> bind2nd (const Operation& op, const T& x)
{
//辅助函数，让user更方便的使用binder2nd
	typedef typename Operation::second_argument_type arg2_type;
//typename 原因在于不知道后面的类型，所以要告诉编译器他是一个typename
	return binder2nd<Operation>(op, arg2_type(x));
}
template <class Operation>
class bind2nd :public unary_function<typename Operation::first_argument_type,
									typename Operation::result_type>
//注意这里的继承，如果这个functor还可以被别人使用的话
{
protected:
	Operation op;//内部成员
	typename Operation::second_argument_type value;
public:
	binder2nd(const Operation& x, const typename Operation::second_argument_type)
	: op(x), value(y) {}
	typename Operation::result_type
	operator()(const typename Operation::first_argument_type& x) const
	{
		return op(x, value);
	}
};
```


函数适配器not1
===
```c++
template <class Predicate>
inline unary_negate<Predicate>not1(const Predicate& pred)
{
	return unary_negate<Predicate>(pred);
}
template <class Predicate>
class unary_negate
:public unary_function<typename Predicate::argument_type, bool>
{
protected:
	Predicate pred;
public:
//explicit关键字的作用就是防止类构造函数的隐式自动转换
	explicit unary_negate(const Predicate& x) : pred(x) {}
	bool operator()(const typename Predicate::argument_type& x) const
	{ return !pred(x); }
};
```

新型适配器bind
---

Since c++11  
<functional>bind -----><functional>binder1st  
<functional>bind -----><functional>binder2nd  
<functional>bind -----><functional>bind1st  
<functional>bind -----><functional>bind2nd

可以绑定
1.  functions 
2.  functions objects 
3.  member functions ，_1必须是某个object的地址
4.  data members，_1必须是某个object的地址

```c++
// bind example
#include <iostream>     // std::cout
#include <functional>   // std::bind
// a function: (also works with function object: std::divides<double> my_divide;)
double my_divide (double x, double y) {return x/y;}
struct MyPair
{
  double a,b;
  double multiply() {return a*b;}
};
int main () 
{
  using namespace std::placeholders;    // adds visibility of _1, _2, _3,...占位符
  // binding functions:
  auto fn_five = std::bind (my_divide,10,2);               // returns 10/2
  std::cout << fn_five() << '\n';                          // 5

  auto fn_half = std::bind (my_divide,_1,2);               // returns x/2
  std::cout << fn_half(10) << '\n';                        // 5

  auto fn_invert = std::bind (my_divide,_2,_1);            // returns y/x
  std::cout << fn_invert(10,2) << '\n';                    // 0.2

  auto fn_rounding = std::bind<int> (my_divide,_1,_2);     // returns int(x/y)
  std::cout << fn_rounding(10,3) << '\n';                  // 3

  MyPair ten_two {10,2};

  // binding members:
  auto bound_member_fn = std::bind (&MyPair::multiply,_1); // returns x.multiply()
  std::cout << bound_member_fn(ten_two) << '\n';           // 20

  auto bound_member_data = std::bind (&MyPair::a,ten_two); // returns ten_two.a
  std::cout << bound_member_data() << '\n';                // 10

  return 0;
}

```
