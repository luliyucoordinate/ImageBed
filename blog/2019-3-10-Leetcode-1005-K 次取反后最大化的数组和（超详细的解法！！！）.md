---
layout: post
title: Leetcode 1005：K 次取反后最大化的数组和（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-3-10 00:00:00
---

给定一个整数数组 A，我们**只能**用以下方法修改该数组：我们选择某个个索引 `i` 并将 `A[i]` 替换为 `-A[i]`，然后总共重复这个过程 `K` 次。（我们可以多次选择同一个索引 `i`。）

以这种方式修改数组后，返回数组可能的最大和。

**示例 1：**

```
输入：A = [4,2,3], K = 1
输出：5
解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。
```

**示例 2：**

```
输入：A = [3,-1,0,2], K = 3
输出：6
解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。
```

**示例 3：**

```
输入：A = [2,-3,-1,5,-4], K = 2
输出：13
解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。
```

**提示：**

1. `1 <= A.length <= 10000`
2. `1 <= K <= 10000`
3. `-100 <= A[i] <= 100`

**解题思路**

这个问题非常简单，我首先是这样思考的。我们先对`A`排序，然后统计`A`中有多少个负数`neg`，如果`K<=neg`，说明取反的次数比负数少，那么我们返回`sum(A[K:]) - sum(A[:K])`（也就是将最小的`K`个负数取反）。如果`K>neg`，那么我们首先将前`neg`个负数取反，然后再对`A`排序，同时我们还需计算`K-=neg`（剩余反转次数）。如果`K`是偶数，返回`sum(A)`，如果是奇数，返回`sum(A[1:]) - A[0] `（也就是只对最小的那个元素操作）

或者我们不进行二次排序，最后返回`sum(A)-2*min(A)`（是同一个意思，都是在找最小值）。

```python
class Solution:
    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:
        A.sort()
        neg = 0
        for i in A:
            if i >= 0:
                break
            neg += 1

        if K <= neg:
            return sum(A[K:]) - sum(A[:K])
        
        for i in range(neg):
            A[i] = -A[i]

        K -= neg
        if K & 1 == 0:
            return sum(A)
        return sum(A) - 2*min(A) 
```

我们还有一个更好的做法，就是直接排好序后，对前`K`个负数反转（如果负数没有`K`个，就对所有负数反转），最后判断剩余反转次数是偶数还是奇数，然后进行前面写法的操作即可。

```python
class Solution:
    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:
        A.sort()
        i = 0
        while i < len(A) and i < K and A[i] < 0:
            A[i] = -A[i]
            i += 1
        return sum(A) - (K - i)%2*min(A)*2
```

reference:

https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/discuss/252254/C%2B%2BPython-Sort

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**