---
layout: post
title: Leetcode 349:两个数组的交集
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-06-04 00:00:00
---

给定两个数组，写一个函数来计算它们的交集。

**例子:**

 给定 *num1*= `[1, 2, 2, 1]`, *nums2* = `[2, 2]`, 返回 `[2]`.

**提示:**

- 每个在结果中的元素必定是唯一的。
- 我们可以不考虑输出结果的顺序。

**解题思路**

由于问题中的元素是唯一的，所以我们只关心元素的有无，那么我们可以使用`set`这个结构。首先将`nums1`的所有数据存入`set`中，查找`nums2`中的数据是否在这个`set`中，如果在的话，我们将这个元素存入一个`list`里面。

```python
class Solution:
    def intersection(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        nums1 = set(nums1)
        result = set()
        for i in nums2:
            if i in nums1:
                result.add(i)
        return list(result)
```

一种`pythonic`的做法

```python
class Solution:
    def intersection(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        return list(set(nums1) & set(nums2))
```

我们知道一般`set`的底层实现是通过平衡二叉树实现的，那么添加元素和搜索元素的时间复杂度都是`O(logn)`这个级别的，那么上述的算法时间复杂度是`O(nlogn)`这个级别的。

但是在`python`中`set`的底层实现是通过`hash`表实现的，所以添加元素和搜索元素的时间复杂度都是`O(1)`级别的，那么上述的算法时间复杂度是`O(n)`这个级别的。而空间复杂度依旧是`O(n)`级别的。如果要使用平衡二叉树的版本，要使用`frozenset`。因为我们使用了两个`set`，所以空间复杂度是`O(n)`级别的。

该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)

**如有问题，希望大家指出！！！**