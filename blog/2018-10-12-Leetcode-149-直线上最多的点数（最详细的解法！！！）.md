---
layout: post
title: Leetcode 149：直线上最多的点数（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-10-12 00:00:00
---

给定一个二维平面，平面上有 *n* 个点，求最多有多少个点在同一条直线上。

**示例 1:**

```
输入: [[1,1],[2,2],[3,3]]
输出: 3
解释:
^
|
|        o
|     o
|  o  
+------------->
0  1  2  3  4
```

**示例 2:**

```
输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
输出: 4
解释:
^
|
|  o
|     o        o
|        o
|  o        o
+------------------->
0  1  2  3  4  5  6
```

**解题思路**

这个问题我们有一个最简单的思路，就是我们先从所有点中找出两个点，然后用这两个点构成一条直线，然后再计算有多少点在这个直线上，我们记录它。接着找下一条直线，直到我们计算完所有直线对应的点的个数。这种解法的时间复杂度是`O(n^3)`，显然太慢了，而且实际操作起来也很麻烦。

我们知道一个线段是由斜率和截距决定的，实际上如果我们知道了一个直线上的点和这条直线的斜率也能确定这条直线。基于此，我们可以遍历所以点`point`，计算其余点和`point`构成的直线的斜率，如果斜率相同，那么说明两个点在一条直线上，我们只要记录点的个数，最后找到最大值即可。对于上述算法我要注意一个问题，就是存在相同点的情况，我们需要对此加以处理。

```python
from collections import defaultdict
class Solution:
    def maxPoints(self, points):
        """
        :type points: List[Point]
        :rtype: int
        """
        slopes, result = defaultdict(int), 0
        for i, point1 in enumerate(points): 
            slopes.clear()
            duplicate = 1
            for _, point2 in enumerate(points[i+1:]):
                if point1.x == point2.x and point1.y == point2.y:
                    duplicate += 1
                    continue

                slope = float('inf') if point1.x == point2.x else \
                            (point1.y - point2.y)/(point1.x - point2.x)

                slopes[slope] += 1

            if result < duplicate:
                result = duplicate

            for _, val in slopes.items():
                if val + duplicate > result:
                    result = val + duplicate

        return result
```

但是实际操作的过程中，我们发现上面的代码还有一个`bug`。例如

```
[Point(0, 0), Point(94911151, 94911150), Point(94911152, 94911151)]
94911150/94911151=0.9999999894638303
94911151/94911152=0.9999999894638303
```

我们发现，对于斜率很靠近的线，`python`的计算精度不够。我们可以使用`Decimal`。

```python
from decimal import Decimal
Decimal((point2.y - point1.y))/Decimal((point2.x - point1.x))
```

但是为此我们需要牺牲一些计算上的耗时。另外一种策略是我们不计算斜率的具体数值，而是通过分式表示。这就涉及到了如何计算最简分式的问题，我们可以通过计算最大公约数来解决，具体操作可以看我的CPP实现。

现在我们将算法优化到了`O(n^2)`这个级别。有没有更好的呢？暂时没有找到更好的办法，留待以后解决。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**