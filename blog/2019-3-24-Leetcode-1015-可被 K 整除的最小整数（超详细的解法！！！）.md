---
layout: post
title: Leetcode 1015：可被 K 整除的最小整数（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-3-24 00:00:00
---

给定正整数 `K`，你需要找出可以被 K 整除的、仅包含数字 **1** 的最小正整数 N。

返回 `N` 的长度。如果不存在这样的 `N`，就返回 `-1`。

**示例 1：**

```
输入：1
输出：1
解释：最小的答案是 N = 1，其长度为 1。
```

**示例 2：**

```
输入：2
输出：-1
解释：不存在可被 2 整除的正整数 N 。
```

**示例 3：**

```
输入：3
输出：3
解释：最小的答案是 N = 111，其长度为 3。 
```

**提示：**

- `1 <= K <= 10^5`

**解题思路**

比赛的时候被这个问题卡了很久，(⊙﹏⊙)b。这个使用暴力法是可以过的，不过上界的选择是有讲究的，我们最多只计算`K`次，为什么？

> 1到111..111(K个1）中必然有个（K-i)个1组成的数能被K整除（除2和5的倍数）。 
>
> 假设不是的话，那么1到K个1组成的数除以K的余数必然有重复的（因为1到K个1组成的数的余数个数是K，而1到K-1才K-1个数，就多出来一个数，抽屉原理），假设两个重复余数的数是i个1组成的数和j个1组成的数，其中i>j。因为它们余数相同，所以它们的差可以被K整除。但是它们的差是以0结尾的，可以被2整除，就必然不能被K整除，所以假设不成立。

```python
class Solution:
    def smallestRepunitDivByK(self, K: int) -> int:
        if K % 2 == 0 or K % 5 == 0: 
            return -1
        
        r = 0
        for N in range(1, K + 1):
            r = (r * 10 + 1) % K
            if r == 0: 
                return N
```

具体的证明过程需要用到欧拉定理。

reference:

https://leetcode.com/problems/smallest-integer-divisible-by-k/discuss/260852/JavaC%2B%2BPython-Brute-Force-O(K)-Time-O(1)-Space

https://leetcode.com/problems/smallest-integer-divisible-by-k/discuss/260916/Proof%3A-we-only-need-to-consider-the-first-K-candidates-in-1-11-111-1111-...

https://leetcode.com/problems/smallest-integer-divisible-by-k/discuss/260875/Python-O(K)-with-Detailed-Explanations

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**