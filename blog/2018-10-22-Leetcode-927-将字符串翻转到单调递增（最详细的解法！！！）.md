---
layout: post
title: Leetcode 927：将字符串翻转到单调递增（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-10-22 00:00:00
---

如果一个由 `'0'` 和 `'1'` 组成的字符串，是以一些 `'0'`（可能没有 `'0'`）后面跟着一些 `'1'`（也可能没有 `'1'`）的形式组成的，那么该字符串是*单调递增*的。

我们给出一个由字符 `'0'` 和 `'1'` 组成的字符串 `S`，我们可以将任何 `'0'` 翻转为 `'1'` 或者将 `'1'` 翻转为 `'0'`。

返回使 `S` 单调递增的最小翻转次数。

**示例 1：**

```
输入："00110"
输出：1
解释：我们翻转最后一位得到 00111.
```

**示例 2：**

```
输入："010110"
输出：2
解释：我们翻转得到 011111，或者是 000111。
```

**示例 3：**

```
输入："00011000"
输出：2
解释：我们翻转得到 00000000。
```

**提示：**

1. `1 <= S.length <= 20000`
2. `S` 中只包含字符 `'0'` 和 `'1'`

**解题思路**

首先想到的界法师

```python
class Solution:
    def threeEqualParts(self, A):
        """
        :type A: List[int]
        :rtype: List[int]
        """
        i, j, x, y = 0, 2, -1, -1
        while j < len(A):
            l = ''.join(str(i) for i in A[0:i+1])
            m = ''.join(str(i) for i in A[i+1:j])
            r = ''.join(str(i) for i in A[j:])
            if self.theSame(l, m):
                if self.theSame(l, r):
                    x, y = i, j
                    break

            if self.less(l, m):
                i += 1
            else:
                j += 1
            
        return [x, y]

    def less(self, A, B):
        A = A.lstrip('0')
        B = B.lstrip('0')
        if len(A) == len(B):
            return A < B
        else:
            if len(A) > len(B):
                return False
            else:
                return True

    def theSame(self, A, B):
        A = A.lstrip('0')
        B = B.lstrip('0')
        return A == B
```



**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**