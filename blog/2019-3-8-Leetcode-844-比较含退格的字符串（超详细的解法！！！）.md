---
layout: post
title: Leetcode 844：比较含退格的字符串（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-3-8 00:00:00
---

给定 `S` 和 `T` 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 `#` 代表退格字符。

**示例 1：**

```
输入：S = "ab#c", T = "ad#c"
输出：true
解释：S 和 T 都会变成 “ac”。
```

**示例 2：**

```
输入：S = "ab##", T = "c#d#"
输出：true
解释：S 和 T 都会变成 “”。
```

**示例 3：**

```
输入：S = "a##c", T = "#a#c"
输出：true
解释：S 和 T 都会变成 “c”。
```

**示例 4：**

```
输入：S = "a#c", T = "b"
输出：false
解释：S 会变成 “c”，但 T 仍然是 “b”。
```

**提示：**

1. `1 <= S.length <= 200`
2. `1 <= T.length <= 200`
3. `S` 和 `T` 只含有小写字母以及字符 `'#'`。

**解题思路**

这个问题非常简单，我们通过栈模拟上面的操作即可。当我们碰到的字符是`#`的时候，我们弹出栈顶元素，否则的话我们就将元素添加到栈中。最后我们只需要判断记录`S`和`T`的两个栈中的元素是不是一致即可。

```python
class Solution:
    def backspaceCompare(self, S: str, T: str) -> bool:
        s1, s2 = list() ,list()
        def helper(s, st):
            for i in st:
                if i == '#':
                    if s:
                        s.pop()
                else:
                    s.append(i)
        helper(s1, S)
        helper(s2, T)
        return s1 == s2
```

这种做法当然不是最高明的，我们使用了想到`O(n)`的空间复杂度。我们实际上可以空间复杂度更小。

我们可以从后向前遍历，当我们碰到`#`的时候，我们通过变量`back`记录我们回退次数，接着当我们遍历到的元素不是`#`，如果我们之前回退过的话，表示我们现在遍历到的元素就需要删除了，输出多少呢？会退的次数`back`。当我们此时的`back==0`并且碰到的元素也不是`#`，表示我们结束了一轮。我们此时就需要看我们当前的`S`和`T`遍历到的元素是不是一致啊？如果不一致，我们返回`false`，否则的话，我们就需要判断下一个元素是不是一致。最后当两个`S`和`T`都遍历完，我们返回`true`。

```python
class Solution:
    def backspaceCompare(self, S: str, T: str) -> bool:
        i, j = len(S) - 1, len(T) - 1
        backS = backT = 0
        while True:
            while i >= 0 and (backS or S[i] == '#'):
                backS += 1 if S[i] == '#' else -1
                i -= 1
            while j >= 0 and (backT or T[j] == '#'):
                backT += 1 if T[j] == '#' else -1
                j -= 1
            if not (i >= 0 and j >= 0 and S[i] == T[j]):
                return i == j == -1
            i, j = i - 1, j - 1
```

非常棒的想法！！！

reference:

https://leetcode.com/problems/backspace-string-compare/discuss/135603/C%2B%2BJavaPython-O(N)-time-and-O(1)-space

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**