---
layout: post
title: POJ 1017 packets
category : cpp
tags : [cpp, acm, 贪心算法]
stickie: true
---


Description
---

A factory produces products packed in square packets of the same height h and of the sizes 1\*1, 2\*2, 3\*3, 4\*4, 5\*5, 6\*6. These products are always delivered to customers in the square parcels of the same height h as the products have and of the size 6\*6. Because of the expenses it is the interest of the factory as well as of the customer to minimize the number of parcels necessary to deliver the ordered products from the factory to the customer. A good program solving the problem of finding the minimal number of parcels necessary to deliver the given products according to an order would save a lot of money. You are asked to make such a program.

Input
---

The input file consists of several lines specifying orders. Each line specifies one order. Orders are described by six integers separated by one space representing successively the number of packets of individual size from the smallest size 1\*1 to the biggest size 6\*6. The end of the input file is indicated by the line containing six zeros.

Output
---

The output file contains one line for each line in the input file. This line contains the minimal number of parcels into which the order from the corresponding line of the input file can be packed. There is no line in the output file corresponding to the last  line of the input file.

Sample Input
---

0 0 4 0 0 1 
7 5 1 0 0 0 
0 0 0 0 0 0 

Sample Output
---

2 
1

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
int main()
{
	std::vector<int> box(6);
	std::vector<int> result;
	//对于边长为3的板子，只有一块时，需要5个2*2，有两块时，需要3个，有三快时，需要1个，有四块时，需要0个
	std::vector<int> mon{ 0, 5, 3, 1 };
	while (true)
	{
		int sum{};
		for (int i = 0; i < 6; ++i)
		{
			int temp;
			std::cin >> temp;
			box[i] = temp;
			sum += temp;
		}
		if (sum == 0)
		{
			break;
		}
		//如果边长是3 4 5 6
		int ans = box[5] + box[4] + box[3] + (box[2] + 3) / 4;
		//需要边长为2的box数量
		int len_2 = box[3] * 5 + mon[(box[2] % 4)];
		//2*2 box数量剩余时，需要增加box的数量
		if (len_2 < box[1])
		{
			ans += (box[1] - len_2 + 8) / 9;
		}
		//需要边长为1的box数量
		int len_1 = ans * 36 - box[5] * 36 - box[4] * 25 - box[3] * 16 - box[2] * 9 - box[1] * 4;
		if (len_1 < box[0])
		{
			ans += (box[0] - len_1 + 35) / 36;
		}
		result.push_back(ans);
	}
	//容器的最后一行一定是000000	
	std::copy(std::begin(result), std::end(result), std::ostream_iterator<int>(std::cout, "\n"));

}
```
因为平台不兼容C++14，所以我就写了下面这样的做法：

```c++
#include <iostream>
#include <vector>

int main()
{
	std::vector<int> box(6);
	std::vector<int> result;
	//对于边长为3的板子，只有一块时，需要5个2*2，有两块时，需要3个，有三快时，需要1个，有四块时，需要0个
	int mon[4] = { 0, 5, 3, 1};
	while (true)
	{
		int sum = 0;
		for (int i = 0; i < 6; ++i)
		{
			int temp;
			std::cin >> temp;
			box[i] = temp;
			sum += temp;
		}
		if (sum == 0)
		{
			break;
		}
		//如果边长是3 4 5 6
		int ans = box[5] + box[4] + box[3] + (box[2] + 3) / 4;
		//需要边长为2的box数量
		int len_2 = box[3] * 5 + mon[(box[2] % 4)];
		//2*2 box数量剩余时，需要增加box的数量
		if (len_2 < box[1])
		{
			ans += (box[1] - len_2 + 8) / 9;
		}
		//需要边长为1的box数量
		int len_1 = ans * 36 - box[5] * 36 - box[4] * 25 - box[3] * 16 - box[2] * 9 - box[1] * 4;
		if (len_1 < box[0])
		{
			ans += (box[0] - len_1 + 35) / 36;
		}
		result.push_back(ans);
	}
	//容器的最后一行一定是000000	
	for (int i = 0; i < result.size(); ++i)
	{
		std::cout << result[i] << std::endl;
	}
}
```