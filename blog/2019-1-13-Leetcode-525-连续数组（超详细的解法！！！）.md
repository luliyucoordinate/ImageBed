---
layout: post
title: Leetcode 525：连续数组（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-13 00:00:00
---

给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。

**示例 1:**

```
输入: [0,1]
输出: 2
说明: [0, 1] 是具有相同数量0和1的最长连续子数组。
```

**示例 2:**

```
输入: [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。 
```

**注意:** 给定的二进制数组的长度不会超过50000。

**解题思路**

这个问题非常简单，类似于之前的问题[Leetcode 325：Maximum Size Subarray Sum Equals k（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/86421075)，首先想到的思路就是计算累加和。我们知道`1`和`0`个数一样，那么这个数组长度必然是偶数，并且数组的内的所有值的和恰好是数组长度的一半。但是我们在计算的时候出现这样的问题

- $(i-j)/2 = pre\_sum[i]-dic[j]$

我们无法计算出`j`的位置，只有通过暴力的解法（遍历去寻找）。此时一个不错的思路就是将输入数组中的`0`变成`-1`，这样我们只要保证我们的区内的和是`0`即可。这就很简单了，我们可以建立一个字典去存放累加和，然后对后续的累加和`pre_sum[i]`，判断之前`[:i]`区间内有没有相同的累加和`pre_sum[i]`，如果有的话，我们假设为`j`，那么我们就可以判断出`(j,i]`这个区间内的和为`0`。

此时还有一个边界问题需要考虑，也就是这个`j`的问题，当我们的`j==0`是，上面做法就会有问题，所以一个简单的思路就是现在字典中添加一项`{0:1}`或者`{0:-1}`。

```python
class Solution:
    def findMaxLength(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        pre_sum, res = 0, 0
        dic = {0:-1}
        
        for i in range(len(nums)):
            pre_sum += -1 if nums[i] == 0 else 1
            if pre_sum in dic:
                res = max(res, i - dic[pre_sum])
            else:
                dic[pre_sum] = i
                
        return res
```

reference:

https://leetcode.com/problems/contiguous-array/discuss/99646/Easy-Java-O(n)-Solution-PreSum-%2B-HashMap

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**