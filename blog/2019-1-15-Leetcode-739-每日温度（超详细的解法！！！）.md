---
layout: post
title: Leetcode 739：每日温度（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-15 00:00:00
---

根据每日 `气温` 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高的天数。如果之后都不会升高，请输入 `0` 来代替。

例如，给定一个列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的输出应该是 `[1, 1, 4, 2, 1, 1, 0, 0]`。

**提示：**`气温` 列表长度的范围是 `[1, 30000]`。每个气温的值的都是 `[30, 100]` 范围内的整数。

**解题思路**

典型的单调栈问题。关于单调栈的问题，我们之前也碰到过[Leetcode 84：柱状图中最大的矩形（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/85093224)。我们这里的问题就是要找到大于当前元素的第一个元素的位置，所以我们可以先将`temperatures`反转，然后我们通过建立一个**严格单调递减的栈**。如

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/739/2019_1_15_1.png" width="300" hegiht="150">
</center>

首先将`temperatures`反转就变成了`[73, 76, 72, 69, 71, 75, 74, 73]`。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/739/2019_1_15_2.png" width="300" hegiht="150">
</center>

假设我们现在考虑`71`，此时我们的栈中存有`[73,72,69]`。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/739/2019_1_15_3.png" width="300" hegiht="150">
</center>

我们发现`71`大于栈顶元素，所以我们要将`69`出栈，然后将`71`压入。并且我们此时可以知道比`71`大的第一个元素就是`72`，所以此时，我们只需要通过`72.index`减去`71.index`就可以得到结果，最后我们得到所有结果后再将结果反转即可。

```python
class Solution:
    def dailyTemperatures(self, T):
        """
        :type T: List[int]
        :rtype: List[int]
        """
        stack = list()
        T.reverse()
        res = []
        for i, val in enumerate(T):
            while stack and T[stack[-1]] <= val:
                stack.pop()
            if stack:
                res.append(i - stack[-1])
            else:
                res.append(0)
            stack.append(i)
            
        res.reverse()
        return res
```

稍微简化一下代码

```python
class Solution:
    def dailyTemperatures(self, T):
        """
        :type T: List[int]
        :rtype: List[int]
        """
        res = [0] * len(T)
        stack = []
        for i in range(len(T) - 1, -1, -1):
            while stack and T[i] >= T[stack[-1]]:
                stack.pop() 
            if stack:
                res[i] = stack[-1] - i
            stack.append(i)
            
        return res
```

知道这种思路后，我们可以很快的写出更加简洁的做法。我们不需要将`T.reverse()`，而是直接建立一个非严格单调递减的栈，当我们碰到一个元素大于栈顶元素的时候，我们知道此时这个元素一定是离栈顶元素最近的那个最大值的点，我们只要测试记录两者之间的位置距离就好啦。

```python
class Solution:
    def dailyTemperatures(self, T):
        """
        :type T: List[int]
        :rtype: List[int]
        """
        res = [0] * len(T)
        stack = []
        for i, t in enumerate(T):
            while stack and T[stack[-1]] < t:
                cur = stack.pop()
                res[cur] = i - cur
            stack.append(i)

        return res
```

reference:

https://leetcode.com/problems/daily-temperatures/discuss/136017/Elegant-Python-Solution-with-Stack

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**