---
layout: post
title: Leetcode 996：正方形数组的数目（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-2-18 00:00:00
---

给定一个非负整数数组 `A`，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为*正方形*数组。

返回 A 的正方形排列的数目。两个排列 `A1` 和 `A2` 不同的充要条件是存在某个索引 `i`，使得`A1[i] != A2[i]`。 

**示例 1：**

```
输入：[1,17,8]
输出：2
解释：
[1,8,17] 和 [17,8,1] 都是有效的排列。
```

**示例 2：**

```
输入：[2,2,2]
输出：1
```

**提示：**

1. `1 <= A.length <= 12`
2. `0 <= A[i] <= 1e9`

**解题思路**

这个问题和之前的两个问题非常类似，

[Leetcode 46：全排列（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82500364)

[Leetcode 47：全排列 II（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82530270)

我们可以采用之前问题的`swap`思路处理这个问题。（具体思路参看`47`题中的递归写法）

```python
class Solution:
    def numSquarefulPerms(self, A: 'List[int]') -> 'int':
        n = len(A)
        res = 0
        def permute(nums, i):
            nonlocal res
            if i == n:
                res += 1
                return 
            for k in range(i, n):
                if i != k and nums[i] == nums[k]:
                    continue
                nums[i], nums[k] = nums[k], nums[i]
                if i == 0 or int((nums[i] + nums[i-1])**(0.5))**2 == (nums[i] + nums[i-1]):
                    permute(nums.copy(), i+1)
                
        A.sort()
        permute(A, 0)
        return res
```

和之前问题的唯一区别就是我们多了一步，就是判断相邻两数的和是不是平方数，我们这里的写法非常巧妙，我们使用了递归，只要保证`[i]`和`[i-1]`可以构成平方数，也就是保证递归开始的时候条件成立即可。这里还需要注意一个细节，就是我们求开方后需要对结果取整。

还有一些别的解法也都是参考了之前的问题，只是稍加修改了，目前没有看到什么比较有新意的解法。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**