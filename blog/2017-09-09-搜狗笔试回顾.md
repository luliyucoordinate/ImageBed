---
layout: post
title: 搜狗笔试回顾
category : cpp
tags : [cpp, 笔试]
stickie: true
---

一个字符串7个A和7个B组成，满足所有的前缀字符串中的A的个数大于B的个数的个数，问这样的字符串个数有多少个（）它这里的前缀字符串表述的很模糊，我不知道这个前缀指的是什么

要对10w个单词进行前缀匹配检索，那种数据结构最合适：Trie树

没有用栈实现的应用场景：表达式求值

在关键词随机分布的情况下，二叉查找树的查找长度与那些查找相当：二分查找，斐波那契查找

给定一个数组235617849，建立初始堆（最小堆）后，数组序列是多少？125437869

CPU利用率与并发进程数的关系：并发进程的内存访问会增加访存的局部特征，局部性特征的下降会导致缺页率上升和CPU利用率下降，进程数多时，提高并发进程数，可提高CPU利用率。

下面程序的输出结果是：

```c++
class A
{
public:
	virtual char f() { return 'f'; }
	char g(int n) { return 'g'; }
};
class B :public A
{
public:
	char f() { return 'F'; }
protected:
	virtual char g(unsigned int n) { return (char)('g' + n); }
};
int main(void)
{
	A* pA = new B;	
	A& rA = *(B*)pA;	//这里很有意思
	A oA = *(B*)pA;
	printf("%c, %c, %c, %c, %c, %c\n", pA->f(), pA->g(1u), rA.f(), rA.g(1), oA.f(), oA.g(1));
	return 0;
}
```

这道题非常的好，结果很明显是F,g,F,g,f,g，由此题我又想到了一些更加复杂的问题

```c++
B* pB = new B;
A* p = new A;
A* pA = pB;
A* pA2 = (A*)pB;
A& rA = *(B*)pA;
A oA = *(B*)pA;
B* oB = (B*)p;
B* oB2 = (B*)pA;
```
你是否能理解这些对象的内部结构呢？