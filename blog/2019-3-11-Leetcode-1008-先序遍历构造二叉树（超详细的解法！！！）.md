---
layout: post
title: Leetcode 1008：先序遍历构造二叉树（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-3-11 00:00:00
---

返回与给定先序遍历 `preorder` 相匹配的二叉搜索树（binary **search** tree）的根结点。

*(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 < node.val，而 node.right的任何后代，值总 > node.val。此外，先序遍历首先显示节点的值，然后遍历 node.left，接着遍历 node.right。）*

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/1008/1266.png" width="300">
</center>

**示例：**

```
输入：[8,5,1,7,10,12]
输出：[8,5,10,1,7,null,12]
```

**提示：**

1. `1 <= preorder.length <= 100`
2. 先序 `preorder` 中的值是不同的。

**解题思路**

这个问题很简单，我们只需要找到比当前遍历到的元素更大元素的位置`index`，那么我们只需要将`[cur+1:index-1]`的元素放左边，`[index:len(preorder)-1]`的元素放右边。

```python
class Solution:
    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:
        return self._buildTree(0, len(preorder)-1, preorder)
    
    def _buildTree(self, pre_start, pre_end, preorder):
        if pre_start > pre_end:
            return 
        
        root = TreeNode(preorder[pre_start])
        i = pre_start
        
        while i <= pre_end:
            if preorder[i] > preorder[pre_start]:
                break
            i += 1
        
        root.left = self._buildTree(pre_start+1, i-1, preorder)
        root.right = self._buildTree(i, pre_end, preorder)
        return root  
```

我们有一个更`pythonic`的写法

```cpp
class Solution:
    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:
        return self._buildTree(preorder)
    
    def _buildTree(self, preorder):
        if not preorder:
            return 
        
        root = TreeNode(preorder[0])
        i = bisect.bisect(preorder, preorder[0])
        root.left = self._buildTree(preorder[1:i])
        root.right = self._buildTree(preorder[i:])
        return root
```

另一个不错的写法

```python
class Solution:
    i = 0
    def bstFromPreorder(self, A, bound=float('inf')):
        if self.i == len(A) or A[self.i] > bound: 
            return 
        
        root = TreeNode(A[self.i])
        self.i += 1
        root.left = self.bstFromPreorder(A, root.val)
        root.right = self.bstFromPreorder(A, bound)
        return root
```

reference:

https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/discuss/252232/JavaC%2B%2BPython-O(N)-Solution

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**