---
layout: post
title: Leetcode 春季赛：校园自行车分配（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-4-14 00:00:00
---

在由 2D 网格表示的校园里有 `n` 位工人（`worker`）和 `m` 辆自行车（`bike`），`n <= m`。所有工人和自行车的位置都用网格上的 2D 坐标表示。

我们需要为每位工人分配一辆自行车。在所有可用的自行车和工人中，我们选取彼此之间曼哈顿距离最短的工人自行车对  (worker, bike) ，并将其中的自行车分配給工人。如果有多个 (worker, bike) 对之间的曼哈顿距离相同，那么我们选择工人索引最小的那对。类似地，如果有多种不同的分配方法，则选择自行车索引最小的一对。不断重复这一过程，直到所有工人都分配到自行车为止。

给定两点 `p1` 和 `p2` 之间的曼哈顿距离为 `Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|`。

返回长度为 `n` 的向量 `ans`，其中 `a[i]` 是第 `i` 位工人分配到的自行车的索引（从 0 开始）。

**示例 1：**

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/chunji-2/1261_example_1_v2.png" width="300">
</center>

```
输入：workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]]
输出：[1,0]
解释：
工人 1 分配到自行车 0，因为他们最接近且不存在冲突，工人 0 分配到自行车 1 。所以输出是 [1,0]。
```

**示例 2：**

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/chunji-2/1261_example_2_v2.png" width="300">
</center>

```
输入：workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]]
输出：[0,2,1]
解释：
工人 0 首先分配到自行车 0 。工人 1 和工人 2 与自行车 2 距离相同，因此工人 1 分配到自行车 2，工人 2 将分配到自行车 1 。因此输出为 [0,2,1]。
```

**提示：**

1. `0 <= workers[i][j], bikes[i][j] < 1000`
2. 所有工人和自行车的位置都不相同。
3. `1 <= workers.length <= bikes.length <= 1000`

**解题思路**

首先想到的是暴力解法，将所有的`workers`和`bikes`对应的距离都算出来，然后存到一个矩阵中。接着我们直选按照从小到大的方式将矩阵中的取出（存储相应的横纵坐标）。对于取出的值，我们需要将其相应的横纵坐标剔除（表示我们访问过了）。

```python
class Solution:
    def assignBikes(self, workers: List[List[int]], bikes: List[List[int]]) -> List[int]:
        n, m = len(workers), len(bikes)
        def dis(a, b):
            return abs(a[0] - b[0]) + abs(a[1] - b[1])

        mem = [[0]*m for _ in range(n)]
        for i in range(n):
            for j in range(m):
                mem[i][j] = dis(workers[i], bikes[j])
                
        res = [0]*n
        seenx, seeny = set(), set()

        for _ in range(n):
            tmp = float('inf')
            im, jm = 0, 0
            for i in range(n):
                if i in seenx:
                    continue
                for j in range(m):
                    if j in seeny:
                        continue
                    if tmp > mem[i][j]:
                        tmp = mem[i][j]
                        im, jm = i, j

            res[im] = jm
            seenx.add(im)
            seeny.add(jm)
                
        return res
```

但是这种解法超时了。

由于是从小到大取，所以不难想到通过排序优化。我们可以将通过数组存储这样的`(距离,x,y)`结构，然后对其排序。接着对排好序的数据从前往后取，取得过程中同样要剔除相应访问过的横纵坐标。

```python
class Solution:
    def assignBikes(self, workers: List[List[int]], bikes: List[List[int]]) -> List[int]:
        n, m = len(workers), len(bikes)
        def dis(a, b):
            return abs(a[0] - b[0]) + abs(a[1] - b[1])
        
        mem = list()
        for i in range(n):
            for j in range(m):
                mem.append((dis(workers[i], bikes[j]), i, j))
             
        mem.sort()
        res = [0]*n
        seenx, seeny = set(), set()

        for it in mem:
            im, jm = it[1], it[2]
            if im in seenx or jm in seeny:
                continue
            
            res[im] = jm
            seenx.add(im)
            seeny.add(jm)           
                
        return res
```

**如有问题，希望大家指出！！！**