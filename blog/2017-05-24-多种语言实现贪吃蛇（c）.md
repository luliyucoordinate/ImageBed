---
layout: post
title: 多种语言实现贪吃蛇（c）
category : toy
tags : [c, game, 贪吃蛇]
stickie: true
---

```c
/**************************************************************************************************************
**文件:snake.c
**编写者:coordinate
**编写日期:2017_6_2
**简要描述:贪吃蛇游戏
**运行环境:vs2015
**************************************************************************************************************/
#include<stdio.h>
#include <time.h>
#include <conio.h>
#include <Windows.h>

#define length 30 // map length
#define width 30  // map width

//map
int map[length][width] = {0};

//gameover flag
int gameover = 0;

//time status
char status;
int sleepTime = 100;

//food coordiante
int food[2];

//snake struct
typedef struct SNAKE
{
	int x;
	int y;
	struct SNAKE *next;
}snake;

snake *head;	//snake head

void init();
void createMap();
void createSnake();
void makeFood();
void endGame();
int bitself();
void crosswall();
void gameControl();

void init()
{
	for (int i = 0; i < length; ++i)
	{
		for (int j = 0; j < width; ++j)
		{
			if (map[i][j] == 1)
			{
				printf("■");
			}
			else
			{
				printf("  ");
			}			
		}
		printf("\n");
	}	
}

//create map
void createMap()
{
	for (int i = 0; i < length; ++i)
	{
		for (int j = 0; j < width; ++j)
		{
			if (i == 0 || j == 0 || i== length-1 || j == width - 1)
			{
				map[i][j] = 1;
			}
		}
		printf("\n");
	}	
}

//create Snake
void createSnake()
{
	snake *tail;
	int i;
	tail = (snake*)malloc(sizeof(snake));
	tail->x = length / 2;
	tail->y = width / 2;
	tail->next = NULL;
	for (i = 1; i <= 3; i++)
	{
		head = (snake*)malloc(sizeof(snake));
		head->next = tail;
		head->x = length / 2 +  i;
		head->y = width / 2;
		tail = head;
	}
	while (tail != NULL)
	{
		map[tail->x][tail->y] = 1;
		tail = tail->next;
	}
}


//makefood
void makeFood()
{
	srand(time(NULL));
	food[0] = rand() % (length - 2) + 1;
	food[1] = rand() % (width - 2) + 1;
	map[food[0]][food[1]] = 1;
}

//bitself
int bitself()
{
	snake *self;
	self = head->next;
	while (self != NULL)
	{
		if (self->x == head->x && self->y == head->y)
		{
			return 1;
		}
		self = self->next;
	}
	return 0;
}

//cross wall
void crossWall()
{
	if (head->x == 0 || head->x == length - 1 || 
		head->y == 0 || head->y == width - 1)
	{
		endGame();
	}
}


void move(snake * nextthead)
{
	if (nextthead->x == food[0] && nextthead->y == food[1])
	{
		nextthead->next = head;
		head = nextthead;
		snake *q = head;
		while (q ->next!= NULL)
		{
			map[q->x][q->y] = 1;
			q = q->next;
		}
		map[q->x][q->y] = 0;
		makeFood();
	}
	else
	{
		nextthead->next = head;
		head = nextthead;
		snake *q = head;
		while (q->next->next != NULL)
		{
			map[q->x][q->y] = 1;
			q = q->next;
		}
		map[q->next->x][q->next->y] = 0;
		free(q->next);
		q->next = NULL;
		map[q->x][q->y] = 0;
	}
	if (bitself())
	{
		endGame();
	}
}
//snake move
void  snakeMove()
{
	snake *nextthead;
	crosswall();

	nextthead = (snake *)malloc(sizeof(snake));

	switch (status)
	{
	case 'w':
		nextthead->x = head->x - 1;
		nextthead->y = head->y;
		move(nextthead);
		break;
	case 'a':
		nextthead->x = head->x;
		nextthead->y = head->y - 1;
		move(nextthead);
		break;
	case 's':
		nextthead->x = head->x + 1;
		nextthead->y = head->y;
		move(nextthead);
		break;
	case 'd':
		nextthead->x = head->x;
		nextthead->y = head->y + 1;
		move(nextthead);
		break;
	default:
		nextthead->x = head->x + 1;
		nextthead->y = head->y;
		move(nextthead);
		break;
	}	
}

//cntrol game
void gameControl()
{
	char key = NULL;
	if (_kbhit())
	{
		key = _getch();
	}
	switch (key)
	{
	case 'w':	//up
		status = 'w';
		break;
	case 'a':	//left
		status = 'a';
		break;
	case 's':	//down
		status = 's';
		break;
	case 'd':	//right
		status = 'd';
		break;
	}
}


//end game
void endGame()
{
	system("cls");
	printf("Game Over");
	system("pause");
}

//main function
int main()
{
	createMap();
	createSnake();
	makeFood();
	init();
	while (1)
	{
		gameControl();
		snakeMove();
		Sleep(200);
		system("cls");
		init();
	}
	return 0;
}
```
