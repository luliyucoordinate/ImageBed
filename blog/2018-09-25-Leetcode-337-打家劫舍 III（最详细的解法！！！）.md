---
layout: post
title: Leetcode 337：打家劫舍 III（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-09-25 00:00:00
---

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

**示例 1:**

```
输入: [3,2,3,null,3,null,1]

     3-
    / \
   2   3
    \   \ 
     3-  1-

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
```

**示例 2:**

```
输入: [3,4,5,1,3,null,1]

     3
    / \
   4-  5-
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
```

**解题思路**

这是之前问题[Leetcode 198：打家劫舍（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82829381) 和[ Leetcode 213：打家劫舍 II（最详细的解法！！！） ](https://blog.csdn.net/qq_17550379/article/details/82834450)的拓展。

思路和之前一样，我们遍历整棵二分搜索树，对于每个节点，我们都需要判断这个节点的值我们需不需要取。例如

```
     3<-
    / \
   2   3
    \   \ 
     3   1
```

如果我们取`3`，那么`3.left and 3.right`我们都不能取了；如果我们不取，那么最大值来自于左右孩子的和，也就是`3.left+3.right`，但是对于左右孩子来说又涉及到了上面的问题，我们是取还是不取呢？这样循环递推下去，知道节点为`null`，我们直接返回`0`即可。那么我们对于每个节点，都要设计一个结构来描述取和不取这样的操作，使用`list`即可，`list[0]`表示取，而`list[1]`表示不取。

我们定义`root`的左右孩子为`l & r`，左孩子`l`的左右孩子为`ll & lr`，右孩子`r`的左右孩子为`rl & rr`。那么我们可以写出这样的方程

```
result = max(root.val + f(ll) + f(lr) + f(rl) + f(rr), f(l) + f(r))
f = max(rob, norob)
```

我们可以很快速的写出下面代码

```python
class Solution:
    def rob(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        check = self._rob(root)
        return max(check[0], check[1])

    def _rob(self, root):
        if not root:
            return [0, 0]

        l, r = self._rob(root.left), self._rob(root.right)
        return l[1] + r[1] + root.val, max(l) + max(r)
```

但是这个代码依旧有优化的空间，我们可以通过**记忆化搜索**的方法继续优化这个代码。但是我们怎么记忆各个节点的访问情况呢？之前的问题都是`list`，所以我们可以通过`index`来建立搜索列表。对于这个问题我们有一个小技巧就是通过`l & r`表示左右，例如`lll`表示左子树的左子树的左子树。

```python
class Solution:
    def rob(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        mem = dict()
        check = self._rob(root, "", mem)
        return max(check[0], check[1])

    def _rob(self, root, path, mem):
        if not root:
            return [0, 0]

        if path in mem:
            return mem[path]

        l, r = self._rob(root.left, path + 'l', mem), self._rob(root.right, path + 'r', mem)
        mem[path] = l[1] + r[1] + root.val, max(l) + max(r)
        return mem[path]
```

我们怎么通过迭代解决这个问题呢？实际上这个问题变成了我们怎么去遍历一颗二叉树，怎么做呢？

[ Leetcode 144:二叉树的前序遍历（最优雅的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/80731041) 

[Leetcode 94:二叉树的中序遍历（最优雅的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/80809930) 

[Leetcode 145:二叉树的后序遍历（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/81044345) 

我这里通过前序遍历解决这个问题

```python
class Solution:
    def rob(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        stack = [(0, root)]
        result = {None: (0, 0)}
        while stack:
            rob, node = stack.pop()
            if not node:
                continue
                
            if not rob:
                stack.extend([(1, node), (0, node.right), (0, node.left)])
            else:
                result[node] = (result[node.left][1] + result[node.right][1] + node.val,\
                               max(result[node.left]) + max(result[node.right]))
        return max(result[root])
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**