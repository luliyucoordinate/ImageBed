---
layout: post
title: 复杂数据类型的机器级表示（1）
category : 计算机系统原理
tags : [notes, 原理]
stickie: true
---


数组和指针类型的分配和访问
===
例如，定义一个具有4个元素的静态存储型short数据类型数组A，可以写成“static short [A];”第i个元素的地址计算公式为$$\&A[0]+2*i$$。  
假定数组A的首地址存放在EDX中，i存放在ECX中，现要将A[I]取到AX中，则所用的汇编指令：

```
movw (%edx,%ecx,2),%eax
```
其中ECX为变址寄存器，在循环中增量  

分配在静态区的数组的初始化和访问

```c
int buf[2] = {10,20};
int main()
{
	int i,sum = 0;
	for(i = 0; i < 2; ++i)
	{
		sum += buf[i];
	}
	return sum;
}
```
buf是在静态区分配的数组，连接后，buf在可执行目标文件的数据段中分配空间  

auto型数组的初始化和访问

```c
int adder()
{
	int buf[2] = {10,20};
	int i,sum = 0;
	for(i = 0; i <2;++i)
	{
		sum += buf[i];
	}
	return sum;
}
```
分配在栈中，故数组首地址通过EBP来定位。  

在指针的目标数据与数组类型相同的前提下，指针变量可以指向数组或数组中的任意元素。

```c
int a[10];
int *ptr = &a[0];
```
这个程序的功能就是使ptr指向数组啊的第0个元素a[0]。a的值就是其首地址，即a=&a[0]，因而a=ptr，从而有$$\&a[i] = ptr+i=a+i$$以及$$a[i]=ptr[i]=*(ptr+i)=*(a+i)$$  

结构和联合数据
===

结构体数据的分配和访问
---
结构体成员在内存中主要分为：分配在栈中的auto结构性变量的首地址由EBP或ESP来定位，分配在静态区的结构型变量首地址是一个确定的静态区地址。结构性变量x各成员首地址可用“基址加偏移量”的寻址方式

```c
struct cont_info
{
	char id[8];
	char name[12];
	unsigned post;
	char address[100];
	char phone[20];
}
unsigned xpost = x.post;//movl 20(%edx),%eax偏移量是20
```
结构体数据作为入口参数

```c
void stu_phone1(struct cont_info *s_info_ptr)
{
	printf("%s phone number: %s", (*s_info_ptr).name, (*s_info_ptr).phone);
}
void stu_phone2(struct cont_info s_info)
{
	printf("%s phone number: %s", s_info.name, s_info.phone);
}
```
结构体变量需要作为一个函数参数时，形参和调用函数中的实参具有相同结构。若采用按值传递，则结构成员都要复制到栈中的参数区，这既增加时间又增加空间，且更新后数据无法在调用中使用。  

(*stu_info_ptr).name可写为stu_info_ptr->name  

![1.png](http://wx4.sinaimg.cn/mw690/af2d2659gy1ffpusncsqyj20c30ez76r.jpg)


执行以下两条指令后

```
movl 8(%ebp),%edx
leal 8(%edx),%eax
```
EAX中存放的是字符串  

stu_info.name送EAX的指令序列为：

```
leal 8(%ebp),%edx
leal 8(%edx),%eax
```

![2.png](http://wx3.sinaimg.cn/mw690/af2d2659gy1ffpuso2mx7j20cj0f3dj1.jpg)


很明显第二种做法开销很大

联合体数据的分配和访问
---
联合体各成员共享存储空间，按最大长度成员所需空间大小为准

```c
union_uarea
{
	char c_data;
	short s_data;
	int i_data;
	long l_data;
}
```
在IA-32中占用4个字节。当事先知道某种数据结构中的不同字段的使用时间是互斥的，就可以将这些字段声明为union，以减少空间。  

实现对相同序列的不同数据类型解释  

```c
unsigned 
float2unsign(float f)
{
	union 
	{
		float f;
		unsigned u;
	}tmp_union;
	tmp_union.f = f;
	return tmp_union.u;
}
```
过程体为：

```
movl 8(%ebp),%eax
movl %eax,-4(%ebp)
movl -4(%ebp),%eax
```
最后两条指令会被优化掉  
结果就是float转化为unsigned但是没有使用内部装换所以，float2unsign(10.0)=1092616192  

利用嵌套定义链表结构

```c
union node
{
	struct 
	{
		int *pre;
		int data1;
	}node1;
	struct 
	{
		int data2;
		union node *next;
	}node2;
}
void node_proc( union node *np)
{
	np->node2.next->node1.data1=*(np->node2.next->node1.ptr)+np->node2.data2;
}
```

![3.png](http://wx1.sinaimg.cn/mw690/af2d2659gy1ffpusoj83aj20ab0fcabs.jpg)

```
movl 8(%ebp),%ecx
movl 4(%ecx),%edx
movl (%edx),%eax
movl (%eax),%eax
addl (%ecx),%eax
movl %eax,4(%edx)

```