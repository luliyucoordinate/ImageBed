---
layout: post
title: Leetcode 1:两数之和（最详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-05-09 00:00:00
---

给定一个整数数组和一个目标值，找出数组中和为目标值的**两个**数。

你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。

**示例:**


    给定 nums = [2, 7, 11, 15], target = 9
    
    因为 nums[0] + nums[1] = 2 + 7 = 9
    所以返回 [0, 1]

**解题思路**

首先想到的解决思路是通过两次循环，每次循环遍历列表，这种算法的时间复杂度是`O(n^2)`。

```python
class Solution:
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        len_nums = len(nums)
        for i in range(len_nums):
            for j in range(i + 1, len_nums):
                if nums[i] + nums[j] == target:
                    return [i, j]
        return []
```

直接忽略这种解法。

我们接着会想到的做法就是，我们可以每次判断`target-num[i]`对应的值是否在`num[i+1:]`中。但是这里我们要注意一个问题，如果列表中有相同的元素，例如`[3, 3]`， 我们对应的`target=6`，这个时候我们在使用`list.index`的时候要注意`index`返回的是第一个值的位置，我们应该使用`list[i + 1].index + i + 1`。

```python
class Solution:
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        len_nums = len(nums)
        for i in range(len_nums):
            dif = target - nums[i]         
            if dif in nums[i+1:]: 
                dif_index = nums[i + 1:].index(dif)+i+1
                return [i, dif_index]
        return []
```

上面做法虽然比第一种快，但是依旧不是最好的。我们思考一下，我们这种做法的问题有哪些，我们这里只用一次循环，但是循环中我们有查找操作（如果每次查找都是最差情况，那么我们要花`O(n)`的时间复杂度），并且查找索引的时候我们使用了`index`函数和切片操作，这些都是非常消耗时间的，那么我们有什么更加优秀的做法呢？

我们可以每次从`nums[:i]`中去查找是否有`target - nums[i]`。这种做法就避免了上述问题中的查找最差的情况（`num_c`是从空列表开始的）

```python
class Solution:
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        nums_len = len(nums)
        for i in range(nums_len):
            dif = target - nums[i]
            if dif in nums[:i]: 
                return [nums.index(dif), i]
        return []
```

我们分析这里存在的问题，我们现在的问题就只存在在`list`这个结构上了，因为我们无法再优化`index`和切片操作，那么有没有更加适合这个问题的数据结构呢?

我们就想到了哈希表这个结构，我们知道在python里面的`map`内部实现就是通过哈希表。我们可以通过哈希表来存储`nums[:i]`。关于哈希表的相关知识，大家可以看这篇[Hash表的理论基础与具体实现（详细教程）](https://blog.csdn.net/qq_17550379/article/details/80302217) 

```python
class Solution:
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        nums_hash = {}
        nums_len = len(nums)
        for i in range(nums_len):
            dif = target - nums[i]
            if dif in nums_hash: 
                return [nums_hash[dif], i]
            nums_hash[nums[i]] = i
        return []
```

我们知道在`c++`中，`unordered_map`可以当作哈希表来使用，所以我在这里同时给出对应的`c++`版本。

```c++
class Solution
{
public:
    vector<int> twoSum(vector<int>& nums, int target) 
    {
        unordered_map<int, int> m;
        for (int i = 0; i < nums.size(); ++i)
        {
            if (m.count(target - nums[i]))
            {
                return {m[target - nums[i]], i};
            }
            m[nums[i]] = i;
        }
        return {};
    }
};
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**