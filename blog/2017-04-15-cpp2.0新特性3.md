---
layout: post
title: cpp2.0新特性(3)
category : cpp
tags : [cpp, cpp第二版]
stickie: true
---


Rvalue references
===

Rvalue references are a new reference type introduced in C++0x that help solve the problem of unnecessary copying and enable perfect forwarding.When the right-hand side of an assignment is an rvalue, then the left-hand side object can steal resources from the right-hand side object rather than performing a separate allocation ,thus enabling move semantics  
Lvalue:可以出现operator=左侧  
Rvalue:只能出现operator=右侧  
做以下测试：

```c++
string s1("hello ");
string s2("world");
s1 + s2 = s2; //竟然通过了编译
string() = "world";//竟然可以对temp object赋值
cout << s1 << endl;
cout << s2 << endl;
cout << s1 + s2 << endl;
```
结果为：

```c++
hello
world
hello world
```
这个是标准库设计上的不合理，temp object是一个Rvalue  
C++ with its user-defined types has introduced some subtleties regarding modifiability and assignability that cause this definition to be incorrect

```c++
int foo(){ return 5; }
...
int x = foo();
int *p = &foo(); //ERROR 表达式必须为左值
foo() = 7; //ERROR 表达式必须是可修改的左值
```
函数的返回值是一个Rvalue，对Rvalue取reference是不可以的


Unperfect Forwarding
---

```c++
void process(int& i)
{
	cout << "process" << i << endl;
}
void process(int&& i)
{
	cout << "process(int&&):" << i << endl;
}
void forward(int &&i)
{
	cout << "forward(int &&):" << i << endl;
	process(i);
}
int a = 0;
process(a);//process(int&):0
process(1);//process(int&&):1
process(move(a));//process(int&&):0
forward(2);//forward(int&&):2,process(int&):2
//rvalue经过forward()传给另一个函数却变为lvalue
//原因在于传递的过程中它变成了一个named object
forward(move(a));//forward(int&&):0,process(int&):0
//rvalue经过forward()传给另一个函数却变为rvalue
```


Perfect Forwarding
---

Perfect forwarding allows you to write a single function template that takes n arbitrary arguments and forwards them transparently to another arbitrary function.The nature of the argument(modifiable,const ,lvalue or rvalue) is preserved in this forwarding process.

```c++
template<typename T1,typename T2>
void functionA(T1&& t1, T2&& t2)
{
	functionB(std::forward<T1>(t1),
				std::forward<T2>(t2));
}
```


String Literal
===

Raw String Literal
---

例如一个用来表示两个反斜杠和一个n的寻常字面常量可定义如下：

```
“\\\\n”
```
也可以定义为raw string literal

```
R”(\\n)”
```
如果要在raw string内写出)”，可以使用定义符。因此，一个raw string的完整语法是R”delim()delim”,其中delim是字符序列，最多16个基本字符，不包含反斜线、空格和小括号。举个例子：

```
R”nc(a\
    b\nc()”
)nc”
```
等同于

```
“a\\\n    b\\nc()\”\n    ”
```


Encoded String Literal
---

u8定义一个UTF-8编码。  
u定义一个string lteral，带着char16_t的字符  
U定义一个string lteral，带着char32_t的字符  
L定义一个wide string lteral，带着wchar_t的字符


New Fundamental Data Type
===

char16_t 和 char32_t
long long 和unsigned long long
std::nullptr_t


Scoped Enumerration
===

一般情况下，在花括号中声明一个name（包括变量名，函数名），这个name的可见性会被限制在花括号的作用域内。对于在C++98风格的enum中声明的enum成员却不是这样。这些enum成员的name属于的作用域是enum所在作用域，这意味着在这个作用域中，不能拥有相同的name:

```c++
enum Color { black, white, red };   //black，white，red
                                    //和Color在同一个作用域
auto white = false;                 //错误！white在这个
                                    //作用域已经声明过了
```
所以事实上，这些enum成员name泄露到enum所在的作用域中去了，这导致官方对于这种enum给出了一个官方术语：unscoped。新的C++11中有一个与此相对应的版本：scoped enum，不会像这样让name泄露：

```c++
enum class Color { black, white, red }; //black，white red
                                        //在Color作用域中
auto white = false;                     //好的，没其他white
Color c = white;                        //错误！在这个作用域中没有
                                        //一个叫“white”的enum成员
Color c = Color::white;                 //对的
auto c = Color::white;                  //也是对的（而且和Item 5的建议一样）
```
再举个例子：

```c++
enum class Salutation : char { mr, ms co};
```
你可以明显定义底层类型（本例是char）并因此获得一个保证大小（如果你这里省略了char，则默认是int）。


Member Template 
===

Member template的一个特殊形式时template构造函数。这个函数通常被提供用于“对象被复制时给予隐式类型转换”的能力。

```c++
template<typename T>
class MyClass 
{
//copy constructor with inmplicit type conversion
//-ddoes not supperss implicit copy constructor
	template<typename U>
	MyClass ( const MyClass<U>& x);
	...
};
void f()
{
	MyClass<double> xd;
	MyClass<double> xd2(xd);
	MyClass<int> xi(xd);
}
```
这里xd2与xd类型完全相同，因此其初始化是通过被隐式生成的copy构造函数完成。xi的类型与xd不同，因此其初始化是通过template构造函数完成的。

Explicit Initialization for Fundamental Type
===

如果你使用一个明确的构造函数，但不给实参这样的语法，基础类型会被设定初值为0：

```c++
int i1;//undefined value
int i2 = int();//initialized with zero
int i3{};//initialized with zero
std::pair<int,float> p;//initialize p.first and p.second with zero
```



