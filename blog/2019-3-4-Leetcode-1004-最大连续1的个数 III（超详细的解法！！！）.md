---
layout: post
title: Leetcode 1004：最大连续1的个数 III（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-3-4 00:00:00
---

给定一个由若干 `0` 和 `1` 组成的数组 `A`，我们最多可以将 `K` 个值从 0 变成 1 。

返回仅包含 1 的最长（连续）子数组的长度。 

**示例 1：**

```
输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释： 
[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
```

**示例 2：**

```
输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。 
```

**提示：**

1. `1 <= A.length <= 20000`
2. `0 <= K <= A.length`
3. `A[i]` 为 `0` 或 `1` 

**解题思路**

这个问题非常简单，就是滑动窗口法。我们建立一个滑动窗口`[l,r]`，其中维护`K`个`0`，我们移动滑动窗口的时候只需要记录滑动窗口的最大宽度即可。

当我们移动滑动窗口的时候`0`的个数超过`K`要怎么办？此时我们只需要移动`l+=1`将窗口中的`0`的个数继续维持在`K`就好啦。

```python
class Solution:
    def longestOnes(self, A: List[int], K: int) -> int:
        n = len(A)
        zeros, l, res = 0, 0, 0
        for r in range(n):
            zeros += 1 - A[r]
            while zeros > K:
                zeros -= 1 - A[r]
                l += 1
            res = max(res, r - l + 1)
        return res
```

这里还有一个`trick`，我们其实不需要缩减窗口的大小。例如当我们判断最大的窗口是`[5,9]`的时候，我们其实不需要判断`[6,9]`了，我们只需要从`[6,10]`开始就好啦。

```python
class Solution:
    def longestOnes(self, A: List[int], K: int) -> int:
        n = len(A)
        zeros = res = l = 0
        for r in range(n):
            zeros += 1 - A[r]
            if zeros > K:
                zeros -= 1 - A[l]
                l += 1
            res = r - l + 1
        return res
```

reference:

https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/JavaC%2B%2BPython-Sliding-Window

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**