---
layout: post
title: Leetcode 257：二叉树的所有路径（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-08-28 00:00:00
---

给定一个二叉树，返回所有从根节点到叶子节点的路径。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**

```
输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```

**解题思路**

这个问题和之前的[Leetcode 112：路径总和（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82115520)有点像。如果之前问题会的话，这个问题应该就不会有问题。当`node.left==None and node.right==None`的时候，`node`就是`叶子节点`。然后我们还要考虑初始条件为空`root==None`的情况。

```python
class Solution:
    def binaryTreePaths(self, root):
        """
        :type root: TreeNode
        :rtype: List[str]
        """
        result = list()
        if root == None:
            return result

        if root.left == None and root.right == None:
            result.append(str(root.val))
            return result

        left = self.binaryTreePaths(root.left)
        for i in range(len(left)):
            result.append(str(root.val) + '->' + left[i])

        right = self.binaryTreePaths(root.right)
        for i in range(len(right)):
            result.append(str(root.val) + '->' + right[i])

        return result
```

我们看看怎么使用迭代来解决这个问题。

```python
class Solution:
    def binaryTreePaths(self, root):
        """
        :type root: TreeNode
        :rtype: List[str]
        """
        result = list()
        stack = [(root, '')]
        while stack:
            node, p = stack.pop()
            if node:
                if not (node.left or node.right):
                    result.append(p + str(node.val))

                stack += [(node.left, p+str(node.val)+'->'), (node.right, p+str(node.val)+'->')]
                
        return result
```

和之前问题的解法基本上是一样的。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**

