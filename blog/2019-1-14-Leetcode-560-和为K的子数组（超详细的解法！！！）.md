---
layout: post
title: Leetcode 560：和为K的子数组（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-14 00:00:00
---

给定一个整数数组和一个整数 **k，**你需要找到该数组中和为 **k** 的连续的子数组的个数。

**示例 1 :**

```
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```

**说明 :**

1. 数组的长度为 [1, 20,000]。
2. 数组中元素的范围是 [-1000, 1000] ，且整数 **k** 的范围是 [-1e7, 1e7]。

**解题思路**

这个问题和之前的问题[Leetcode 525：连续数组（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/86472802)很类似，但是我觉得这个问题比之前的问题还要简单。我们这里直接通过计算累加和，通过字典记录所有累加和和其**出现的次数**，然后判断`pre_sum-k`的值是不是字典中，如果在的话，我们只需要在结果上加上对应累加和出现的次数即可。

我们接着思考边界问题，也就是`pre_sum==k`的时候，此时一个好的处理办法就是在初始化`dict`的时候，添加`{0:1}`。 

```python
class Solution:
    def subarraySum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        res, pre_sum = 0, 0
        sum_dict = {0:1}
        
        for num in nums:
            pre_sum += num
            if pre_sum - k in sum_dict:
                res += sum_dict[pre_sum - k]
            dic[pre_sum] = dic.get(pre_sum, 0) + 1
                
        return res
```

这个问题应该说和之前的问题没有任何变化，还是要找到对称点（也就是字典中到底要记录什么），我们这里的对称点是`pre_sum-k`，而之前问题的对称点是`pre_sum`。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**