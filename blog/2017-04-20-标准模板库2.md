---
layout: post
title: 标准模板库(2)
category : cpp
tags : [cpp, notes, cpp标准库]
stickie: true
---

更易型算法(Manipulating Algorithm)
===
现实中存在某些限制和某些需要避开的事物，其中许多和元素/容器的改动相伴相生。有些算法会改变目标的区间。

移除(Removing)元素
---
分析这个例子：

```c++
#include <algorithm>
#include <iterator>
#include <list>
#include <iostream>
using namespace std;
int main()
{
    list<int> coll;
    // insert elements from 6 to 1 and 1 to 6
    for (int i=1; i<=6; ++i) {
        coll.push_front(i);
        coll.push_back(i);
    }
    // print all elements of the collection
    cout << "pre:  ";
    copy (coll.cbegin(), coll.cend(),         // source
          ostream_iterator<int>(cout," "));   // destination
    cout << endl;
    // remove all elements with value 3
    remove (coll.begin(), coll.end(),         // range
            3);                               // value
    // print all elements of the collection
    cout << "post: ";
    copy (coll.cbegin(), coll.cend(),         // source
          ostream_iterator<int>(cout," "));   // destination
    cout << endl;
}
```
注意这个程序的结果和我们预想的不一样：

```c++
pre:  6 5 4 3 2 1 1 2 3 4 5 6
post: 6 5 4 2 1 1 2 4 5 6 5 6
```
remove并没有改变集合中的元素数量。cend返回的是当初那个终点，size()返回的还是当初那个大小。  
事实上，这个算法返回一个新终点。你可以利用这个新终点获得新区间。改进版本：

```c++
#include <algorithm>
#include <iterator>
#include <list>
#include <iostream>
using namespace std;

int main()
{
    list<int> coll;

    // insert elements from 6 to 1 and 1 to 6
    for (int i=1; i<=6; ++i) {
        coll.push_front(i);
        coll.push_back(i);
    }

    // print all elements of the collection
    copy (coll.cbegin(), coll.cend(),
          ostream_iterator<int>(cout," "));
    cout << endl;

    // remove all elements with value 3
    // - retain new end
    list<int>::iterator end = remove (coll.begin(), coll.end(),
                                      3);

    // print resulting elements of the collection
    copy (coll.begin(), end,
          ostream_iterator<int>(cout," "));
    cout << endl;

    // print number of removed elements
    cout << "number of removed elements: "
         << distance(end,coll.end()) << endl;

    // remove "removed" elements
    coll.erase (end, coll.end());

    // print all elements of the modified collection
    copy (coll.cbegin(), coll.cend(),
          ostream_iterator<int>(cout," "));
    cout << endl;
}
```
如果真想把那些删除的元素斩草除根，erase正适用于此目的。  
为什么算法不自己调用erase呢？这正是STL为了获取弹性付出的代价。通过“以迭代器为接口”，STL将数据结构和算法分离出来。任何“以迭代器访问容器”的算法，都不得通过迭代器调用容器类所提供的任何成员函数。  
算法的操作对象不一定是“容器内的全部元素”所形成的区间，而可以使那些元素的子集。  
注意，通常并无必要删除那些“已被删除”的元素。以逻辑终点取代容器的实际终点，通常就足以应对现实情况。

更易Associative(关联式)和Unordered(无序)容器
---
更易型算法(指那些会移除，重排，修改元素的算法)若用于关联式容器或无序容器，会出问题。如果更易型算法用于关联式和无序容器身上，会改变某位置上的值，进而破会容器本身对次序的维护。  
关联式容器和无序容器的所有迭代器均被申明为指向常量的value或key，如果你更动关联式容器或无序容器的元素会导致编译出错。

算法VS成员函数
---
如果高效能是你的首要目标，你应该总是优先选用成员函数。

以函数作为算法的实参
===
有些算法可以接受用户自定义的辅助函数，提高弹性和能力。

判断式(Predicate)
---
Predicate是一种特殊的辅助函数。所谓的predicate，它会返回布尔值。  
单参数判断式(Unary Predicate)会检查唯一实参的某项特性。  
双参判断式(Binary Predicate)  
Binary Predicate的典型用途是，比较两个实参的特定属性。

使用Lambda
===
可以定义对象，用于描述函数行为，并将这些对象以“inline实参”形式给算法作为predicate。

函数对象(Function Object)
===
定义一个函数对象
---
函数对象是一种带状态的函数。事实上，在同一时间点，相同类型的两个不同的函数对象所表述的相同机能，可具备不同状态。这是寻常函数中不可能的。另一个好处是，你可以在运行期初始化他们—当然必须在他们被调用之前。  
每个函数对象有其自己的类型。寻常函数，唯有在其signature不同时，才算类型不同。而函数对象即使signature相同，也可以有不同的类型。  
函数对象通常比寻常函数速度快。由于更多细节在编译器就已确定，所以通常可能进行更好的优化。

预定义的函数对象
---
C++标准库内含若干预定义的函数对象，含盖了许多基础运算。一个典型的例子是作为基础排序的函数对象。operator < 默认排序准则是调用less<>，所以，如果你声明：

```c++
set<int> coll;
```
会被扩展为

```c++
ser<int,less<int>> coll;
```

binder
---
你可以使用特殊的函数适配器，所谓的binder，将于定义的函数对象和其他数值结合为一体。

```c++
#include <set>
#include <deque>
#include <algorithm>
#include <iterator>
#include <functional>
#include <iostream>
#include "print.hpp"
using namespace std;
using namespace std::placeholders;

int main()
{
    set<int,greater<int>> coll1 = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    deque<int> coll2;

    // Note: due to the sorting criterion greater<>() elements have reverse order:
    PRINT_ELEMENTS(coll1,"initialized: ");

    // transform all elements into coll2 by multiplying them with 10
    transform (coll1.cbegin(),coll1.cend(),      // source
               back_inserter(coll2),             // destination
               bind(multiplies<int>(),_1,10));   // operation
    PRINT_ELEMENTS(coll2,"transformed: ");

    // replace value equal to 70 with 42
    replace_if (coll2.begin(),coll2.end(),       // range
                bind(equal_to<int>(),_1,70),     // replace criterion
                42);                             // new value
    PRINT_ELEMENTS(coll2,"replaced:    ");

    // remove all elements with values between 50 and 80
    coll2.erase(remove_if(coll2.begin(),coll2.end(),
                          bind(logical_and<bool>(),
                               bind(greater_equal<int>(),_1,50),
                               bind(less_equal<int>(),_1,80))),
                coll2.end());
    PRINT_ELEMENTS(coll2,"removed:     ");
}
```
通过指定：

```c++
bind(multiplies<int>(),_1,10)
```
变定义一个函数对象，将传入的第一个实参乘以10。  
最后一例用的是binder的组合：

```c++
bind(logical_and<bool>(),
     bind(greater_equal<int>(),_1,50),
     bind(less_equal<int>(),_1,80))
```
表现出的是个unary predicate，拥有参数x，操作意义是x>=50&&x<=80。

STL内部的错误和异常
===
错误处理(Error Handling)
---
C++标准库指出，对于STL的任何运用，如果违反规则，将导致不明确的行为。通常会导致不明确的内存访问，这肯能导致难缠的副作用。具体地说，使用STL，必须满足以下条件：  
迭代器必须合法有效。例如你必须在使用他们之前先将他们初始化。  
迭代器如果指向past-the-end位置，它并不指向任何对象。因此不能对他调用operator*和operator->。  
区间(range)必须合法：  
用以“指出某个区间”的前后迭代器必须指向同一个容器。  
从第一个迭代器出发必须可以到达第二个迭代器位置。  
如果涉及的区间不止一个，第二区间及后继各区间必须拥有“至少和第一区间一样多的”元素。  
腹泻操作中的“标的区间”必须拥有足够多的元素，否则必须采用insert iterator  
以下例子展示若干可能发生的错误：

```c++
#include <vector>
#include <algorithm>
using namespace std;
int main()
{
    vector<int> coll1;    // empty collection
    vector<int> coll2;    // empty collection

    // RUNTIME ERROR:
    // - beginning is behind the end of the range
    vector<int>::iterator pos = coll1.begin();
    reverse (++pos, coll1.end());

    // insert elements from 1 to 9 into coll1
    for (int i=1; i<=9; ++i) {
        coll1.push_back (i);
    }

    // RUNTIME ERROR:
    // - overwriting nonexisting elements
    copy (coll1.cbegin(), coll1.cend(),  // source
          coll2.begin());                // destination

    // RUNTIME ERROR:
    // - collections mistaken
    // - cbegin() and cend() refer to different collections
    copy (coll1.cbegin(), coll2.cend(),  // source
          coll1.end());                  // destination
}
```
