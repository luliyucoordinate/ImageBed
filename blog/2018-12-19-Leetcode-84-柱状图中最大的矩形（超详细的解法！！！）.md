---
layout: post
title: Leetcode 84：柱状图中最大的矩形（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-12-19 00:00:00
---

求在该柱状图中，能够勾勒出来的矩形的最大面积。

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2018/10/12/histogram.png" width="200" hegiht="150">
</center>


以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 `[2,1,5,6,2,3]`。

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png" width="200" hegiht="150">
</center>


图中阴影部分为所能勾勒出的最大矩形面积，其面积为 `10` 个单位。

**示例:**

```
输入: [2,1,5,6,2,3]
输出: 10
```

**解题思路**

这个问题非常有意思。我们首先可以想到的是暴力破解，我们通过`i`不断遍历`heights`，然后在遍历的过程中通过`j`不断向后寻找最大矩形。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/84/2018_12_19_1.png" width="200" hegiht="150">
</center>

例如，我们把`i`从`1`开始遍历，`j`在`[i,len(heights)]`区间遍历。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/84/2018_12_19_2.png" width="200" hegiht="150">
</center>

接着我们`i`从`2`开始遍历，`j`在`[i,len(heights)]`区间遍历。


```python
class Solution:
    def largestRectangleArea(self, heights):
        """
        :type heights: List[int]
        :rtype: int
        """
        if not heights:
            return 0
        heights_len = len(heights)
        res = 0
        i, j = 0, 0
        while i < heights_len:
            min_h = heights[i]
            for j in range(i, heights_len):              
                min_h = min(min_h, heights[j])
                res = max(res, min_h*(j - i + 1))
            i += 1
                
        return res
```

这种解法显然很慢，我们有一种更好的思路就是通过递增栈。所谓的**递增栈**，就是栈中只存放递增序列。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/84/2018_12_19_3.png" width="200" hegiht="150">
</center>

我们首先将`2`加入到栈中，我们接着访问`1`，我们发现`1`比栈顶元素`2`小，所以我们将栈顶元素`2`弹出，并且记录此时的面积`2`。我们发现栈已经空了，所以我们要接着压栈。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/84/2018_12_19_4.png" width="200" hegiht="150">
</center>

接着我们通过不断遍历找到第二个递增栈。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/84/2018_12_19_5.png" width="200" hegiht="150">
</center>

我们接着访问`2`，我们发现此时`2`比栈顶元素`6`小，所以我们弹出栈顶元素`6`，并且记录此时的面积`6*1=6`。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/84/2018_12_19_6.png" width="200" hegiht="150">
</center>

此时栈中还有元素，我们发现此时`2`依旧比栈顶元素`5`大，所以我们需要将栈顶元素`5`弹出，并且我们记录此时出栈元素构成的最大面积`5*2=10`。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/84/2018_12_19_7.png" width="200" hegiht="150">
</center>

我们发现此时的`2`比栈顶元素大了，我们就将`2`压入栈中，接着将`3`压入栈中。此时遍历结束，我们发现栈不为空，所以我们需要进行出栈操作，出栈的同时记录出栈元素构成的最大面积即可。

```python
class Solution:
    def largestRectangleArea(self, heights):
        """
        :type heights: List[int]
        :rtype: int
        """
        stack = list()
        res, i = 0, 0
        while i < len(heights):
            if not stack or (heights[i] >= heights[stack[-1]]):
                stack.append(i)
                i += 1
            else:
                k = stack.pop()
                res = max(res, heights[k]*((i - stack[-1] - 1) if stack else i))
                    
        while stack:
            k = stack.pop()
            res = max(res, heights[k]*((i - stack[-1] - 1) if stack else i))
            
        return res
```

一个更简洁的写法。

```python
class Solution:
    def largestRectangleArea(self, heights):
        """
        :type heights: List[int]
        :rtype: int
        """
        stack = [-1]
        res = 0
        heights.append(-1)
        
        for idx, val in enumerate(heights):
            while heights[stack[-1]] > val:
                h = heights[stack.pop()]
                res = max(res, h*(idx - stack[-1] -1))

            stack.append(idx)

        return res
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**