---
layout: post
title: Leetcode 128：最长连续序列（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-12-28 00:00:00
---

给定一个未排序的整数数组，找出最长连续序列的长度。

要求算法的时间复杂度为 *O(n)*。

**示例:**

```
输入: [100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**解题思路**

对于这个问题首先可以想到的解法就是先排序，然后遍历排序后的数组，找出最长的连续数组。这里有一个陷阱，我们在排序之前需要去重。

```python
class Solution:
    def longestConsecutive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        
        nums = list(set(nums))
        nums.sort()
        res, i, nums_len = 1, 0, len(nums)
        while i < nums_len - 1:
            tmp = 1
            while i < nums_len - 1 and nums[i] == nums[i+1] - 1:
                tmp += 1
                i += 1
                
            res = max(res, tmp)
            i += 1
            
        return res
```

这种解法当然很垃圾，很明显题目的要求（`O(n)`复杂度）不是要我们这样去做。怎么办呢？可以这样做，首先通过`set`将`nums`去重并且`hash`。然后我们遍历`nums`中的元素`x`，先判断`x-1`是不是在`nums`中（也就是先确定**连续数组的最小值**），如果不在的话，我们接着判断`x+1`是不是在`nums`中，接着判断`x+2`是不是在`nums`中，类推下去。这样我们就可以找到最长的连续数组。

```python
class Solution:
    def longestConsecutive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums = set(nums)
        best = 0
        for x in nums:
            if x - 1 not in nums:
                y = x + 1
                while y in nums:
                    y += 1
                best = max(best, y - x)
        return best
```

但是实际测试的时候上面的这个做法比第一个慢。

reference:

https://leetcode.com/problems/longest-consecutive-sequence/discuss/41057/Simple-O(n)-with-Explanation-Just-walk-each-streak

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**