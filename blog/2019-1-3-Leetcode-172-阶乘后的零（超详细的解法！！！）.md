---
layout: post
title: Leetcode 172：阶乘后的零（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-3 00:00:00
---

给定一个整数 *n*，返回 *n*! 结果尾数中零的数量。

**示例 1:**

```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```

**示例 2:**

```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

**说明:** 你算法的时间复杂度应为 *O*(log *n*) 。

**解题思路**

首先想到的就是暴力解法。将阶乘算出来，然后计算尾数有多少个零即可。

```python
import math
class Solution:
    def trailingZeroes(self, n):
        """
        :type n: int
        :rtype: int
        """
        fac = math.factorial(n)
        res = 0
        while fac:
            if fac % 10 == 0:
                res += 1
            else:
                break
                
            fac //= 10
            
        return res
```

但是这种做法在输入数较大的时候就超时了。有什么更好的解法呢？

我们发现题目的问题是**尾数有多少个零**，这就很有讲究了。首先`5*2=10`和`1*10=10`，也就是对于`10！`结尾必然会有两个`0`，那么有什么规律呢？我们发现`10`又可以看成是`2*5`，所以归根结底还是要看`5`有多少个，这就很简单了`n//5`即可。但是计算`100!`的时候发现少计算了个数，在哪呢？O(∩_∩)O哈哈~在`25`的时候，我们将`25=5*5`，所以应该时会有两个零才对（因为`2`的数量有很多，你看`16`就有四个`2`了，原因在于`2<5`，所以同样大的数，必然其中包含`2`的数量大于`5`）。以此类推，对于`5**n`都要做处理。那么这个问题就很简单了

```python
class Solution:
    def trailingZeroes(self, n):
        """
        :type n: int
        :rtype: int
        """
        res, k = 0, 5
        while k <= n:
            res += n//k
            k *= 5
            
        return res
```

递归写法。

```python
class Solution:
    def trailingZeroes(self, n):
        """
        :type n: int
        :rtype: int
        """
        return 0 if n == 0 else n // 5 + self.trailingZeroes(n // 5)
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**