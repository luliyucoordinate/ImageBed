---
layout: post
title: Leetcode 10：正则表达式匹配（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-15 00:00:00
---

给定一个字符串 (`s`) 和一个字符模式 (`p`)。实现支持 `'.'` 和 `'*'` 的正则表达式匹配。

```
'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
```

匹配应该覆盖**整个**字符串 (`s`) ，而不是部分字符串。

**说明:**

- `s` 可能为空，且只包含从 `a-z` 的小写字母。
- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `.` 和 `*`。

**示例 1:**

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。
```

**示例 3:**

```
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。
```

**示例 4:**

```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。
```

**示例 5:**

```
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```

**解题思路**

这个问题如果以暴力破解方式思考其实挺难的，主要的难点在于`*`匹配多少次的问题，所以我们可以先尝试通过递归解决这个问题。

对于`*`，我们可以从最简单的情况思考。我们首先判断`len(p)>1 and p[1]=="*"`，如果是的话，说明`*`在`p`的第二位，我们就要判断`s[0]`和`p[0]`能否匹配，如果可以匹配的话，我们继续判断`isMatch(s[1:], p)`（也就是`*`匹配了一次，我们会继续使用`.*`或者`?*`去参与比较），同时需要判断`isMatch(s,p[2:])`是不是成立（也就是`*`表示匹配`0`次）。如果上述条件不成立，我们还需判断`isMatch(s,p[2:])`是不是成立（也就是`*`表示匹配`0`次），因为此时也可能匹配`0`次。

如果`*`不在`p`的第二位，我们就要判断`s[0]`和`p[0]`能否匹配。


```python
class Solution:
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        s_len, p_len = len(s), len(p)
        if p_len == 0:
            return s_len == 0

        if p_len > 1 and p[1] == "*":
            return self.isMatch(s, p[2:]) or \
                (s_len != 0 and (s[0] == p[0] or p[0] == '.') \
                and self.isMatch(s[1:], p))
        else:
            return s_len != 0 and (s[0] == p[0] or p[0] == '.')\
                and self.isMatch(s[1:], p[1:]) 
```

上面的写法使用了`trick`，我们将`=='*'`时候的两种情况归并到了一起，分开写的话如下

```python
if p_len > 1 and p[1] == "*":
    if s_len != 0 and (s[0] == p[0] or p[0] == '.'):
        return self.isMatch(s[1:], p) or self.isMatch(s, p[2:])
    else:
    	return self.isMatch(s, p[2:])
else:
    return s_len != 0 and (s[0] == p[0] or p[0] == '.')\
        and self.isMatch(s[1:], p[1:]) 
```

对于递归可以解决的问题，我们都可以记忆化搜索的方式来优化。

```python
class Solution:
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        s_len, p_len = len(s), len(p)
        mem = [[None]*(p_len+1) for _ in range(s_len+1)]
        return self._isMatch(s, p, mem)

    def _isMatch(self, s, p, mem):
        s_len, p_len = len(s), len(p)
        if p_len == 0:
            return s_len == 0
        if mem[s_len][p_len] != None:
            return mem[s_len][p_len]

        if p_len > 1 and p[1] == "*":
            mem[s_len][p_len] =  self._isMatch(s, p[2:], mem) or \
                (s_len != 0 and (s[0] == p[0] or p[0] == '.') \
                and self._isMatch(s[1:], p, mem))
            return mem[s_len][p_len]
        else:
            mem[s_len][p_len] =  s_len != 0 and (s[0] == p[0] or p[0] == '.')\
                and self._isMatch(s[1:], p[1:], mem) 
            return mem[s_len][p_len]
```

然而记忆化搜索又和动态规划有着密切的联系，所以我们可以非常迅速的写出动态规划转移方程

- $f(i,j)=f(i-1,j-1)\ \ if\ \ p[j-1]!='*'\ \ and \ \ s[i-1]==p[j-1]||p[j-1]=='.'$
- $f(i,j)=f(i,j-2)\ \ if \ \ p[j-1]=='*'$
- $f(i,j)=f(i-1,j)\  \ and \ \ (s[i-1]==p[j-2] || p[j-2]=='.')\ \ if\ \ p[j-1]=='*'$

`f(i,j)`表示输入`s[0:i]`和输入`p[0:j]`时的匹配结果。

```python
class Solution:
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        s_len, p_len = len(s), len(p)
        mem = [[False]*(p_len+1) for _ in range(s_len+1)]
        mem[0][0] = True
        for i in range(s_len+1):
            for j in range(1, p_len+1):
                if p[j-1] == '*':
                    mem[i][j] = j > 1 and mem[i][j-2] or \
                                (i > 0 and (s[i-1] == p[j-2] or \
                                j > 1 and p[j-2] == ".") and \
                                 i > 0 and mem[i-1][j])
                else:
                    mem[i][j] = i > 0 and \
                                mem[i-1][j-1] and \
                                ((i > 0 and s[i-1] == p[j-1]) or\
                                 p[j-1] == ".")

        return mem[-1][-1]
```

我在之前的一些问题中也一直提及这样的问题，如果我们拿到一个动态规划问题无从下手的时候，不防先从递归开始思考。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**