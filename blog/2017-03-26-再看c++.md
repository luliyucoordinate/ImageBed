---
layout: post
title: 再看c++
category : cpp
tags : [cpp]
stickie: true
---


Object Based基于对象
===

这里的类型是含有指针

```c++
class String
{
public:
	string(constchar* cstr = 0);
	string(conststring& str);
	string&operator=(const String& str);
	~String();
	char *get_c_str()const { return m_data; }
private:
	char *m_data;
};
```


ctor和dtor
---
```c++
inline
String::String(const char * cstr = 0)
{
	if( cstr)
	{
	   	m_data = new char[strlen(cstr) + 1];
		strcpy(m_data, cstr);
	}
	else
	{
   	 	m_data = new char [1];
    	*m_data = ‘\0’;
	}
}

inline
String::String()
{
	delete[] m_data;
} 
```


copy constructor
---
如果使用的是默认拷贝的话，只会copy指针，指针指向的值不会copy

```c++
inline
String::String(const String& str)
{
	m_data = newchar[ strlen(str.m_data  + 1)];
	strcpy(m_data,str.m_data);
}
```


copy assignment operator
---
```c++
inline 
String& String::operator=(constString& str)
{
    if(this == &str)
        return *this;   //self assignment
	delete[] m_data;
	m_data = newchar[ strlen(str.m_data) + 1];
	strcpy(m_data,str.m_data);
	return *this;
}
```
这里self assignment的原因在于
我们在copy之前调用了delete



stack and heap
---

stack是存在于某个作用域内的内存空间，但你调用函数，函数本身会形成一个stack用来放置他所接受的参数，以及返回地址。在函数本体内申明的任何变量，其所使用的内存块都取自于上述的stackHeap，是指由系统提供的一块global内存空间，程序可动态分配Complex c1(1,2)c1便是所谓的stack object，其生命在作用域结束之后结束。

```c++
static Complex c2(1,2);
```
c1便是所谓的static object，其生命在作用域结束之后任然存在，在整个程序结束后结束。

```c++
Complex c3(1,2);
int main()
{ }
```
c3便是global object，他的生命在程序结束后才结束，你也可以把它视为static object  
new先分配内存在调用ctor

```c++
Complex *pc = new Complex(1, 2);
```
编译器转化为

```c++
Complex *pc;
void* mem = operator new (sizeof( Complex));// 内部调用malloc
pc = static_cast< Complex*>(mem);
pc->Comnplex::Complex(1,2); 
```
delete 先调用dtor，在释放内存

```c++
String::~String(ps);
operator delete(ps); // 内部调用free
```

<a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fe3yfh2smwj20p40i2taq.jpg" data-lightbox="roadtrip">
<img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fe3yfh2smwj20p40i2taq.jpg" class="img-fluid">
</a>
<a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fe3yfhgf74j20se0hegnw.jpg" data-lightbox="roadtrip">
<img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fe3yfhgf74j20se0hegnw.jpg" class="img-fluid">
</a>


array new一定要搭配array delete  
delete[] p;与delete p;都会删除内存

<a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fe3yfhxibyj20pe0eltac.jpg" data-lightbox="roadtrip">
<img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fe3yfhxibyj20pe0eltac.jpg" class="img-fluid">
</a>


但是问题不是发生这里，第一种写法会告诉编译器调用三次析构函数 而第二个会调用一次析构函数。最后的指针空间都会被释放，但是这里指针所指向的内存空间在第二种情况下会发生内存泄漏。但是如果一个类里面没有指针的话。那这两种就没有区别，但是区别做是一种好的习惯。

关于static  
static data members  
同一个类不同对象具有相同的值时，使用静态成员变量  
static member functions  
静态函数没有this pointer，所以他不可像一般函数那样访问非静态成员数据，所以他只可以访问静态成员数据。

```c++
class Account
{
public:
	static double m_rate;
	static void set_rate(const double& x) { m_rate = x;}
];
double Account::m_rate = 8.0;
```

调用static函数的方式  
通过object调用和通过class name调用  
多谈几句  
问题1： 为什么在类内的静态成员定义后，要到类的外部在定义和初始化？  
答：首先这句话就是错的，在类内的静态成员变量只是一定声明，并没有分配相应的内存空间；在类外，相当于定义加上初始化，如果只是定义，也是能够编译成功的，因为分配了内存。等价于全局变量，但只属于类。  

问题2：为什么类的静态成员在类外部的定义只能一次?  
答：好比全局变量的多重定义  
另外，任何变量都只进行一次初始化。局部变量在程序块结束时生存期就结束了，下次再调用这个程序块时从原理上说声明的是另一个变量了(分配到的地址也不一定一样)。  
PS：在不同编译器的不同编译情况时，实际的内存分区可能不同。例如TC的Small模式下堆和栈区是重合的，而Tiny模式下连静态区域和动态区域都是重合的。  

问题3：私有的静态成员变量如何初始化，访问权限还是私有么？  
答：显然，也是在类的外部进行初始化，但是访问权限是存在的。比如不能在程序执行的过程中直接用类名加作用域来访问此私有的静态成员。需要通过类公有的外部接口来访问，包括静态与非静态接口。  
 
问题4：在程序执行过程中，其他类的对象改变静态成员变量的值，那么相应的在建立另一个对象时的静态成员值会是初始化的值还是上一次改变的值？  
答：是上一次改变的值，因为初始化是分配内存，赋初值。  

问题5：类的非静态成员函数中能访问静态成员变量么？  
答：是可以访问的，前提是要对静态的进行外部的初始化。如果为初始化，则会报错，是链接错误，显然在类内部只是声明，并没有在类的外部进行定义与初始化，未分配内存。  

问题6：类的静态成员函数中能访问非静态成员变量么？  
答：不能，解析不了。非静态成员，不是一个特定的对象的，既没有this指针，指向，根本找不到。  

首先问题来自这个函数:

```c++
int fun()
{
	static int i=0;
	i++;
	return i;
}
```
当这个函数被反复调用时,i的值是会一直加的,也就是静态变量只被初始化了一次.  
我对此产生了疑惑.不知道大家有没有.当改为:

```c++
int fun()
{
    i=0;
    ++i;
    return i;
}
```
反复调用时都返回的是1; 这个例子很明白,虽然i这个变量时同名的,但是地址是不一样的,这是一个新的变量,因为在作用域后,原变量被销毁了.接着创建一个新的变量.
那么这里我们就知道了一件事情:就是静态变量是全局的,和程序的生命周期是一样的.那么原来的staic的i依然存在. 但是它的可访问区域就只能是定义的作用域,而不一定能全局访问,这是全局变量的一个差别.而静态变量的必须初始化,如果没有显示初始化,则初始化为0 ,'0'或者其他.初始化在程序第一次加载中开始.并设置了相应的标志位!所以当变量重复时,编译器忽略了重复初始化的代码,到这里就算是C++只能初始化一次的原因了!操作系统在加载程序时会根据程序中的声明部分为程序分配内存空间(这部分数据是由编译器生成的)。程序所支配的内存空间分为两大部分：静态区域和动态区域(至于为什么这样区分涉及到硬件知识，
建议LZ不要深究)：动态区域用于存储经常会变动的数据(动态区域又分为两大部分：
栈和堆，关于这两个部分大家应该都很熟悉了)；静态区域(Java里称为永久区域)用于存储不会经常变化的数据，
例如程序的指令代码(C/C++里就是各个函数编译后得到的代码)、用户类型(结构体、类)的声明代码、全局变量、静态变量
有些例子提到用静态变量来做递归的计数器，那只是为了说明静态变量的特性。
实际上不推荐这种用法，因为这样会对程序性能造成轻微的影响。
静态区域内的数据会在程序加载时进行初始化，生存期为程序运行的全部时间。

关于singleton  
这个设计模式主要目的是想在整个系统中只能出现一个类的实例。这样做当然是有必然的，比如你的软件的全局配置信息，或者是一个Factory，或是一个主控类，等等。

```c++
class A
{
public: 
	static A& getInstance ( return a; );
	setup() { }
private:
	A();
	A(const A& rhs);
};
A& A::getInstance()
{
	static A a;
	return a;
}
A::getInstance.setup();
```
关于function template

```c++
template <class T>
inline 
const T& min(const T& a, constT& b)
{
	return b < a ? b : a; // < overload
}
r3 = min( r1, r2);
```
编译器会对function template 进行  
argument deduction,所以像模板类一样不用写类型  

member template

```c++
template <class T1, class T2>
struct pair
{
	typedef T1 first_type;
	typedef T2 second_type;
	
	T1 first;
	T2 second;
	
	pair()
		: first(T1()), second(T2()) {}
	pair(const T1& a, const T2& b)
		: first(a) ,second(b) {}
	
	template <class U1, class U2>
	pair(const pair<U1, U2>& p
		: first(p.first), second(p.second) {}
};
```
关于namespace

```c++
namespce std
{
}

```
<a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe3yfi6sf8j20wx0abjsm.jpg" data-lightbox="roadtrip">
<img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe3yfi6sf8j20wx0abjsm.jpg" class="img-fluid">
</a>

关于type conversion operator(类型转换操作符)  
类型转换操作符（type conversion operator）是一种特殊的类成员函数，它定义将类类型值转变为其他类型值的转换。转换操作符在类定义体内声明，在保留字 operator 之后跟着转换的目标类型。boost::ref和boost::cref就使用到了类型转换操作符。

T1::operator T2() [const];　　　//T1的成员函数，"(T2)a"类型转换  
转换函数必须是成员函数，不能指定返回类型，并且形参表必须为空；返回值是隐含的，返回值是与转换的类型相同的，即为上面原型中的T2；T2表示内置类型名（built-in type）、类类型名（class type）或由类型别名（typedef）定义的名字；对任何可作为函数返回类型的类型（除了 void 之外）都可以定义转换函数，一般而言，不允许转换为数组或函数类型，转换为指针类型（数据和函数指针）以及引用类型是可以的；转换函数一般不应该改变被转换的对象，因此转换操作符通常应定义为 const 成员；支持继承，可以为虚函数；只要存在转换，编译器将在可以使用内置转换的地方自动调用它；



Object oriented programming面向对象
===


Composition 复合has-a
---
```c++
Adapter模式
template <class T, class Sequence = deque<T> >
class queue
{
	…
protected:
	Sequence c;
public:
	bool empty() const { return c.empty(); }
	size_type size() const { return c.size(); }
	reference front() { return c.front(); }
	reference back() { return c.back(); }
	void push (const value_type& x) { return c.push_back(x); }
	void pop() { c.pop_front(); }
};
```

更深层的复合  
Container <> -- -->component  
构造由内而外  
Container 的构造函数首先调用Component的default构造函数，然后才执行自己  
Container::Container(…) : Component() { … }  
析构由外向内  
Container 的析构函数首先执行自己，然后才调用Component的析构函数  
Container::~Container() : {…~Component() };

```c++
Delegation 委托Composition by reference
String.hpp文件
class StringRep;
class String
{
public:
	String();
	String( const char *s);
	String(const String &s);
	String &operator=(const String& s);
	~String();
private:
	StringRep *rep;  //pimpl handle/body
};
Cpp文件
#include “String.hpp”
namespace 
{
	class StringRep
	{
		friend class String;
		StringRep(const char *);
		~StringRep();
		int count;
		char *rep;
	};
}
String::String(){ … }
```
```c++
Inheritance继承 is-a
struct _List_node_base
{
    _List_node_base *_M_next;
	_List_node_base *_M_prev;
};
template <typename _Tp >
struct _List_node
: public _List_node_base
{
	_Tp _M_data;
};
```

构造由内而外  
base 的构造函数首先调用derived的default构造函数，然后才执行自己  
derived::derived(…) : base() { … }  
析构由外向内  
derived 的析构函数首先执行自己，然后才调用base的析构函数  
derived::~ derived () : {…~base() };  
注意base class 的dtor必须是virtual否则会出现undefined behavior  

Inheritance with virtual functions  
继承的是调用权  
non-virtual函数：不希望dervied class重新定义override它  
virtual 函数：希望derived class重新定义override它，他已有默认定义。  
pure virtual函数：希望derived class一定要重新定义override它，你对他没有默认定义。  

```c++
class Shap
{
	virtual void draw() const = 0; //pure virtual
	virtual void error(const std::string& msg); // impure virtual
	int objectID() const; //non-virtual
};
class Rectangle : public Shape { … };
class Ellipse : public Shape { … };
```

Delegation and Inheritance  
Observer模式  

```c++
class Subject
{
	int m_value;
	vector< Observer* >m_views;
public:
	void attach( Observer *obs)
{
    m_views.push_back(obs);
}
void set_val (int value)
{
    m_value = value;
    notify();
}
void notify()
{
    for( int I = 0; I < m_views.size(); ++i)
        m_views[i]->update(this, m_value);
}
};
class Observer
{
public:
	virtual void update(Subject *sub, int value ) = 0;
};//作为父类派生出多个观察者，放入容器中
```
Composite模式

<a href="http://wx2.sinaimg.cn/mw690/af2d2659gy1fe3yfip9j5j20eg0acte5.jpg" data-lightbox="roadtrip">
<img src="http://wx2.sinaimg.cn/mw690/af2d2659gy1fe3yfip9j5j20eg0acte5.jpg" class="img-fluid">
</a>

```c++
class Component
{
	int value;
public:
	Component(int val) { value = val; }
	virtual void add( Component *){}
};
class Primitive: public Component
{
public:
	Primitive(int val) : Component(val) {}
};
class Composite: public 
{
	vecotor< Component *>
public:
	Composite(int val) :Component(val) {}
	void add(Component *elem)
{
	c.push_back(elem);
}
…
};
```


Prototype模式
---

创建未来的对象

<a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe3yfj1eiaj20nc0ei0us.jpg" data-lightbox="roadtrip">
<img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe3yfj1eiaj20nc0ei0us.jpg" class="img-fluid">
</a>

```c++
#include <iostream.h>
enum imageType
{
	LAST, SPOT
};
class Image
{
public:
	virtual void draw() = 0;
	static Image *findAndClone(imageType);
protected:
	virtual imageType returnType() = 0;
	virtual Image *clone() = 0;
	static void addPrototype( Image *image)
	{
    	_prototypes[_nextSlot++] = image;
	}
private:
	static Image * prototypes[10];
	static int _nextSlot;
};
Image *Image::_prototypes[];
int Image::_nextSlot;
Image *Image::findAndClone(imageType type)
{
	for(int I = 0; I < _nextSlot; ++i)
	{
    	if(_prototypes[i]->returnType() == type)
   		{
        	return _prototypes[i]->clone();
    	}
	}
}
class LandSatImage::public Image
{
public:
	imageType returnType()
	{
		return LSAT;
	}
	void draw()
	{
		cout << "LandSatImage::draw" << _id << endl;
		
	}
	Image *clone()
	{
		return new LandSatImage(1);
	}
protected:
	LandSatImage(int dummy) ///这里私有保护都可以
	{
		_id = count++;
	}
private:
	static LandSatImage _LandSatImage;
	LandSatImage()
	{
		addPrototype(this);
	}
	int _id;
	static int _count;
}
LandSatImage LandSatImage::_LandSatImage;
int LandSatImage::_count = 1;
```


conversion function转换函数
---
```c++
class fraction 
{
public:
Fraction (int num, int den = 1)
    : m_numberator ( num ), m_denominator(den) {}
operator double() const
{
return (double) (m_numerator / m-denominator;
}
private:
int m_numerator;
int m_denominator;
}
Fraction f(3,5);
double d = 4 + f;
```


non-explicit-one-argument ctor
---
```c++
class Fraction
{
public:
	Fraction(int num, int den = 1)
	    : m_numberator(num), m_denbominator(den){}
	Fraction operator+(const Fraction& f)
	{
		return Fraction(...);
	}
private:
	int m_numerator;
	int m_denominator;
};
Fraction f(3,5);
Fraction d2 = f + 4;//调用 non-explicit ctor将4转化为Fraction(4,1)
```
注意的是如果一个类里面同时有这两个的话会报错，出现二意

```c++
class Fraction
{
public:
	explicit Fraction(int num, int den = 1)
	    : m_numberator(num), m_denbominator(den){}
	Fraction operator+(const Fraction& f)
	{
		return Fraction(...);
	}
private:
	int m_numerator;
	int m_denominator;
};
Fraction f(3,5);
Fraction d2 = f + 4;//error声明为explicit的构造函数不能在隐式转换中使用
```


pointer-like class
---

关于智能指针  
智能指针(smart pointer)是存储指向动态分配（堆）对象指针的类，用于生存期控制，能够确保自动正确的销毁动态分配的对象，防止内存泄露。

```c++
template<class T>
class shared_ptr
{
public:
	T& operator* () const
	{ return *px; }
	T* operator->() const
	{ return px; }
	shared_ptr(T* p): px(p) {}
private:
	T* px;
	long* pn;
	...
};
shared_ptr<Foo> sp(new Foo);
Foo f(*sp);
sp->method();
关于迭代器
template<class T, class Ref, class Ptr>
struct _list_iterator
{
	typedef _list_iterator<T, Ref, Ptr> self;
	typedef Ptr pointer;
	typedef Ref reference;
	typedef _list_node<T>* link_type;
	link_type node;
	reference operator*() const { return (*node).data; }
	pointer operator->() const { return &(operator* ()); }
	...
};
```


Function-like classes仿函数
---
```c++
template <class T>
struct identity
{
	const T&
	operator() (const T& x) const { return x; }
};
template <class Pair>
struct select1st
{
	const typename Pair::first_type&
	operator() (const Pair& x) const
	{return x.first; }
};
template <class Pair>
struct select2nd
{
	const typename Pair::second_type&
	operator() (const Pair& x) const
	{ return x.second; }
};
template<class T1,class T2>
struct pair
{
	T1 first;
	T2 second;
	pair() :first(T1()) ,second(T2()){}
pair(const T1& a,const T2& b)
	 :first(a), second(b){}
…
};
select1st<Pair>() (new Pair());

```
