---
layout: post
title: 迭代器相关的辅助函数
category : cpp
tags : [cpp, notes, cpp标准库, 迭代器]
---


advance
---

定义于头文件\<iterator\>  

```c++
template< class InputIt, class Distance >
void advance( InputIt& it, Distance n );
```
增加迭代器it n个元素。如果n为负，迭代器递减。在这种情况下，InputIt的BidirectionalIterator必须满足的要求，否则该行为是未定义。  
例子：  

```c++
#include <iostream>
#include <iterator>
#include <vector>
 
int main() 
{
    std::vector<int> v{ 3, 1, 4 };
    auto vi = v.begin();
    std::advance(vi, 2);
    std::cout << *vi << '\n';
}
```
结果为 4  

next和prev
---

定义于头文件 \<iterator\>  

```c++
template< class ForwardIt >
ForwardIt next( ForwardIt it, 
                typename std::iterator_traits<ForwardIt>::difference_type n = 1 );
```
返回的nth的继任者的迭代器it。  
定义于头文件\<iterator\>  

```c++
template< class BidirIt >
BidirIt prev( BidirIt it, 
              typename std::iterator_traits<BidirIt>::difference_type n = 1 );
```
返回的nth的前身迭代器it。  
前面提到了next的一个有效的用处就是在forward和bidirectional迭代器。  
里一个用处主要是before_begin  

```c++
auto posBefore = list.before_begin();
for(; next(posBefore) != list.end(); ++posBefore)
{
	if(*next(posBefore) %2 == 0)
	{
		break;
	}
}
```

distance
---

```c++
template< class InputIt >
typename std::iterator_traits<InputIt>::difference_type 
    distance( InputIt first, InputIt last );
```
返回first和last之间的元素数量。如果last不能由first递增得到，则函数的行为是未定义的。  
例子：  

```c++
#include <iostream>
#include <iterator>
#include <vector>
 
int main() 
{
     std::vector<int> v{ 3, 1, 4 };
     auto distance = std::distance(v.begin(), v.end());
     std::cout << distance << '\n';
}
```
结果为3  

处理两个non-random-access迭代器之间的距离时要十分小心。第一迭代器所知的元素绝对不能在第二迭代器所指元素的后方，否则会导致不明确的行为。  

```c++
Iter_swap
template< class ForwardIt1, class ForwardIt2 >
void iter_swap( ForwardIt1 a, ForwardIt2 b );
```
交换给定的迭代器指向的元素的值。迭代器的类型不必相同，但其所指的两个值必须可以相互赋值。  

```c++
#include <iostream>
#include <list>
#include <algorithm>
#include <iterator>
#include "print.hpp"
using namespace std;
int main()
{
    list<int> coll;
    // insert elements from 1 to 9
    for (int i=1; i<=9; ++i) {
        coll.push_back(i);
    }
    PRINT_ELEMENTS(coll);
    // swap first and second value
    iter_swap (coll.begin(), next(coll.begin()));
    PRINT_ELEMENTS(coll);
    // swap first and last value
    iter_swap (coll.begin(), prev(coll.end()));
    PRINT_ELEMENTS(coll);
}
```
程序输出如下：  

```c++
1 2 3 4 5 6 7 8 9
2 1 3 4 5 6 7 8 9
9 1 3 4 5 6 7 8 2
```
注意，next和prev始自c++11，因此若以operator++和—取而代之，可以参看前面讲的内容。  
