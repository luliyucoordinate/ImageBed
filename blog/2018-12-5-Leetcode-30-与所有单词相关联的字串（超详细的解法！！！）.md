---
layout: post
title: Leetcode 30：与所有单词相关联的字串（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-12-5 00:00:00
---

给定一个字符串 **s** 和一些长度相同的单词 **words。**在 **s** 中找出可以恰好串联 **words** 中所有单词的子串的起始位置。

注意子串要与 **words** 中的单词完全匹配，中间不能有其他字符，但不需要考虑 **words** 中单词串联的顺序。

**示例 1:**

```
输入:
  s = "barfoothefoobarman",
  words = ["foo","bar"]
输出: [0,9]
解释: 从索引 0 和 9 开始的子串分别是 "barfoor" 和 "foobar" 。
输出的顺序不重要, [9,0] 也是有效答案。
```

**示例 2:**

```
输入:
  s = "wordgoodstudentgoodword",
  words = ["word","student"]
输出: []
```

**解题思路**

我们首先想到的解法当然是暴力破解。我们将`words`的所有排列情况列出来，为了避免重复元素，我们应该使用一个`set`去存放结果。然后我们遍历`set`中的所有元素，查看元素在`s`中的位置，并将位置存放到`list`中。

```python
class Solution:
    def findSubstring(self, s, words):
        """
        :type s: str
        :type words: List[str]
        :rtype: List[int]
        """
        res = list()
        if not words:
            return res
        
        for word in set(itertools.permutations(words)):
            tmp_word = ''.join(word)
            
            i = s.find(tmp_word)

            while i != -1:
                res.append(i)
                i = s.find(tmp_word, i + 1)
                
        return res
```

提交代码后提示我们` Memory Limit Exceeded`。我们遗漏了一个条件**长度相同的单词 words**。所以我们就有了如下的策略，我们可以先将`words`中的元素存放到`dict`中，对于例1来说就是

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_1.png" width="150" hegiht="160">
</center>

此时我们的目标就是匹配`dict`中的所有字符串，我们从头开始

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_2.png" width="600" hegiht="220">
</center>

我们发现此时匹配了`bar`，所以我们此时应该移动`len(words[0])`的步数

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_3.png" width="600" hegiht="220">
</center>

我们发现此时`foo`也匹配了，所以此时`dict`中的全部元素都匹配成功，我们就要记录开始的`index=0`。我们现在从`index=1`开始匹配

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_4.png" width="600" hegiht="220">
</center>

我们发现第一个字符串就匹配失败，我们接着从`index=2`开始也是失败，我们接从`index=3`开始

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_5.png" width="600" hegiht="220">
</center>

我们发现此时第一个匹配成功，所以我们此时应该移动`len(words[0])`

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_6.png" width="600" hegiht="220">
</center>

我们发现此时匹配失败，所以我们就要从`index=4`，依次往后。

```python
class Solution:
    def findSubstring(self, s, words):
        """
        :type s: str
        :type words: List[str]
        :rtype: List[int]
        """
        if not words:
            return []
        
        words_dict = collections.defaultdict(int)
        for word in words:
            words_dict[word] += 1
            
        s_len, words_len, word_len, res = len(s), len(words), len(words[0]), list()
        for i in range(s_len - words_len*word_len + 1):
            num, has_words = 0, collections.defaultdict(int)
            while num < words_len:
                word = s[i+num*word_len:i+(num+1)*word_len]
                if word not in words_dict:
                    break

                has_words[word] += 1
                if has_words[word] > words_dict[word]:
                    break
                
                num += 1
                
            if num == words_len:
                res.append(i)
                
        return res          
```

上述代码提交后就获得了`accept`。你可能已经注意到了上述算法中存在的一些缺陷，例如当我们的`words`很长时，我们`n-1`个`word`都匹配成功了，但是就最后一个匹配失败，我们就要`index++`开始，实际上这是有问题的，我们此时应该继续从失败的单词后继续开始匹配，直到这一轮匹配完再从`index++`开始，例如

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_6.png" width="600" hegiht="220">
</center>

我们发现此时匹配失败，我们应该从`the`后，也就是`foo`开始将剩余部分匹配完。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_7.png" width="600" hegiht="220">
</center>

这样我们就充分利用了我们之前存储的信息。为了更好地说明问题，我们取这样的一个例子`s = "barfoobarfoobarfoofoo"`,`words = ["foo","bar","foo"]`。我们来看一下具体实现步骤

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_8.png" width="600" hegiht="220">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_9.png" width="150" hegiht="150">
</center>

我们发现此时匹配到了一个单词`bar`，所以此时我们前进`len(words[0])`步，并且将此时匹配到的单词加入到一个临时的字典中存放。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_11.png" width="600" hegiht="220">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_12.png" width="150" hegiht="150">
</center>

我们发现此时匹配到了一个单词`foo`，所以此时我们前进`len(words[0])`步，并且将此时匹配到的单词加入到一个临时的字典中存放。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_13.png" width="600" hegiht="220">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_10.png" width="150" hegiht="150">
</center>

我们发现此时匹配到了一个单词`bar`，但是此时`bar`的数量已经超过了`words`中的，所以我们此时要将第一个`bar`弹出。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_15.png" width="600" hegiht="220">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_14.png" width="150" hegiht="150">
</center>

我们发现此时匹配到的单词`the`不在`words`中，所以此时我们前进`len(words[0])`步，并且将临时字典清空。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_16.png" width="600" hegiht="220">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_19.png" width="150" hegiht="150">
</center>

我们发现此时匹配到了一个单词`bar`，所以此时我们前进`len(words[0])`步，并且将此时匹配到的单词加入到一个临时的字典中存放。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_17.png" width="600" hegiht="220">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_12.png" width="150" hegiht="150">
</center>

我们发现此时匹配到了一个单词`foo`，所以此时我们前进`len(words[0])`步，并且将此时匹配到的单词加入到一个临时的字典中存放。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_18.png" width="600" hegiht="220">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/30/2018_12_8_9.png" width="150" hegiht="150">
</center>

我们发现此时匹配到了一个单词`foo`，并且将此时匹配到的单词加入到一个临时的字典中存放，我们发现此时多有单词匹配成功，我们就将`index=12`加入到我们的结果中。接着我们再从`index=1...len(words[0])-1`开始遍历即可。代码如下

```python
class Solution:
    def findSubstring(self, s, words):
        """
        :type s: str
        :type words: List[str]
        :rtype: List[int]
        """
        if not words:
            return []
        
        words_dict = collections.defaultdict(int)
        for word in words:
            words_dict[word] += 1
            
        s_len, words_len, word_len, res = len(s), len(words), len(words[0]), list()
        for k in range(word_len):
            has_words, num = collections.defaultdict(int), 0
            for i in range(k, s_len, word_len):
                word = s[i:i + word_len]
                if word in words_dict:
                    num += 1
                    has_words[word] += 1
                    while has_words[word] > words_dict[word]:
                        pos = i - word_len*(num - 1)
                        rem_word = s[pos:pos + word_len]
                        has_words[rem_word] -= 1
                        num -= 1
                else:
                    has_words.clear()
                    num = 0
                    
                if num == words_len:
                    res.append(i - word_len*(num - 1))
        return res
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**