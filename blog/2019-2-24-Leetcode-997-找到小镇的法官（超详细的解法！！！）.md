---
layout: post
title: Leetcode 997：找到小镇的法官（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-2-24 00:00:00
---

在一个小镇里，按从 `1` 到 `N` 标记了 `N` 个人。传言称，这些人中有一个是小镇上的秘密法官。

如果小镇的法官真的存在，那么：

1. 小镇的法官不相信任何人。
2. 每个人（除了小镇法官外）都信任小镇的法官。
3. 只有一个人同时满足属性 1 和属性 2 。

给定数组 `trust`，该数组由信任对 `trust[i] = [a, b]` 组成，表示标记为 `a` 的人信任标记为 `b` 的人。

如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 `-1`。

**示例 1：**

```
输入：N = 2, trust = [[1,2]]
输出：2
```

**示例 2：**

```
输入：N = 3, trust = [[1,3],[2,3]]
输出：3
```

**示例 3：**

```
输入：N = 3, trust = [[1,3],[2,3],[3,1]]
输出：-1
```

**示例 4：**

```
输入：N = 3, trust = [[1,2],[2,3]]
输出：-1
```

**示例 5：**

```
输入：N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
输出：3
```

**提示：**

1. `1 <= N <= 1000`
2. `trust.length <= 10000`
3. `trust[i]` 是完全不同的
4. `trust[i][0] != trust[i][1]`
5. `1 <= trust[i][0], trust[i][1] <= N`

**解题思路**

这个问题非常简单，我们可以建立一个`defaultdict(set)`，然后遍历`trust`中的每个元素`it`（将`it[0]`作为`key`，将`it[1]`作为`value`）添加到`dict`中，这样我们就建立了一个信任关系的映射。我们知道**每个人（除了小镇法官外）都信任小镇的法官**，那么我们只需要查找`dict`中是不是有一个`value`的长度等于`N-1`，如果存在的话，那么对应的`key`就是法官。此时还有一个问题，就是**小镇的法官不相信任何人**，我们只需要新建一个`set`，将`it`的`key`添加到`set`中，如果我们返回的数在`set`中存在的话，那么说明**存在法官相信他人的情况**。

这里还有一个边界条件没有考虑，就是小镇只有一个人的时候，那么这个人一定是法官。

```python
from collections import defaultdict
class Solution:
    def findJudge(self, N: int, trust: List[List[int]]) -> int:
        if not trust:
            return 1
        trust_map = defaultdict(set)
        trust_set = set()
        for it in trust:
            trust_map[it[1]].add(it[0])
            trust_set.add(it[0])
        
        for key, val in trust_map.items():
            if len(val) == N-1 and key not in trust_set:
                return key
        return -1
```

我们还有一个更加出色的想法，就是建立有向图。将小镇里的每个人当成一个节点，那么对于**法官**这个节点来说，指向它的边的数量减去它指向的边的数量一定是`N-1`，可以理解为`七桥问题`。（边表示为`it[0]`指向`it[1]`）

```python
class Solution:
    def findJudge(self, N: int, trust: List[List[int]]) -> int:
        count = [0] * (N + 1)
        for i, j in trust:
            count[i] -= 1
            count[j] += 1
        for i in range(1, N + 1):
            if count[i] == N - 1:
                return i
        return -1
```

reference:

https://leetcode.com/problems/find-the-town-judge/discuss/242938/JavaC%2B%2BPython-Directed-Graph

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**