---
layout: post
title: Leetcode 229：求众数 II（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-06 00:00:00
---

给定一个大小为 *n* 的数组，找出其中所有出现超过 `⌊ n/3 ⌋` 次的元素。

**说明:** 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

**示例 1:**

```
输入: [3,2,3]
输出: [3]
```

**示例 2:**

```
输入: [1,1,1,3,3,2,2,2]
输出: [1,2]
```

**解题思路**

这是之前问题[Leetcode 169：求众数（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/83788426)的扩展。现在要求时间复杂度为`O(n)`，那么我们就不可以使用之前的做法了。我们可以参考[摩尔投票算法](https://blog.csdn.net/qq_17550379/article/details/83818965)的思路

```python
class Solution:
    def majorityElement(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        if not nums:
            return []

        c1, c2, m, n = 0, 0, None, None
        for num in nums:
            if num == m:
                c1 += 1
            elif num == n:
                c2 += 1
            elif c1 == 0:
                m, c1 = num, 1
            elif c2 == 0:
                n, c2 = num, 1
            else:
                c1 -= 1
                c2 -= 1

        return [num for num in set([m, n]) \
                    if nums.count(num) > len(nums)//3]
```

我们要对最后的结果用`set`处理，因为要避免输入的元素`[0,0,0]`就会输出`[0,0]`。



```python
from collections import Counter
class Solution:
    def majorityElement(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        ctr = Counter()
        for n in nums:
            ctr[n] += 1
            if len(ctr) == 3:
                ctr -= Counter(set(ctr))
        return [n for n in ctr if nums.count(n) > len(nums)/3]
```

reference:

https://leetcode.com/problems/majority-element-ii/discuss/63502/6-lines-general-case-O(N)-time-and-O(k)-space

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**