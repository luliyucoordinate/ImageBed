---
layout: post
title: Leetcode 955：删列造序 ||（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-12-17 00:00:00
---

给定由 `N` 个小写字母字符串组成的数组 `A`，其中每个字符串长度相等。

选取一个删除索引序列，对于 `A` 中的每个字符串，删除对应每个索引处的字符。

比如，有 `A = ["abcdef", "uvwxyz"]`，删除索引序列 `{0, 2, 3}`，删除后 `A` 为`["bef", "vyz"]`。

假设，我们选择了一组删除索引 `D`，那么在执行删除操作之后，最终得到的数组的元素是按 **字典序**（`A[0] <= A[1] <= A[2] ... <= A[A.length - 1]`）排列的，然后请你返回 `D.length` 的最小可能值。

**示例 1：**

```
输入：["ca","bb","ac"]
输出：1
解释： 
删除第一列后，A = ["a", "b", "c"]。
现在 A 中元素是按字典排列的 (即，A[0] <= A[1] <= A[2])。
我们至少需要进行 1 次删除，因为最初 A 不是按字典序排列的，所以答案是 1。
```

**示例 2：**

```
输入：["xc","yb","za"]
输出：0
解释：
A 的列已经是按字典序排列了，所以我们不需要删除任何东西。
注意 A 的行不需要按字典序排列。
也就是说，A[0][0] <= A[0][1] <= ... 不一定成立。
```

**示例 3：**

```
输入：["zyx","wvu","tsr"]
输出：3
解释：
我们必须删掉每一列。
```

**提示：**

1. `1 <= A.length <= 100`
2. `1 <= A[i].length <= 100`

**解题思路**

这是之前问题[Leetcode 944：删列造序（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/84984081)的扩展。这个问题的主要难点在于我们需要考虑这样的情况`["xga","xfb","yfa"]`，此时我们发现`x`出现两次，那么我们就要比较其后的`g`和`f`是否满足字典序。我们首先看一个较为朴素的思路

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/955/2018_12_17_1.png" width="150" hegiht="150">
</center>

我们首先遍历第一行和第二行元素，比较他们的第一列元素。我们发现此时它们相同，我们就要接着比较第二列元素。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/955/2018_12_17_2.png" width="150" hegiht="150">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/955/2018_12_17_3.png" width="100" hegiht="100">
</center>

我们发现对于第二列的元素，第一行的`g`比第二行的`f`大，所以我们要删除这一列，我们将其记录到一个`set`中。接着我们继续看第三列元素。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/955/2018_12_17_4.png" width="150" hegiht="150">
</center>

我们发现第三列元素符合字典序，所我们第一轮遍历结束。我们接着看第二行和第三行。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/955/2018_12_17_5.png" width="150" hegiht="150">
</center>

我们发现此时已经满足字典序，并且第二行元素比第三行小，所以我们可以不用再向后比较了。我们最后只要返回我们记录的`set`的大小即可。

```python
class Solution:
    def minDeletionSize(self, A):
        """
        :type A: List[str]
        :rtype: int
        """
        d = set()
        row, col = len(A), len(A[0])
        i = 1
        while i < row:
            for j in range(col):
                if j in d or A[i-1][j] == A[i][j]:
                    continue
                if A[i-1][j] > A[i][j]:
                    d.add(j)
                    i = 0
                    
                break
            i += 1
                
        return len(d)
```

我们还有一个更好的思路，通过记录之前列的排序状态。我们首先将状态初始化为`False`

我们首先看第一列的元素

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/955/2018_12_17_11.png" width="150" hegiht="150">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/955/2018_12_17_13.png" width="100" hegiht="100">
</center>

我们发现已经全部按照字典序排列了，所以我们接着看第二列，并且我们需要记录第一列的排序状态。`x==x`，我们也将其记录为`False`（因为我们要考虑后续列的状态），接着`x<y`，所以我们要记录为`True`。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/955/2018_12_17_12.png" width="150" hegiht="150">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/955/2018_12_17_16.png" width="100" hegiht="100">
</center>

我们发现第二列的第一行和第二行元素不满足字典序，所以我们要删除这一列，不用再检查后面行的元素了。我们接着看第三列

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/955/2018_12_17_14.png" width="150" hegiht="150">
</center>

我们首先看前两个元素，我们发现排好序了，所以我们接着看后两个元素。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/955/2018_12_17_15.png" width="150" hegiht="150">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/955/2018_12_17_17.png" width="100" hegiht="100">
</center>

我们发现后两个元素没有排好序，所以这个时候我们要看前面一个**没有删除的列**的情况（这里就是第一列），来考虑当前列要不要删除。我们可以从`type`中知道前面是`True`，也就是说前面一列当前行的位置已经排好序了，所以我们当前列也不用删除。此时我们要更新排序状态。

```python
class Solution:
    def minDeletionSize(self, A):
        """
        :type A: List[str]
        :rtype: int
        """
        row, col = len(A), len(A[0])
        res = 0
        s = [False]*(row - 1)
        for j in range(col):
            i = 0
            while i < row - 1:
                if not s[i] and A[i][j] > A[i + 1][j]:
                    res += 1
                    break
                i += 1
                    
            if i < row - 1:
                continue
                
            i = 0
            while i < row - 1:
                if A[i][j] < A[i + 1][j]:
                    s[i] = True
                    
                i += 1
                    
        return res
```


reference:

https://leetcode.com/problems/delete-columns-to-make-sorted-ii/discuss/203182/JavaC++Python-Greedy-Solution-O(MN)

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**