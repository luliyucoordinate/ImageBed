---
layout: post
title: 棋盘缺一角问题
category : 算法
tags : [python, 算法]
stickie: true
date: 2018-03-04 00:00:00
---

问题的描述很简单，就是一个国际象棋的棋盘缺少一个方格。我们能否使用右边`L`的图案拼出左边这种棋盘（并且右边的图形不可以重叠）

<center class="half">
<img src="http://wx1.sinaimg.cn/mw690/af2d2659ly1fp0wq71yp3j20bh0b1t9h.jpg"  width="300">
<img src="http://wx2.sinaimg.cn/mw690/af2d2659ly1fp0wqb5qwnj203g036mx1.jpg" width="80">
</center>

这是一道智力测试题，但是我们可以通过程序非常简洁的处理这个问题。

首先，我们希望问题的规模缩小，我们首先将棋盘分成四个部分

<center class="center">
<img src="http://wx3.sinaimg.cn/mw690/af2d2659ly1fp0x4k3ijdj20fd0emwee.jpg"  width="300">
</center>

这个时候问题出现了，有一个小部分和其他部分不同，这对我们很不利，但是可以这样考虑

<center class="center">
<img src="http://wx4.sinaimg.cn/mw690/af2d2659ly1fp0x8qakwsj20e30dka9y.jpg"  width="300">
</center>

我们发现将棋盘中间挖去一个`L`型，就变成了四个相同的 “缺一个角的小棋盘” 。这就很好了！我们把问题的规模变小了。

通过上述规律推导，不难发现，最后剩下的就是`L`图型。

最后我们整理一下思路

```python
def cover(board, lab=1, top=0, left=0, side=None):
    if side is None:
        side = len(board)
    s = side // 2
    offsets = (0, -1), (side - 1, 0)
    for y_outer, y_inner in offsets:
        for x_outer, x_inner in offsets:
            if board[top + y_outer][left + x_outer] == 0:
                board[top + s + y_inner][left + s + x_inner] = lab
                
    lab += 1
    if s > 1:
        for y in [0, s]:
            for x in [0, s]:
                lab = cover(board, lab, top + y, left + x, s)
                
    return lab

board = [[0]*8 for i in range(8)]
board[7][7] = -1
cover(board)
for row in board:
    print((" %2d"*8) % tuple(row))
```

结果就是

```python
  3  3  4  4  8  8  9  9
  3  2  2  4  8  7  7  9
  5  2  6  6 10 10  7 11
  5  5  6  1  1 10 11 11
 13 13 14  1 18 18 19 19
 13 12 14 14 18 17 17 19
 15 12 12 16 20 17 21 21
 15 15 16 16 20 20 21 -1
```

