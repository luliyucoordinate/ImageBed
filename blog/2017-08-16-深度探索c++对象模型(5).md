---
layout: post
title: 深度探索c++对象模型(5)
category : cpp
tags : [cpp]
stickie: true
---

关于虚拟构造函数
---


```c++
class Base1
{
public:
	Base1();
	virtual ~Base1();
	virtual void speakClearly();
	virtual Base1 *clone() const; //函数的返回类型是类本身
protected:
	float data_Base1;
};
class Base2
{
public:
	Base2();
	virtual ~Base2();
	virtual void mumble();
	virtual Base2 *clone() const; //函数的返回类型是类本身
protected:
	float data_Base2;
};
class Deriverd : public Base1, public Base2
{
public:
	virtual ~Deriverd();
	virtual Deriverd *clone() const;//函数的返回类型是类本身
protected:
	float data_Derived;
};
```

通过之前的[调试技巧](http://www.coordinate.wang/cpp/2017/08/07/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B(4).html)我们可以得到

```
1>  class Base1	size(8):
1>  	+---
1>   0	| {vfptr}
1>   4	| data_Base1
1>  	+---
1>
1>  Base1::$vftable@:
1>  	| &Base1_meta
1>  	|  0
1>   0	| &Base1::{dtor}
1>   1	| &Base1::speakClearly
1>   2	| &Base1::clone
1>
1>  Base1::{dtor} this adjustor: 0
1>  Base1::speakClearly this adjustor: 0
1>  Base1::clone this adjustor: 0
1>  Base1::__delDtor this adjustor: 0
1>  Base1::__vecDelDtor this adjustor: 0
1>
1>  class Base2	size(8):
1>  	+---
1>   0	| {vfptr}
1>   4	| data_Base2
1>  	+---
1>
1>  Base2::$vftable@:
1>  	| &Base2_meta
1>  	|  0
1>   0	| &Base2::{dtor}
1>   1	| &Base2::mumble
1>   2	| &Base2::clone        
1>
1>  Base2::{dtor} this adjustor: 0
1>  Base2::mumble this adjustor: 0
1>  Base2::clone this adjustor: 0
1>  Base2::__delDtor this adjustor: 0
1>  Base2::__vecDelDtor this adjustor: 0
1>
1>  class Deriverd	size(20):
1>  	+---
1>   0	| +--- (base class Base1)
1>   0	| | {vfptr}
1>   4	| | data_Base1
1>  	| +---
1>   8	| +--- (base class Base2)
1>   8	| | {vfptr}
1>  12	| | data_Base2
1>  	| +---
1>  16	| data_Derived
1>  	+---
1>
1>  Deriverd::$vftable@Base1@:
1>  	| &Deriverd_meta
1>  	|  0
1>   0	| &Deriverd::{dtor}
1>   1	| &Base1::speakClearly
1>   2	| &Deriverd::clone //注意一下这里，在Lippman的对象模型书里面在这下面有一个Base2::mumble
1>
1>  Deriverd::$vftable@Base2@:
1>  	| -8
1>   0	| &thunk: this-=8; goto Deriverd::{dtor}
1>   1	| &Base2::mumble
1>   2	| &thunk: this-=8; goto Base2* Deriverd::clone
1>   3	| &thunk: this-=8; goto Deriverd* Deriverd::clone
1>
1>  Deriverd::{dtor} this adjustor: 0
1>  Deriverd::clone this adjustor: 0
1>  Deriverd::__delDtor this adjustor: 0
1>  Deriverd::__vecDelDtor this adjustor: 0
```

我们可以从上面的 `Deriverd::$vftable@Base2@` 可以看到里面使用了 `thunk` 的技法。

如果我们通过如下的方式调用

```c++
Base2 *pb1 = new Derived;
Base2 *pb2 = pb1->clone();
```
当进行 `pb1->clone()` 时，会被调用指向 `Deriverd` 对象的起始地址，于是 `clone()`  的 `Derived` 版会被调用，它会传回一个指针，指向一个新的 `Derived` 对象，该对象的地址在被指定给pb2之前，必须先经过调整，以指向 `Base2subobject` 