---
layout: post
title: linux Day8
category : linux
tags : [linux, thread, c, pipe]
stickie: true
---


后台程序向屏幕输出
===

1.  创建fifo文件
2.  执行以下程序
```c++
int signal1(int signo, void (*func)(int)){
       structsigaction act, oact;
       act.sa_handler= func;
       sigemptyset(&act.sa_mask);
       act.sa_flags= 0;
       returnsigaction(signo, &act, &oact);
}

 
void setdaemon(){
       pid_tpid, sid;
       pid= fork();
       if(pid== -1){
              printf("forkerrpr %s\n",strerror(errno));
              exit(0);
       }
       if(pid== 0){
              if((sid= setsid()) < 0){
                     printf("setsiderror %s\n", strerror(errno));
                     exit(0);
              }
       }
       if(pid> 0){
              exit(0);
       }
}
void listenfifo(){
		const char * sfifoname = "fifo1";
       intlen = 0;
       charbuf[128];
       memset(buf,0, sizeof(buf));
       intfd = open(sfifoname, O_RDONLY);
       if(fd== -1){
              printf("open%s failed, %s\n", sfifoname, strerror(errno));
       }
       len= read(fd, buf, sizeof(buf));
       if(len> 0){
              if(buf[strlen(buf)- 1] == '\n'){
                     buf[strlen(buf)- 1] = 0;
              }
              close(STDOUT_FILENO);
              open(buf,O_WRONLY);
       }
       close(fd);
}
void catch_Signal(int Sign){
       switch(Sign){
       caseSIGINT:
              listenfifo();
              break;
       }
}
int main(void){
       setdaemon();
       signal1(SIGINT,catch_Signal);
       while(1){
              puts("!!!helloworld!!!");
              sleep(1);
       }
       return0;
}
1、 关闭当前窗口，让其后台执行，打开一个新的终端，找到其PID
2、 执行kill –s 2 PID
tty > fifo1
```


进程与线程
===

进程是一个实体。每个进程又自己的内存段。进程是执行中的程序。  
每个程序至少有一个线程，同一时间只能做一件事，多线程可以同一时间做多件事情。  
线程包含进程内执行环境必须的信息，包括线程ID，一组寄存器值，栈，调度优先级和策略，信号屏蔽字，errno变量以及线程私有数据。  
进程内的所有信息对于线程都是共享的，包括代码，全局变量和堆内存，栈以及文件描述符。  
线程标识  
进程ID用pid_t表示，他是一个unsign int  
线程ID用pthread_t表示，pthread_t不能把它当成整数处理  
可以通过pthread_self()函数获自身的线程ID



线程创建
===

进程中只有一个控制线程，程序开始运行的时候每个进程只有一个线程，它以单线程方式启动的，在创建多线程以前，进程的行为与传统进程没有区别。  
gcc在连接时需要加-lpthread选项

```c++
<pthread.h>
Int pthread_create(pthread_t *thread,constpthread_attr_t *attr, void
 *(*start_routine)(void*),void *arg);
 ```

如果pthread_create成功返回，由thread指向的内存单元被设置为新创建线程的线程ID  
Attr用于定制各种不同的线程属性  
新创建的线程从start_rtn函数地址开始执行，该函数中有一个void *参数  ，如果需要向start_rtn函数传多个参数，就需要把这些参数放到一个结构中，然后把这个结构的地址作为void *传入。线程创建的时候不能保证那个先运行。  
pthread  
函数成功返回0。



线程调用
===

进程终止  
任意线程调用exit函数，整个进程都会终止。  
如果信号默认动作时终止进程，那么信号发送到该进程，整个进程也会被终止。

单个线程通过以下三种方式退出  
1.  线程只是从启动函数返回，返回值是现成的退出码
2.  线程可以被同一进程中的其他线程取消
3.  调用pthread_exit函数

```
void pthread_exit(void *arg);
```
arg是一个无类型指针，该指针会被其它线程调用
  
pthread_join捕捉

```c
int pthread_join(pthread_t th, void **thr_return)
```
pthread_join函数用于挂起当前进程，直到th指定的线程终止  
如果另一个线程返回值不是NULL，则保存在thr_return地址中  
一个线程所使用的内存资源在应用pthread_join调用之前不会被重新分配，所以每个线程必须调用一次pthread_join函数  
其他线程不能对同一线程再应用pthread_join调用

```c
int pthread_detach(pthread_t th);
```
pthread_detach函数使线程处于分离状态  
对于被分离状态的线程，不需要调用pthread_join，如果其他线程调用pthread_join失败，返回EINVAL。  
如果不等待一个线程，同时对现成的返回值不感兴趣，可以设置这个线程为被分离状态，让系统在线程退出时自动回收他所占的资源。  
一个线程不能自己调用pthread_detach改变自己被分离状态，只有其他线程调用

```c
int pthread_cancel(pthread_t th)
```
pthread_cancel函数允许一个线程取消th指定的另一个线程，函数成功返回0，否则返回非0。

```c
int pthread_equal(pthread_t th1, pthread_t th2);
```
判断两个线程是否相同，相同返回非零值，不同返回0。因为pthread_t不是整数类型，所以不能用符号比较。



线程属性
===

使用pthread_attr_t结构修改线程默认属性，并把这些属性与创建线程联系起来  
可以使用pthread_attr_init函数初始化pthread_attr_t结构。  
调用pthread_attr_init以后，pthread_arrt_t的结构所包含的内容就是操作系统实现支持线程所有属性的默认值。  
如果需要修改其中个别属性的值，需要调用其他函数。

```c
int pthread_attr_destory(pthread_attr_t *attr);
int pthread_attr_init(pthread_attr_t *attr);
```
函数pthread_attr_init初始化attr结构  
函数pthread_attr_destory释放attr内存空间  
pthread_attr_t的结构对于应用程序来讲是不透明的，应用程序不需要了解有关结构的内部组成。  
对于pthread_detach这个函数可以在创建时设置。

```c
int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
```
通过这个函数设置分离状态还是正常状态。


线程同步
===

线程共享进程的内存空间，打开文件描述符，全局变量。  
当有多个线程同时访问一块内存空间或者一个变量、一个文件描述符，如果不加控制，那么会有意外发生。


互斥（mutex）
===

互斥指相互排斥，是一个锁或者信号灯。  
互斥用来保护多个线程共享的数据和结构不会被同时修改，一个互斥锁只能有两种状态unlocked和locked。  
任何时刻只能有一个线程来掌握某个互斥上锁。（原子操作）  
一个线程如果试图在一个已经加锁的互斥上再加锁，这个线程会被挂起，直到加锁的线程释放互斥锁为止。  

```c
pthread_mutes_t mutes = PTHREAD_MUTEX_INITIALIZER；初始化全局变量
int pthread_mutes_lock(pthread_mutex_t *mutex);    上锁
int pthread_mutex_unlock(pthread_mutex_t *mutex);  解锁
```

积累
===

ps –eLf                        查看线程  
gdb –q+执行文件core文件         调试代码

