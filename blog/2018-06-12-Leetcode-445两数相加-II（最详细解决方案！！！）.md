---
layout: post
title: Leetcode 445:两数相加 II（最详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-06-12 00:00:00
---

给定两个**非空**链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。

你可以假设除了数字 0 之外，这两个数字都不会以零开头。

**进阶:**

如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。

**示例:**

```
输入: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
输出: 7 -> 8 -> 0 -> 7
```

**解题思路**

由于这个问题和[Leetcode 2:两数相加（最详细解决方案！！！）](http://blog.csdn.net/qq_17550379/article/details/80435080)这篇文章中的问题类似，我们可以先将输入的链表`reverse`然后调用前面那个问题的算法，然后再将结果`reverse`即可。链表的反转操作看这篇[Leetcode 206:反转链表（最详细解决方案！！！）](http://blog.csdn.net/qq_17550379/article/details/80647926)。

但是这里的**进阶**选项中提到**不能修改链表**，那么要怎么做呢？

我们可以通过`栈`来实现，我们首先要建立三个`栈`，分别用来存储`l1`、`l2`和结果。两数加法部分依旧是通过之前那篇文章中的操作完成。

```python
class Solution:
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        stack_list1, stack_list2, stack_list3 = list(), list(), list()
        h = ListNode(-1)
        cur = h

        while l1 != None:
            stack_list1.append(l1.val)
            l1 = l1.next

        while l2 != None:
            stack_list2.append(l2.val)
            l2 = l2.next

        add = 0
        while stack_list1 or stack_list2 or add:
            if stack_list1:
                top1 = stack_list1.pop()
            else:
                top1 = 0
            if stack_list2:
                top2 = stack_list2.pop()
            else:
                top2 = 0
            val = top1 + top2 + add
            add = val // 10
            stack_list3.append(val%10)

        while stack_list3:
            cur.next = ListNode(stack_list3.pop())
            cur = cur.next

        return h.next 
```

这里我们还有一种做法就是通过两个

```
s1          f1    
7   2   4   3
s2          f2
5   6   4   null
```

接着

```
   cur  s1         f1    
h   7   2   4   3  null

s2          f2
5   6   4   null
```



**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**