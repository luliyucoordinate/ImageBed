---
layout: post
title: Leetcode 1012：至少有 1 位重复的数字（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-3-19 00:00:00
---

给定正整数 `N`，返回小于等于 `N` 且具有至少 1 位重复数字的正整数。

**示例 1：**

```
输入：20
输出：1
解释：具有至少 1 位重复数字的正数（<= 20）只有 11 。
```

**示例 2：**

```
输入：100
输出：10
解释：具有至少 1 位重复数字的正数（<= 100）有 11，22，33，44，55，66，77，88，99 和 100 。
```

**示例 3：**

```
输入：1000
输出：262 
```

**提示：**

1. `1 <= N <= 10^9`

**解题思路**

这个问题和之前的问题很类似

[Leetcode 788：旋转数字（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/88647103)

[Leetcode 902：最大为 N 的数字组合（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/88657235)

我们首先将问题转换为**包含不重复位的数**有多少个。对于输入数，例如`1234`，我们首先计算`[0,999]`，我们可以将它拆分为`[10,99]`和`[100,999]`来考虑。对于`[10,99]`，其第一位有`9`种选法（`1~9`），第二位要与第一位不同有`9`种选法，所以总共有`9x9=81`种。对于`[100,999]`，第一位有`9`种选法，第二位和第三位有$A_9^2$中选法（也就是`9`个数中取两个数），也就是`9x9x8=648`。

接着思考`[1000, 1199]`内有多少个元素？第二位要和第一位不同，所以有`1`种选法，第二位和第三位有$A_8^2$中选法（也就是`9`个数中取两个数），所以总共有`1x8x7=56`。同理接着计算`[1200,1229]`，`[1230,1233]`和`1234`。结果总共是`803`，也就是`1234-803=431`。

我们还有一些边界问题没有考虑，例如对于`1123`，此时当我们遍历到第二个位置的时候，我们发现`1`在前面已经出现过了，所以我们此时直接返回当前的结果就可以了。

```python
class Solution:
    def numDupDigitsAtMostN(self, N: int) -> int:
        L = list(map(int, str(N + 1)))
        res, n = 0, len(L)

        def A(m, n):
            return 1 if n == 0 else A(m, n - 1) * (m - n + 1)

        for i in range(1, n): 
            res += 9 * A(9, i - 1)
            
        seen = set()
        for i, x in enumerate(L):
            tmp = sum(y not in seen for y in range(0 if i else 1, x))
            res += tmp*A(9 - i, n - i - 1)
            if x in seen: 
                break
            seen.add(x)
        return N - res
```

上面的过程使用了`trick`也就是`N+1`的方式，这样我们就不用将最后的整个数单独考虑（例子中的`1234`）。或者也可以用之前的写法，通过`len(set(L))==len(L)`判断是不是满足条件即可。

reference:

https://leetcode.com/problems/numbers-with-repeated-digits/discuss/256725/JavaPython-Count-the-Number-Without-Repeated-Digit

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**