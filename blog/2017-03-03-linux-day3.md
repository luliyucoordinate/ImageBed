---
layout: post
title: linux Day3
category : linux
tags : [linux]
stickie: true
---


修改文件后要让文件生效
. 文件

调试gdb
===

gdb 文件 core文件  
gdb &ndash;q 文件 core文件       关闭无用信息

gdb                             文件  
run                             在gdb下运行  
where                           显示出错的代码  
list                            显示出错代码的上下  
print                           显示变量的值  
break                           设置断点  +行号/+函数名/+文件名：行号or函数名  
continue                        从断点后继续执行  
delete                          删除一个断点  
info break                      查看断点  
quit                            推出调试  
set variable varname = value    设置变量的值  
step                            单步进入函数  
next                            当遇到函数时，函数当成一条语句  
return+数据                      停止当前函数，数据为返回值

Stack 栈
===

```c
int abc(int a,int b){
        return a + b;
}
```
_stdcall   Pascal默认调用函数方式  
函数从右向左压入栈  
函数参数由被调用者压入或弹出栈

```c
int _attribute_((stdcall)) abc(int a,int b)
```
_cdecl    c/c++默认调用函数方式  
函数从右向左压入栈  
函数参数由被调用者压入或弹出栈

```c
int _attribute_((cdecl)) abc(int a,int b)
```

如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。  
如果用delete释放“malloc申请的动态内存”，结果也会导致程序出错，但是该程序的可读性很差。  
所以new/delete必须配对使用，malloc/free也一样。  
看看《Effective C++》这个吧。  
摘一段：  
把new和delete 与malloc和 free混在一起用也是个坏想法。  
对一个用new获取来的指针调用 free，或者对一个用 malloc 获取来的指针调用 delete，其后果是不可预测的。大家都知道&ldquo;不可预测&rdquo;的意思：它可能在开发阶段工作良好，在测试阶段工作良好，但也可能会最后在你最重要的客户的脸上爆炸。

内存分配
===

calloc(sizeof(data type),num)    分配内存并置零  
realloc 分配的内存连续，如果不够，会找个新内存，把copy过去  
realloc不初始化  
不要用悬空指针

```c
char *s = NULL; free(s); s = NULL;释放完再置为空
```


不建议使用scanf，无法输入空格，不检测越界问题

```c
#include <stdio.h>
#include <stdlib.h>
int main()
{
    char *longNum1 = (char*)malloc(10);
    char *longNum2 =  (char*)malloc(10);
    scanf("%9s",longNum1);
    scanf("%9s",longNum2);
    printf("%s\n",longNum1);
    printf("%s\n",longNum2);
    return 0;
}
```
用read(STDIN_FILENO，buf, sizeof(buf))  
标准输入（standard input）的文件描述符是 0，标准输出（standard output）是 1，标准错误（standard error）是 2。

open
===

open(file, flags)  
Flags:O_RDONLY,O_WRONLY,O_RDWR,O_CREAT,O_APPEND  
成功后返回一个文件描述符  
open失败后会返回-1，并设置errno变量  
close()   关闭  

tty     查看屏幕位置  
file+文件 查看文件类型  
cat abc.cpp &gt; a.txt 将abc的结果 输出到a.txt  
chmod 000 file 修改权限 000 expression permission denied  
sleep(1) 延迟1s  
usleep() 微秒
