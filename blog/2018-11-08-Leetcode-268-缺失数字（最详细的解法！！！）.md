---
layout: post
title: Leetcode 268：缺失数字（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-08 00:00:00
---

给定一个包含 `0, 1, 2, ..., n` 中 *n* 个数的序列，找出 0 .. *n* 中没有出现在序列中的那个数。

**示例 1:**

```
输入: [3,0,1]
输出: 2
```

**示例 2:**

```
输入: [9,6,4,2,3,5,7,0,1]
输出: 8
```

**说明:**
你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?

**解题思路**

我们首先想到的方法是建立一个数组，然后将所以元素放进去，然后遍历数组看那个数不在即可，例如

```
nums: 3  0  1
0  1  2  3
1  1  0  1
```

但是题目要求我们不适用额外的空间，所以我们这个方案就不能使用了。我们还可以怎么做呢？我们可以将所以数加起来得到一个**缺失一个数字的和**，如果我们不缺任何数字的话，所有数组的和应该是$(1+n)n/2$。所以根据二者之差就可以得到结果

```python
class Solution:
    def missingNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        return n*(n+1)// 2 - sum(nums)
```

还有一种做法是使用`xor`，我们知道`a^b^b=a`，类似于**消除游戏**的感觉O(∩_∩)O~。所以我们对于`nums`中的所有数都做这种操作，最后剩下的没有消除的元素就是我们缺失的。

```python
class Solution:
    def missingNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = len(nums)
        for i in range(len(nums)):
            result = result^i^nums[i]

        return result
```

reference:

https://leetcode.com/problems/missing-number/discuss/69832/1+-lines-Ruby-Python-Java-C++

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**