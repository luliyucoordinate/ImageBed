---
layout: post
title: Leetcode 5：最长回文子串（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-11 00:00:00
---

给定一个字符串 **s**，找到 **s** 中最长的回文子串。你可以假设 **s** 的最大长度为1000。

**示例 1：**

```
输入: "babad"
输出: "bab"
注意: "aba"也是一个有效答案。
```

**示例 2：**

```
输入: "cbbd"
输出: "bb"
```

**解题思路**

首先最简单的做法就是暴力解法，通过二重循环确定子串的范围，然后判断子串是不是回文，最后返回最长的回文子串即可。

```python
class Solution:
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        max_len, result = float("-inf"), ""
        for i in range(len(s)):
            for j in range(i+1, len(s)):
                if s[i:j] == s[i:j][::-1]:
                    if j-i > max_len:
                        max_len = j-i
                        result = s[i:j]
        return result
```

我们直接跳过它QAQ。这个问题很明显可以通过动态规划来解，我们看看转移方程是什么样的。

- $f(i,j)=f(i+1,j-1)\ \ s_i==s_j$
- $f(i,j)=1\ \ s_i==s_{i+1} \ \ and\ \  j == i+1$
- $f(i,j)=1\ \ i==j$

我们定义函数`f(i,j)`，判断`s[i,j]`这个区间内的字符串是不是回文串，其中`i`和`j`表示子串在`s`中的左右位置。

```python
class Solution:
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        if not s:
            return ""

        s_len = len(s)
        mem = [[0]*s_len for _ in range(s_len)]
        left, right, result_len = 0, 0, 0
        for j in range(s_len):
            for i in range(j):
                if s[i] == s[j] and (j-i < 2 or mem[i+1][j-1]):
                    mem[i][j] = 1
                if mem[i][j] and result_len < j-i+1:
                    result_len = j - i + 1
                    left, right = i, j
            
            mem[j][j] = 1

        return s[left:right+1]
```

这种算法的时间复杂度是`O(n^2)`级别同样空间复杂度也是`O(n^2)`级别，有没有更好的做法呢？我们知道回文串是中心对称的，所以我们知道找到回文串的中心，然后向两边扩展即可。这里的中心位置我们要奇偶分开考虑，如果字符串长度是奇数的话，中心就只有一个元素，如果字符串是偶数的话，那么中心是两个元素。

```python
class Solution:
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        if not s or len(s) < 1:
            return ""

        left, right = 0, 0
        for i in range(len(s)):
            len1 = self._expandAroundCenter(s, i, i)
            len2 = self._expandAroundCenter(s, i, i+1)
            max_len = max(len1, len2)
            if max_len > right - left:
                left = i - (max_len - 1)//2
                right = i + max_len//2

        return s[left:right+1]

    def _expandAroundCenter(self, s, left, right):
        L, R = left, right
        while L >= 0 and R <len(s) and s[L] == s[R]:
            L -= 1
            R += 1

        return R - L - 1
```

类似于这种思路，我们也可以假设遍历到的字符作为回文串的结尾，判断之前的字符串是不是回文串。

```python
class Solution:
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        if len(s) < 2 or s == s[::-1]:
            return s
        
        start, maxlength = 0, 1
        for i in range(len(s)):
            odd = s[i-maxlength-1:i+1]
            even = s[i-maxlength:i+1]    
            if i-maxlength-1 >= 0 and odd == odd[::-1]:
                start = i-maxlength-1
                maxlength += 2
            elif i-maxlength >= 0 and even == even[::-1]:
                start = i-maxlength
                maxlength += 1
        return s[start:start+maxlength]
```

但是这种写法明显比前面一种好，因为我们可以在判断的过程中记录`maxlength`，而这样我们就可以避免重复计算小于`maxlength`的字符串是不是回文。

这样我们的空间复杂度就优化到了常数级别。有没有更快的算法呢？有，使用[Manacher’s Algorithm超详细！！！](https://blog.csdn.net/qq_17550379/article/details/84022674)，类似的思想在`KMP`算法中也有应用。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**