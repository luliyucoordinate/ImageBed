---
layout: post
title: Leetcode 110：平衡二叉树（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-08-25 00:00:00
---

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过1。

**示例 1:**

给定二叉树 `[3,9,20,null,null,15,7]`

```
    3
   / \
  9  20
    /  \
   15   7
```

返回 `true` 。
**示例 2:**

给定二叉树 `[1,2,2,3,3,null,null,4,4]`

```
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```

返回 `false` 。

**解题思路**

对于这个问题，我们可以非常快的写出递归版本。当`root`为空的时候，我们将`None`也看成是一棵二叉树，所以返回`True`。接着我们判断`左子树高度`和`右子树高度`差是不是大于1，如果是，那么我们返回`False`就好啦。如果不是接着递归判断`左子树`和`右子树`是不是一棵平衡二叉树。

```python
class Solution:        
    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True

        def height(node):
            if not node:
                return 0

            return max(height(node.left), height(node.right)) + 1

        if abs(height(root.left) - height(root.right)) > 1:
            return False

        return self.isBalanced(root.left) and self.isBalanced(root.right)
```

但是如你所见，这个解法有一个很明显的弊端，就是我们在每次求`height`的时候有大量的重复运算，我们怎么可以避免这种重复运算呢？或者说我们有什么办法在遍历一遍树（求一次`height`）的过程中就可以得到答案呢？我们希望当左右子树中存在不平衡的时候就可以提前停止。

```python
class Solution:        
    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        def height(node):
            if not node:
                return 0

            left = height(node.left)
            right = height(node.right)
            if left == -1 or right == -1 or abs(left - right) > 1:
                return -1

            return max(left, right) + 1
        
        return height(root) != -1
```

上面这种解法非常的巧妙，当树出现不平衡的时候，我们令树的高度是`-1`。

同样的，对于可以用递归解决的问题，我们都应该思考一下怎么可以通过迭代去解决。那这个问题怎么通过迭代解决呢？我们可以先通过BFS得到一个list，然后从list的最后一个节点回退到root，并且计算节点的深度差，更新各节点深度。

```python
class Solution:        
    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        nodes = [root]
        for node in nodes:
            if node:
                nodes.extend([node.left, node.right])

        depths = {}
        nodes.reverse()
        for node in nodes:
            if node:
                if abs(depths.get(node.left, 0) - depths.get(node.right, 0)) > 1:
                    return False

                depths[node] = max(depths.get(node.left, 0), depths.get(node.right, 0)) + 1

        return True
```

我们也可以通过前序遍历的方式去更新节点的深度。但是这里的问题和之前的[Leetcode 144:二叉树的前序遍历（最优雅的解法！！！）](http://blog.csdn.net/qq_17550379/article/details/80731041)中有一些区别，之前的问题中是输出节点，而我们这里是要更新节点。所以我们不能直接将节点弹出，而是要保留到更新完节点后再弹出。这要怎么做呢？我们可以通过建立一个`tuple`包含一个`seen`信息，表示这个节点之前是不是访问过。如果访问过我们再将节点弹出，否则的话再将节点插回去。

```python
class Solution:        
    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        stack = list()
        stack.append((root, 0))
        depths = {}
        while stack:
            node, seen = stack.pop()
            if node:
                if not seen:
                    stack.extend([(node, 1), (node.right, 0), (node.left, 0)])
                if abs(depths.get(node.left,0) - depths.get(node.right,0)) > 1:
                    return False
                depths[node] = max(depths.get(node.left,0), depths.get(node.right,0)) + 1

        return True
```

依照这种思路，我们也可以写出`中序遍历`和`后序遍历`的版本。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**