---
layout: post
title: cpp通用工具(1)
category : cpp
tags : [cpp, notes, cpp标准库]
stickie: true
---


Pair 
===


构造函数与赋值
---
自C++11开始，如果pair<>用到了某个类型而该类型只有一个nonconstant copy构造函数，将会编译失败：

```c++
class A
{
	public:
	...
	A(A&);
}
std::pair<A,int> p;//ERROR since C++11
```


piecewise construction
---
```c++
class Foo
{
public:
	Foo(tuple<int,float>){}
	template<typename.. Args>
	Foo(Args... args){}
};
int mian()
{
	tuple<int,float> t(1,2.22);
	pair<int,Foo) p1(42,t);
	pair<int,Foo> p2(piecewise_construct, make_tuple(42),t);
}
```
只有当std::poecewise_construct被当作第一参数，class Foo才会被迫使用那个“接受tuple的元素而非tuple整体”的构造函数。这就意味着，在这个例子中被调用的是那个“实参数目不定的构造函数”。

make_pair
---
自C++11开始，可以使用<tuple>内的tie()接口，抽取出pair的value：

```c++
std::pair<char,char> p = std::make_pair('x','y');
char c;
std::tie(sstd::ignore,c) = p;//extra seconf value into c
```
c++standard明确指出，如果可能的话make_pair()使用move语义，否则就使用copy语义

Tuple
===


Tuple的操作
---
```c++
//create four-element tuple elements are initialized with default value
tuple <string,int,int,complex<double>> t;
//create and initialize a tuple explicitly
tuple <int,float,string> t1(41,6.3,"nico");
//create tuple with make_tuple
auto t2 = make_tuple(22,33,"nico");
//assignment
get<1>(t1) = get<1>(t2);
//cpmparsion
if(t1 < t2)
{
	t1 = t2;
}
```
运行期传入一个索引是不允许的

```c++
int i;
get<i>(t1);//ERROR 
```


tie
---
如果想最方便的在tuple中使用reference，可以使用tie，他可以建立一个内含reference的tuple：

```c++
std::tuple<int float,std::string> t(77,1.1,"move lisght");
int i;float f;
std::string s;
std::tie(i,f,s) = t;//assigns values of t to I,fand s
```
这里std::tie会将i、f和s的reference建立起一个tuple。等同于:

```c++
std::make_tuple(std::ref(i),std::ref(f),std::ref(s)) = t;
```
使用tie的时候，std::ignore允许我们忽略tuple的某些元素，也就是我们可以用它来局部提取tuple的元素值：

```c++
std::tuple<int float,std::string> t(77,1.1,"move lisght");
int i;
std::string s;
std::tie(i,std::ignore,s) = t;//assign first and third value of t to I and s
```


Initializer List
---
不可以将初值列传至“期望获得一个tuple”的地方

```c++
std::vector<std::tuple<int,float>> v{1,1.0};ERROR
std::tuple<int,int,int> foo(){return {1,2,3};}//ERROR
```
注意的是，上面的做法对于pair和array是可以的  
但是对于tuple，你必须明确的将初值转为一个tuple

```c++
std::vector<std::tuple<int,float>> v{std::make_tuple(1,1.0),
					std::make_tuple(2,2.0)};//OK
std::tuple<int,int,int> foo()
{
	return std::make_tuple(1,2,3);//OK
}
```


其他的tuple特性
---
tuple_size<tupletype>::value可获得元素个数  
tuple_element<idx,tupletype>::type可获得idx个元素的类型  
tuple_cat()可将多个tuple创成一个tuple  
tuple的输入输出  
tuple class 出公开于boost程序库，在那里tuple可以将元素写至ouput stream，但是C++标准库不支持。你可以使用一下头文件做支持：

```c++
//printtuple.hpp
#include<tuple>
#include <iostream>
template<int IDX,int MAX, typename... Args>
struct PRINT_TUPLE
{
	static void print(std::ostream& strm,const std::tuple<Args...>& t)
	{
		strm << std::get<IDX>(t) << (IDX + 1==MAX?"":",");
		PRINT_TUPLE<IDX+1, MAX, Args...>::print(strm, t);
	}
}
template<typename... Args>
ostream& operator<<(ostream& strm, const tuple<Args...>& t)
{
	strm << "[";
	PRINT_TUPLE<0,sizeof...(Args),Args...>::print(strm,t);
	return strm << "]";
}
template<int MAX, typename...Args>
struct PRINT_TUPLE<MAX, MAX, Args...>
{
	static void print (std::ostream& strm, const tuple<Args...>& t)
	{}
};
```
这文件在[cpp2.0新特性第二讲](http://www.coordinate.wang/cpp/2017/04/14/cpp2.0%E6%96%B0%E7%89%B9%E6%80%A72.html#处理first和last元素)中有提及


Class shared_ptr
===

多个shared_ptr可以共享同一个对象。对象的最后一个拥有着有责任销毁对象，并清除与该对象相关的所有资源。

使用shared_ptr
---
```c++
#include <memory>
shared_ptr<string> pNic(new string("nic"));
shared_ptr<string> pJut(new string("jut"));
```
由于“接受单一pointer作为唯一实参”的构造函数是explicit，所以这里不可以使用assign，那要被视为需要一个隐式转换。

```c++
shared_ptr<string> pNic = new string("nic");//ERROR
shared_ptr<string> pNic;
pNic.reset(new string(“nico”));//OK
shared_ptr<string> pJut {new string("jut")};//OK
```
也可以使用make_shared

```c++
shared_ptr<string> pNic = make_shared<string>(“nic”);
shared_ptr<string> pJut = make_shared<string>(“jut”);
```
这样做会比较安全

对于array
---
可以使用unique_ptr的辅助函数作为deleter，其内部调用delete[]:

```c++
std::shared_ptr<int> p(new int[10],
						std::default_delete<int[]>());
```
然而要注意的是，shared_ptr和unique_ptr以不同的方式处理deleter。例如unique_ptr允许你只传递对应元素类型作为template实参，对于shared_ptr就不可以：

```c++
std::unique_ptr<int[]> p(new int[10]);//OK
std::shared_ptr<int[]> p(new int[10]);//ERROR
```
此外对于unique_ptr，必须明确给第二个template实参，指出自己的deleter：

```c++
std::unique_ptr<int,void(*)(int*)> p(new int[10],
									[](int *p){ delete []p;});
```
还要注意的是shared_ptr不提供operator[]，但是unique_ptr可以。


Class weak_ptr
===

允许使用“共享但不拥有”的对象，这个class 会建立起一个shared_ptr。一旦最末尾一个拥有该对象的shared_ptr失去拥有全，任何weak_ptr都会自动成空。

使用 weak_ptr
---
```c++
class Person {
  public:
    string name;
    shared_ptr<Person> mother;
    shared_ptr<Person> father;
    vector<shared_ptr<Person>> kids;

    Person (const string& n,
            shared_ptr<Person> m = nullptr,
            shared_ptr<Person> f = nullptr)
     : name(n), mother(m), father(f) {
    }

    ~Person() {
      cout << "delete " << name << endl;
    }
};

shared_ptr<Person> initFamily (const string& name)
{
    shared_ptr<Person> mom(new Person(name+"'s mom")); 
    shared_ptr<Person> dad(new Person(name+"'s dad")); 
    shared_ptr<Person> kid(new Person(name,mom,dad)); 
    mom->kids.push_back(kid);
    dad->kids.push_back(kid);
    return kid;
}

int main()
{
    shared_ptr<Person> p = initFamily("nico");

    cout << "nico's family exists" << endl;
    cout << "- nico is shared " << p.use_count() << " times" << endl;
    cout << "- name of 1st kid of nico's mom: " 
         << p->mother->kids[0]->name << endl;

    p = initFamily("jim");
    cout << "jim's family exists" << endl;
}
```
每个person的析构函数都未被调用

```c++
class Person {
  public:
    string name;
    shared_ptr<Person> mother;
    shared_ptr<Person> father;
    vector<weak_ptr<Person>> kids;  // weak pointer !!!

    Person (const string& n,
            shared_ptr<Person> m = nullptr,
            shared_ptr<Person> f = nullptr)
     : name(n), mother(m), father(f) {
    }

    ~Person() {
      cout << "delete " << name << endl;
    }
};
```
这样做后。我们可以打破shared pointer形成的cycle，使得从kid到parent用的时shared pointer，而parent到kids使用的weak pointer。  
注意使用weak pointer时，我们必须用一下方式访问对象。不应该这样：

```c++
p->mother->kids[0]->name
```
必须是这样在式子内加上lock：

```c++
p->mother->kids[0].lock()->name
```


错误的使用shared pointer
---
shared_ptr多次引用同一数据，如下：

```c++
int* pInt = new int[100];
shared_ptr<int> sp1(pInt);
// 一些其它代码之后…
shared_ptr<int> sp2(pInt);
```
这种情况在实际中是很容易发生的，结果也是非常致命的，它会导致两次释放同一块内存，而破坏堆。  
使用shared_ptr包装this指针带来的问题，如下：

```c++
class tester 
{
public:
    tester()
    ~tester()
    {
        std::cout << "析构函数被调用!\n"; 
    }
public:
    shared_ptr<tester> sget()
    {
        return shared_ptr<tester>(this);
    }
};
int main()
{
    tester t;
	shared_ptr<tester> sp =  t.sget();
	return 0;
}
```
也将导致两次释放t对象破坏堆栈，一次是出栈时析构，一次就是shared_ptr析构。若有这种需要，可以使用下面代码。

```c++
class tester : public std::enable_shared_from_this<tester>
{
public:
    tester()
    ~tester()
    {
        std::cout << "析构函数被调用!\n"; 
    }
public:
    shared_ptr<tester> sget()
    {
        return shared_from_this();
    }
};

int main()
{
    shared_ptr<tester> sp(new tester);
    // 正确使用sp 指针。
    sp->sget();
    return 0;
}
```


Class unique_ptr
===

可确保一个对象和其相应资源同一时间之辈一个pointer占有。  
unique_ptr是“其所指对象”的唯一拥有者。当unique_ptr被销毁，其所指的对象也就自动销毁。unique_ptr的必要条件是，他指的对象只有一个拥有者。

```c++
#include<memory>
void f()
{
	std::unqiue<ClassA> ptr(new ClassA);
}
```
这样就够了，不需要delete语句和catch语句。如果是普通的指针的话，会出现这样的问题，可能会忘记delete对象，特别是如果你在函数中有个return语句。

使用unique_ptr
---
```c++
//create and initialize string
std::unique_ptr<std::string> up(new std::string("nico");
(*up)[0] = 'N';//replace first character
up->append("fjdk");//append some characters
std::cout << *up << std::endl;
```
此外你可以调用release,获得unique_ptr拥有的对象并放弃拥有权，于是调用者对该对象有了使用权：

```c++
std::unique_ptr<std::string> up(new std::string("nico");
std::string* sp = up.release();
```


转移unique_ptr的拥有权
---
不可以对unique_ptr执行copy和assign，如果你要的是寻常的copy语句。然而你可以使用move。这种情况下上述的copy构造函数或assignment操作符拥有权交给另一个unique_ptr。  
举个例子:

```c++
std::unique_ptr<ClassA> up1(new ClassA);
std::unique_ptr<ClassA> up2(up1);//ERROR
//transfer ownership  of the unique_ptr
std::unique_ptr<ClassA> up3(std::move(up1));//OK
assignment操作符的行为和上面所说的类似:
std::unique_ptr<ClassA> up1(new ClassA);
std::unique_ptr<ClassA> up2;
up2 = up1;//ERROR 
up2 = std::move(up1);//assign the unique_ptr
```
如果上述的复制动作之前up2原本拥有对象，会有一个delete动作被调用。删除该对象：

```c++
std::unique_ptr<ClassA> up1(new ClassA);
std::unique_ptr<ClassA> up2(new ClassA);
up2 = std::move(up1);//assign the unique_ptr
//delete object owned by up2
```


对于array
---
对于array应该是用delete[]而不是delete，所以下面的做法是错误的：

```c++
std::unique_ptr<std::string> up(new std::string[10]);
```
很幸运，C++标准可提供了一个派诺特话版本用来处理array，对该对象调用delete[]。  
你只要这样申明：

```c++
std::unique_ptr<std::string[]> up(new std::string[10]);
```
然而要注意的是，他不提供操作符*和->，提供[]，用于访问其所执行的array中的某个对象：

```c++
std::unique_ptr<std::string[]> up(new std::string[10]);
std::cout << *up << std::endl;//ERROR
std::cout << up[0] << std::endl;//OK
```


其他相应资源的deleter
---
当你所指向的对象要求的不只是delete或delete[]，你就只好自己制定deleter。但是与shared_ptr不同的是，你必须指定deleter的类型作为第二个template实参。该类型可以是reference to function，或是个function pointer或function object。如果是function object的话，其function call操作符()应该接受一个“指向对象”的pointer。

```c++
class ClassADeleter
{
public:
	void operator() (ClassA* p)
	{
		delete p;
	}
};
std::unique_ptr<ClassA,ClassADeleter> up(new ClassA());
```
如果你给的是个函数或lambda，你必须声明deleter的类型位void(*)(T*)或std::function<void(T*)>，要不就是使用decltype

```c++
std::unique_ptr<int,void(*)(int*)> up(new int[10],
					[](int* p)
					{
						...
						delete [] p;
					});
std::unique_ptr<int,std::function<void(int*)> up(new int[10],
						[](int* p)
						{
							...
							delete [] p;
						});
auto l = [](int *p)
			{
				...
				delete [] p;
			});
std::unique_ptr<int,decltype(l)> up(new int[10],l);
```
