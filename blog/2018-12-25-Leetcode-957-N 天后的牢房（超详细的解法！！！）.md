---
layout: post
title: Leetcode 957：N 天后的牢房（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-12-25 00:00:00
---

8 间牢房排成一排，每间牢房不是有人住就是空着。

每天，无论牢房是被占用或空置，都会根据以下规则进行更改：

- 如果一间牢房的两个相邻的房间都被占用或都是空的，那么该牢房就会被占用。
- 否则，它就会被空置。

（请注意，由于监狱中的牢房排成一行，所以行中的第一个和最后一个房间无法有两个相邻的房间。）

我们用以下方式描述监狱的当前状态：如果第 `i` 间牢房被占用，则 `cell[i]==1`，否则 `cell[i]==0`。

根据监狱的初始状态，在 `N` 天后返回监狱的状况（和上述 N 种变化）。

**示例 1：**

```
输入：cells = [0,1,0,1,1,0,0,1], N = 7
输出：[0,0,1,1,0,0,0,0]
解释：
下表概述了监狱每天的状况：
Day 0: [0, 1, 0, 1, 1, 0, 0, 1]
Day 1: [0, 1, 1, 0, 0, 0, 0, 0]
Day 2: [0, 0, 0, 0, 1, 1, 1, 0]
Day 3: [0, 1, 1, 0, 0, 1, 0, 0]
Day 4: [0, 0, 0, 0, 0, 1, 0, 0]
Day 5: [0, 1, 1, 1, 0, 1, 0, 0]
Day 6: [0, 0, 1, 0, 1, 1, 0, 0]
Day 7: [0, 0, 1, 1, 0, 0, 0, 0]
```

**示例 2：**

```
输入：cells = [1,0,0,1,0,0,1,0], N = 1000000000
输出：[0,0,1,1,1,1,1,0]
```

**提示：**

1. `cells.length == 8`
2. `cells[i]` 的值为 `0` 或 `1` 
3. `1 <= N <= 10^9`

**解题思路**

这是一个经典的细胞自动机问题，可以查看[Leetcode 289：生命游戏（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/83959020)。首先可以想到的解法就是暴力破解（直接按照题目的意思来就可以啦）

```python
class Solution:
    def prisonAfterNDays(self, cells, N):
        """
        :type cells: List[int]
        :type N: int
        :rtype: List[int]
        """
        tmp = [0]*8
        for _ in range(N):
            for i in range(1, 7):
                tmp[i] = int(cells[i-1] == cells[i+1])
                
            cells = tmp[::]
            
        return cells
```

我们可以将上面这种写法简化

```python
class Solution:
    def prisonAfterNDays(self, cells, N):
        """
        :type cells: List[int]
        :type N: int
        :rtype: List[int]
        """    
        for _ in range(N):
            cells = [0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in range(1, 7)] + [0]
        return cells
```

但是如果给定的`N`很大的话，那么这种做法就会超时，显然`N`到达一定的次数后，这个数组的值就开始重复了。所以我们可以建立一个变量`cycle`用于记录多少个重复值。当我们发现出现重复的时候（我们需要记录第一天的`cells`）我们就要将`k%=cycle`，然后继续运行剩余的值即可。

```python
class Solution:
    def prisonAfterNDays(self, cells, N):
        """
        :type cells: List[int]
        :type N: int
        :rtype: List[int]
        """
        source, tmp = None, [0]*8
        cycle, k = 0, N
        
        while k:
            for i in range(1, 7):
                tmp[i] = int(cells[i-1] == cells[i+1])
            
            if cycle == 0:
                source = tmp[::] 
            elif source == tmp:
                k %= cycle

            cells = tmp[::]
            cycle += 1
            k -= 1
        
        return cells
```

其实如果你发现这里的规律每`14`次重复，那么这个代码就可以简化为

```python
class Solution:
    def prisonAfterNDays(self, cells, N):
        """
        :type cells: List[int]
        :type N: int
        :rtype: List[int]
        """
        N = N % 14
        if not N:
            N = 14
            
        for _ in range(N):
            cells = [0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in range(1, 7)] + [0]
        return cells
```

使用之前问题中的编码方法对这个问题进行编码

- die <- die 00
- die <- live 01
- live <- die 10
- live <- live 11

```python
class Solution:
    def prisonAfterNDays(self, cells, N):
        """
        :type cells: List[int]
        :type N: int
        :rtype: List[int]
        """
        N = N % 14
        if not N: 
            N = 14
            
        for _ in range(N):
            for i in range(1, len(cells) - 1):
                if cells[i-1] & 1 == cells[i+1] & 1:
                    cells[i] = 2 if not cells[i] & 1 else 3
                    
            for i in range(len(cells)):
                cells[i] >>= 1
                
        return cells      
```

这样，我们的空间又得到了优化。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**