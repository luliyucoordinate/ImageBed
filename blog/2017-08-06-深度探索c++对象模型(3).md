---
layout: post
title: 深度探索c++对象模型(3)
category : cpp
tags : [cpp]
stickie: true
---


当一个类对象以另一个同类实体作为初值时，大部分情况下会调用拷贝构造函数。一般是这三种具体情况：

-  显式地以一个类对象作为另一个类对象的初值，形如X xx=x;
-  当类对象被作为参数交给函数时。
-  当函数返回一个类对象时。

后两种情形会产生一个临时对象。

如果一个类没有定义拷贝构造函数，通常按照“成员逐一初始化(Default Memberwise Initialization)”的手法来解决“一个类对象以另一个同类实体作为初值”——也就是说把内建或派生的数据成员从某一个对象拷贝到另一个对象身上，如果数据成员是一个对象，则递归使用“成员逐一初始化(Default Memberwise Initialization)”的手法。

对于默认的拷贝构造函数不会使用深拷贝，它只是使用浅拷贝（位逐次拷贝）。

有以下几种情况之一，位逐次拷贝将不能胜任或者不适合来完成“一个类对象以另一个同类实体作为初值”的工作。此时，如果类没有定义拷贝构造函数，那么编译器将必须为类合成一个拷贝构造函数。

-  当类内含一个成员对象，而后者的类声明有一个拷贝构造函数时（不论是设计者定义的还是编译器合成的）。
-  当类继承自一个声明有拷贝构造函数的类时（同样，不论这个拷贝构造函数是被显示声明还是由编译器合成的）。
-  类中声明有虚函数。
-  当类的派生串链中包含有一个或多个虚基类。

对于前两种情况，不论是基类还是对象成员，既然后者声明有拷贝构造函数时，就表明其类的设计者或者编译器希望以其声明的拷贝构造函数来完成“一个类对象以另一个同类实体作为初值”的工作，而设计者或编译器这样做——声明拷贝构造函数，总有它们的理由，而通常最直接的原因莫过于因为他们想要做一些额外的工作或“位逐次拷贝”无法胜任。对于有虚函数的类，如果两个对象的类型相同那么位逐次拷贝其实是可以胜任的。但问题将出在，如果基类由其继承类进行初始化时，此时若按照位逐次拷贝来完成这个工作，那么基类的vptr将指向其继承类的虚函数表，这将导致无法预料的后果——调用一个错误的虚函数实体是无法避免的，轻则带来程序崩溃，更糟糕的问题可能是这个错误被隐藏了。所以对于有虚函数的类编译器将会明确的使被初始化的对象的vptr指向正确的虚函数表。因此有虚函数的类没有声明拷贝构造函数，编译将为之合成一个，来完成上述工作，以及初始化各数据成员，声明有拷贝构造函数的话也会被插入完成上述工作的代码。

```c++
class Foo
{
public:
	int a;
	Foo *next;
	virtual void Func(void){cout<<"call Foo::func()"<<endl;}
};
class D:public Foo
{
public:
	int c;
	virtual void Func(void){cout<<"call D::func()"<<endl;}
};
int main(void)
{
	D d;
	Foo f=d;
	d.Func();	//call D::func()   
	f.Func();	//call Foo::func()
	system("pause");
	return 0;
}
```

当含有虚函数的时候，我们的类会有虚函数表，每个对象会有vptr。如果我们的基类只是简单的将子类的vptr值拷贝过来，显然是不符合要求的，于是这个时候编译器会给我们自动的停用bitwise拷贝，而用reset将基类的vptr指向基类的虚函数表。所以这个时候是达到了我们的要求的。我想说的是，其他值会按照默认的按位拷贝，只是vptr不会，还有我们下一个将讨论的也不会。

对于继承串链中有虚基类的情况，问题同样出现在继承类向基类提供初值的情况，此时位逐次拷贝有可能破坏对象中虚基类子对象的位置。

```c++
class Raccoon : public virtual ZooAnimal
{
public: 
	Raccoon() { /* private data initialization */ }
	Raccoon( int val ) { /* private data initialization */ }
	// ... private: // all necessary data
 };
class RedPanda : public Raccoon
{
public: 
	RedPanda() { /* private data initialization */ }
	RedPanda( int val ) { /* private data initialization */ }
	// ... private: // all necessary data
};
```

这里如果是两个一样的类的对象间进行拷贝，简单的按位拷贝就会解决问题，而我们的问题在于父类与子类之间的拷贝；

```c++
RedPanda   little_red; 
Raccoon    little_critter = little_red;
```

这个时候，编译器会在默认的拷贝构造函数中插入初始化指向虚基类的指针，而不是reset。



必须用到初始化列表的情况：

-  有const成员
-  有引用类型成员
-  调用一个基类的构造函数，这个构造函数拥有一组参数
-  调用一个成员对象的构造函数，这个构造函数拥有一组参数