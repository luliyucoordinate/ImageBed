---
layout: post
title: 理解C/C++语言的声明语法-声明子
category : cpp
tags : [cpp, notes]
stickie: true
---

转载自[dreamliner](http://www.cnblogs.com/dreamliner/archive/2009/06/10/1500827.html)的blog

声明
===
一些声明可能难以理解，特别是如果声明几个不同类型的名字或者那些指向函数指针的函数。例如在§10.1.1/171中，我们看到

```c++
int* p, q;
```
定义p为一个“整型指针”类型的对象，q为一个整型对象。在§10.1.2/173中，我们看到

```c++
double (*get_analysis_ptr())(const vector<Student_info>&);
```
声明get_analysis_ptr为一个函数，不带任何参数，它返回一个指针，它指向一个函数，它带有一个const vector<Student_info>&参数，返回double。你可以通过重写以清楚的表达这些声明的含义，例如

```c++
int* p;
int q;
```
和

```c++
// 定义analysis_fp为一个函数，它带一个const vector<Student_info>&参// 数，返回一个double类型。
typedef double (*analysis_fp)(const vector<Student_info>&);
analysis_fp get_analysis_ptr();
```
不幸的是，这种策略不会帮助你阅读其它程序员代码中令人迷惑的声明。  
一般，一个声明大致如下  
声明语句：声明说明符[声明子[初始化器]] [,声明子[初始化器]]...;  
它为每一个声明子声明一个名字。这些名字始于声明开始的地方终于声明作用域结束的地方。一些声明同时也是定义。名字可以声明多次，但是仅能定义一次。如果一个声明分配了存储空间或者定义了类或函数体，那么它也是一个定义。  
C++继承了C的声明语法。理解声明的关键是认识到每个声明包含两个部分：一系列声明说明符，它们一起说明一个类型和其它正在声明的特性，紧跟着是零个或多个声明子（每个声明子都可选的有一个关联的初始化器）。根据说明符和声明子的形式，每个声明子都为名字赋予一个类型。  
理解声明的第一步是定位说明符和声明子的边界。这很容易：所有的说明符都是关键字或者类型名，因此说明符终止于第一个不是以上类型之一的符号。  
例如，在

```c++
const char * const * const * cp;
```
很容易找到边界：double是一个类型，左括号后面既不是关键字也不是类型名。因此，声明—说明符只是double，声明子为声明的其它部分，不包含分号。

```c++
double (*get_analysis_ptr())(const vector<Student_info>&);
```
另一个例子，考虑§10.1.2/173中的声明：  
第一个既不是关键字也不是类型名的符号是*，因此说明符是const char，唯一的声明子* const * const * cp。

说明符（Specifiers）
---
我们可以将声明—说明符分成三个部分：类型说明符，存储类说明符，和其它说明符：  
声明说明符：{类型说明符|存储类说明符|其它声明说明符}  
然而，这种划分仅仅有助于理解，因为声明本身不存在对应的划分：声明—说明符可以以任何次序出现。  
类型说明符决定了声明的类型。我们在§A.2/299中讨论内置类型。

```
type-specifier: char | wchar_t | bool | short | int | long | signed
unsigned | float | double | void | type-name | const | volatile
type-name: class-name | enum-name | typedef-name
```
const说明符指出这种类型的对象不可以修改，volatile通知编译器变量可能以非语言定义的形式改变，应该避免优化。  
注意const既可以出现在说明符部分，这样修改类型，也可以出现在声明子部分，说明一个const指针。这没有任何歧义，因为声明子部分的const总是跟着一个*。  
存储类说明符决定变量的位置和生命周期：

```
storage-class-specifiers: register | static | extern | mutable
```
register说明符建议编译器通过将此对象放到寄存器中以优化性能。  
一般，局部变量在退出声明它们的块（block）时即被销毁；静态变量的值在作用域的入口和出口间会被保存起来。  
extern说明符表明当前的声明不是一个定义，隐含着在其它地方存在相应的定义。  
mutable存储类仅用于类的数据成员，并且允许修改这些数据成员即使它们是常量对象的成员。  
其它声明说明符定义了与类型无关的属性：

```
other-decl-specifier: friend | inline | virtual | typedef
```
friend说明符(§12.3.2/216 and §13.4.2/246)改写保护。  
内联说明符用于函数定义，提示编译器如果可能内联下面的代码。当展开调用时，函数定义必须出现在那个作用域，因此将内联函数体放到声明函数的头文件中通常是一个好主意。  
virtual说明符(§13.2.1/234)仅用于成员函数，表示这个函数是动态绑定的。  
typedef说明符(§3.2.2/43)定义类型的同义词。

声明子（Declarators）
---
一个声明为每个声明子都声明一个实体（entity）,同时为那个实体给出一个名字，并且隐含的给出存储类，类型，和由说明符给出的其它特性。说明符和声明子一起决定了名字是否是一个对象，数组，指针，引用或函数。例如，声明x为一个整型指针，f为一个函数返回一个整型。正是声明子*x和f()使类型x和f产生区别。

```
int *x, f();
declarator: [ * [ const ] | & ]... direct-declarator
direct-declarator: declarator-id | ( declarator ) |
direct-declarator ( parameter-declaration-list ) |
direct-declarator [ constant-expression ]
A declarator-id is an identifier, possibly qualified:
declarator-id: [ nested-name-specifier ] identifier
nested-name-specifier: { class-or-namespace-name ::}...
```
如果声明子是一个仅包含一个declarator-id的直接-声明子，那么这说明这个标识符具有decl-specifiers隐含的属性，而没有进一步的修饰。例如，在下面的声明中

```c++
int n;
```
声明子是n，这是一个只包含direct-declarator的declarator-id，因此根据含义，n的类型为整型。  
如果声明子为其它形式，那么你可以按照下面的方法确定标识符的类型：首先，假设T为decl-specifiers隐含的类型，忽略friend或static等非类型属性，同时假设D为声明子。然后重复下面的步骤直到推导出D为一个declarator-id，此时T正是你所寻找的类型：  
1.  如果D形如(D1)，那么用D1替换D。
2.  如果D形如* D1 或 * const D1，那么根据是否有const，用“指针，它指向T”或者“常量指针，它指向T”替换T，然后用D1替换D。
3.  如果D形如D1(参数-声明-列表)，那么用参数由参数-声明-列表定义的、“返回T的函数”替换T，然后用D1替换D。
4.  如果D形如D1[常量-表达式]，那么用元素个数由常量-表达式给出的“T数组”替换T，然后然后用D1替换D。
5.  最后，如果声明子形如&D，那么用“T引用”替换T，然后用D1替换D。
作为一个示例，考虑下面的声明

```c++
int *f();
```
首先，T和D分别为int和*f()，因此D形如*D1，其中D1为f()。  
你可能认为D可以形如D1() 或者 *D1。然而，如果D形如D1()，那么D1将不得不为*f，D1将是一个direct-declarator（因为本节开始处的语法注1规定只有direct-declarator前面是()）。但是如果我们看看direct-declarator的定义注2，很明显它不能包含*。因此，D只能是*f()，它形如*D1，其中D为f()。  
既然我们已经确定D1为f()，那么我们知道必须用“指针，它指向T”替换T，即“指针，指向整型”，同时用f()替换D。  
至此我们还没有解析D为declarator-id，因此我们必须重复该过程。此时，D1只能是f，因此我们用“返回T的函数”替换T，它是一个“返回整型指针不带参数的函数”，然后用f替换D。  
此时，D为declarator-id，因此推导结束。我们已经确定声明

```c++
int *f();
```
声明f的类型为“不带参数返回整型指针的函数”。另一个例子，声明

```c++
int* p, q;
```
具有两个声明子，*p和q。对于每个声明子，T都是int。对于第一个声明子，D是*p，因此T变成“指针，它指向整型，”而D为p。声明p类型为“指针，它指向整型”。  
我们单独分析第二个声明子，T还是int，D是q。很明显声明q为整型。  
最后，让我们分析§10.1.2/173中那个奇怪的例子:

```c++
double (*get_analysis_ptr())(const vector<Student_info>&);
```
分析过程可以分为下面五个步骤  
1.  T: double    D: (*get_analysis_ptr())(const vector<Student_info>&)
2.  T: 返回double带有 const vector<Student_info>& 参数的函数    D: (*get_analysis_ptr())
3.  T: function returning double... (如前所示)    D: *get_analysis_ptr()
4.  T: 指针，它指向一个返回double...的函数    D: get_analysis_ptr()
5.  T: 一个函数，返回一个函数指针，它指向一个返回double...的函数   D: get_analysis_ptr
get_analysis_ptr是一个函数，它返回一个函数指针，它指向一个返回double，带有const vector<Student_info>&参数的函数。我们将如何展开const vector<Student_info>&作为一个练习。幸运的是，很少有函数声明如此令人迷惑；它们中的大多数看起来

```
declarator: declarator-id ( parameter-declaration-list )
```
到目前为止，常见情况中最难的是返回函数指针的函数。  
注1：这里将allows翻译为规定而不是允许。因为如果翻译为允许，言外之意是()后面还可以是其它东西，但是在五条语法中找不到这种东西。语法指的是direct-declarator ( parameter-declaration-list )  
注2：“declarator: [ * [ const ] | & ]... direct-declarator”
