---
layout: post
title: Leetcode 943：最短超级串（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-23 00:00:00
---

给定一个字符串数组 `A`，找到以 `A` 中每个字符串作为子字符串的最短字符串。

我们可以假设 `A` 中没有字符串是 `A` 中另一个字符串的子字符串。 

**示例 1：**

```
输入：["alex","loves","leetcode"]
输出："alexlovesleetcode"
解释："alex"，"loves"，"leetcode" 的所有排列都会被接受。
```

**示例 2：**

```
输入：["catg","ctaagt","gcta","ttca","atgcatc"]
输出："gctaagttcatgcatc"
```

**提示：**

1. `1 <= A.length <= 12`
2. `1 <= A[i].length <= 20`

**解题思路**

这个问题非常简单，前提是你非常熟悉[Travelling Salesman Problem（旅行商问题）](https://blog.csdn.net/qq_17550379/article/details/84393587)，这个问题其实就是一个变相的旅行商问题。我们怎么把它转化为旅行商问题呢？我们首先要定义一种**距离**，用来描述两个字符串之间的差别。例如

```
gcta -> ctaagt
```

对于上面的示例，我们首先计算字符串`gcta`的结尾与`ctaagt`开头有多少元素是一样的，我们通过计算发现有三个。此时，我们就定义这两者之间的距离是`len(atgcatc)-3`，也就是如果`ctaagt`加到`gcta`后我们要增加的长度，我们遍历所有字符串，然后我们求出分别以此字符串出发最后回到此字符串的最短距离，那么这个最短的距离一定就是我们所需要的结果。

我们首先计算不同字符串之间的距离，添加到一个`graph`中去。然后通过`tsp`寻找以哪个字符串开始最后的结果是最短的，并且在此过程中我们要记录遍历字符串的顺序（我们通过`path`）。然后我们通过这个找到的头字符串，并且根据我们之前记录的`path`将所有字符串都合在一起就是我们最后的结果。

```python
class Solution:
    def shortestSuperstring(self, A):
        """
        :type A: List[str]
        :rtype: str
        """
        A_len = len(A)
        graph = [[0]*A_len for _ in range(A_len)]
        mem = [[-1]*A_len for _ in range(1 << A_len)]
        path = [[0]*A_len for _ in range(1 << A_len)]
        visited_all = (1 << A_len) - 1 

        def _calc(a, b):
            for i in range(1, len(a)):
                if len(a) - i <= len(b) and a[i:] == b[:len(a)-i]:
                    return len(b) - len(a) + i
            return len(b)

        for i in range(A_len):
            for j in range(A_len):
                if i == j:
                    continue
                graph[i][j] = _calc(A[i], A[j]) 

        def _tsp(mask, pos):
            if mask == visited_all:
                return 0
            if mem[mask][pos] != -1:
                return mem[mask][pos]

            result = float("inf")
            for i in range(A_len):
                if (1 << i) & mask:
                    continue
                newResult = graph[pos][i] + _tsp(mask | (1 << i), i)
                if result > newResult:
                    result = newResult
                    path[mask][pos] = i
            mem[mask][pos] = result
            return result

        ret, best = float("inf"), -1
        for i in range(A_len):
            cur = len(A[i]) + _tsp(1 << i, i)
            if ret > cur:
                ret = cur
                best = i
        
        mask = 1 << best
        result_str = A[best]
        while mask != visited_all:
            j = path[mask][best]
            result_str += A[j][len(A[j]) - graph[best][j]:]
            mask |= (1 << j)
            best = j

        return result_str
```

上面这个算法的思路非常清晰，但是显然不是最好的。还有一个比较好的思路就是贪心策略，我们首先从全部的字符串中找两两之间重叠最多的两个字符串，这两个字符串一定在最后的结果中。例如

```
"catg","ctaagt","gcta","ttca","atgcatc"
```

上述的字符串中重复最多的是`gcta`和`ctaagt`，所以我们可以将这两个元素合并，结果就是`gctaagt`，它一定在最后的结果中。现在我们就将这个合并过的字符串添加到我们的查找字符串中，并且我们要从`gcta`和`ctaagt`中去掉`ctaagt`。

```
"catg","gctaagt","ttca","atgcatc"
```

现在我们继续合并，也就是先找重复字符最多的两个字符串。此时我们发现`catg`和`atgcatc`重复最多，我们就将他俩合并，然后删除`atgatc`

```
"gctaagt","ttca","catgcatc"
```

以此类推。

```python
class Solution:
    def shortestSuperstring(self, A):
        """
        :type A: List[str]
        :rtype: str
        """
        def findOverlappingPair(s1, s2):
            max_overlap_len = float("-inf") 
            n = min(len(s1), len(s2))
            res = ''
            for i in range(1, n+1):
                if s1.endswith(s2[:i]):
                    if max_overlap_len < i:
                        max_overlap_len = i
                        res = s1 + s2[i:]
            for i in range(1, n+1):
                if s2.endswith(s1[:i]):
                    if max_overlap_len < i:
                        max_overlap_len = i
                        res = s2 + s1[i:]

            return max_overlap_len, res
        
        A_len = len(A)
        
        while A_len != 1:
            p, q = -1, -1
            res = ''
            max_val = float("-inf") 
            for i in range(A_len):
                for j in range(i+1, A_len):
                    r, tmp_res = findOverlappingPair(A[i], A[j])
                    if max_val < r:
                        max_val = r
                        res = tmp_res
                        p = j
                        q = i
            A_len -= 1
            if max_val == float("-inf"): 
                A[0] = A[0] + A[A_len]
            else:
                A[p] = res
                A[q] = A[A_len]
            
        return A[0]
```

reference:

https://leetcode.com/problems/find-the-shortest-superstring/discuss/194947/LeetCode-Weekly-Contest-111-screencast-(rank-12)

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**