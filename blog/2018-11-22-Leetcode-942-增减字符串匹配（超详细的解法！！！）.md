---
layout: post
title: Leetcode 942：增减字符串匹配（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-22 00:00:00
---

给定只含 `"I"`（增大）或 `"D"`（减小）的字符串 `S` ，令 `N = S.length`。

返回 `[0, 1, ..., N]` 的任意排列 `A` 使得对于所有 `i = 0, ..., N-1`，都有：

- 如果 `S[i] == "I"`，那么 `A[i] < A[i+1]`
- 如果 `S[i] == "D"`，那么 `A[i] > A[i+1]`

**示例 1：**

```
输出："IDID"
输出：[0,4,1,3,2]
```

**示例 2：**

```
输出："III"
输出：[0,1,2,3]
```

**示例 3：**

```
输出："DDI"
输出：[3,2,0,1]
```

**提示：**

1. `1 <= S.length <= 1000`
2. `S` 只包含字符 `"I"` 或 `"D"`。

**解题思路**

这个问题非常简单，我们可以通过分析例子得到这样的结论。每次`I`的前一个位置都是从最小值开始往上加一得到的，例如

```
 I D I D
0 4 1 3 2
↑   ↑
```

我们的第一个`I`前是`0`，而第二个`I`前是`1`。每次`I`的前一个位置都是从最大值开始往下减一得到的

```
 I D I D
0 4 1 3 2
  ↑   ↑
```

我们的第一个`D`是`4`，而我们的第二个`D`是`3`。最后我们只要将边界加入到这个结果数组中即可（也就是`2`，`2`可以从`I`或`D`得到）。

```python
class Solution:
    def diStringMatch(self, S):
        """
        :type S: str
        :rtype: List[int]
        """
        minv, maxv = 0, len(S)
        result = list()
        for ch in S:
            if ch == 'I':
                result.append(minv)
                minv += 1
            elif ch == 'D':
                result.append(maxv)
                maxv -= 1
        result.append(maxv)    
        return result
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**