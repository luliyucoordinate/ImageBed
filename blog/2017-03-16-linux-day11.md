---
layout: post
title: linux Day11
category : linux
tags : [linux, network, c, hook]
stickie: true
---

Windows hook
===

WH_KEYBOARD键盘钩子  
WH_MOUSE鼠标钩子  
WH_CALLWNDPROC窗口回掉函数钩子  

键盘hook消息说明  
wParam参数  
虚拟键盘代码：是一种与设备无关的键盘编码，在windows.h消息中定义，14表示caps lock建，11表示ctrl，12表示alt，8表示退格键  
lParam参数  
0-15位：用户按一个键的重复次数  
16-23位：给出OEM键盘扫描码  
24位：是否为增强键盘上的扩展键，1表示是，0表示否  
25-28位：保留  
29位：给出关联码，表示是否使用alt，如果使用为1  
30位：给出前一次敲击状态  
31位：给出转换状态，1：表示按键，2：表示放键  

鼠标hook消息说明  
wParam参数  
包含鼠标按键与键盘组合使用标记，用来识别鼠标按键和键盘按键上shift与ctrl键的组合状态  
lParam参数  
鼠标点坐标位置，低位表示横坐标，高位表示纵坐标，可以使用windows。h中的HIWORD和LOWORD这两个宏来获得这两个坐标


Shell
===

shell
---

当用户登录时，实际上是进入到一个shell的程序中


交互模式
---

Shell受到用户输入的指令后，就开始执行这个指令，并把结果显示到屏幕上，结束后shell又会显示系统提示符，等待用户输入下一个指令。


后台模式
---

后台运行的符号为&，在命令后面加上&符号，就可以将程序饭在后台执行。  
在后台中的程序通过fg命令调回前台  
程序已经在前台运行，执行ctrl+z就可以放入后台  
如果有多个进程在后台执行，执行jobs命令，能够列出所有后台进程，中括号中的数字就是jobs的代号，通过fg %number就可以恢复指定的后台进程。


输入输出重定向
---

通过><将标准输入输出重定向


管道
---

通过管道符号 | 完成一系列命令的顺序处理


通配符
---

通配符的作用是在处理文件的时候用通配符模糊匹配一个或多个字符


环境变量
---

Shell是一个很大的程序，为了使工作环境符合用户的习惯或者应用的需要，可以让用户设置shell使用环境变量  
Shell scripts  
Shell最重要的也是最负责的就是shell scrpits。Shell除了解释命令以外还有一个重要的功能就是程序设计语言，可以通过shell scripts进行程序设计，完成更加复杂的功能。


Shell变量
---

预定义变量：通常用户自行定义的特殊用途变量，有效返回限于定义变量的script中。  
环境变量：通常用来定义系统重要的设置，主要功能为提供程序执行时的参考。  
varName=value shell定义变量不需要定义变量类型，只需要=使用变量，变量名前加$，不加$表示字符串  
set查看所有已经设置的变量  
unset varName删除设置的变量  
环境变量使用export命令  
export varName=value  
env显示当前环境变量  
export –n varName删除设置的环境变量


环境变量的作用域
---

在.bash_profile中定义的变量在用户登陆后一直有效。  
在普通脚本文件中定义的变量只在脚本内部有效


几个常用的环境变量
---

PWD显示当前路径  
UID用户ID  
BASH_VERSION bash的版本号  
HOSTTYPE显示计算机平台  
OSTYPE显示操作系统种类  
PATH系统命令，文件查找路径  
HOME用户的home目录


bash设置文件
---
```shell
/etc/profile  
```
这是系统的shell设置文件，用户可以将系统最重要的环境变量定义到这个文件中

```shell
`/.bash_profile 
```
用户个人的bash设置文件，用户登录的时候bash就会读取该用户目录下的.bash_file文件  

```shell
`/.bashrc  
```
每次启动shell时都会读取这个文件  

```shell
#!  /bin/sh
a=5
b=3
echo a=$a
echo b=$b
if (test “$a” = “$b”) then 注意等号前后都有空格
	echo a=b
else
	echo a!=b
fi
```
#代表注释，出现！表示指定程序解析shell的命令，shell不需要编译  
$后面数字的话标识参数  
$i代表第i个参数，但是i不可以超过10(<10)如果超过10，shift能使引用数位移，如此就可以将引用过的数移掉  
$#代表参数个数  
$*代表所有参数  
$？上一个命令的返回值  
` `不是字符串而是shell指令，’ ‘and“ ”字符串  
PDATE=`date`  
expr用来取计算的结果，expr是一个命令可以直接使用，用的时候加参数  
expr 4 + 3  
var=`expr $a + $b`  注意+前后有空格


read命令用于从终端或文件读取输入
---

read命令读取输入一行，直至遇到换行  
行尾的换行符在读入时被转化为一个空字符  
如果read命令后有变量名，输入内容赋给该变量，如果read命令后未跟变量名，读入的行将被赋值给内置REPLY  
//用户输入两个数字，计算两个数字的和

```shell
#! /bin/sh
read a
echo 'a=' $a
read b
echo 'b=' $b
c=`expr $a + $b`
echo $c
```

if条件语句
---

if条件语句后test是一个固定关键字  
第二种

```shell
if [ -option expr ]; then
	commands
else
	commands
fi
```
-d file文件存在并且是个目录  
-e file文件存在  
-r file文件存在并且可读  
-w file文件存在并且可写  
-x file


while循环语句
---
```shell
while [ expr ];
do
	commands
done
```
expr为真时一直继续直到为假  
一个循环5次的例子

```shell
#! /bin/sh
times=0
while [ "$times" != "5" ];
do
        echo $times
        times=$[$times + 1]
done
```
case分支
case “string” in
pattern_1)
	commands
	;;相当于break
Pattern_2)
	commands
	;;
*)
	Commands
	;;
esac
当有条件语句中的string等于pattern字符串，执行pattern下面的指令  
当没有条件时，最后执行*)  
//多重分支的例子

```shell
#! /bin/sh
case "$1" in
start)
        echo "is start"
        ;;
stop)
        echo "is stop"
        ;;
*)
        echo "is nothing"
esac
```

for循环
---
```shell
for varname in list ;
do
commands
done
```
list可以是一串字符或数字  
for没执行一次循环就将varname指定为list中的一个值，直到list这个数组结束

```shell
#! /bin/sh
sum=0
for I in 1 2 3 4 5
do
sum=$[$sum + i]
echo $sum
done
```

exit语句
---

exit code 与C语言类似



:语句
---

代表空语句，本身没有任何作用，但又是合法语句，经常用来填补程序设计的空缺



自定义函数
---
```shell
function funname
{
	commands
}
```
例子

```shell
function func
{
	echo “function”
}
```
Func
函数中使用参数

```shell
funciotn func 
{
	echo “function”
	a=$1代表这个函数的参数
	b=$2
	echo `expr $a + $b`
}
func 3 5
```

积累
===

文件类型：  
-：普通文件 (f)  
d：目录文件  
b：块设备文件 (block)  
c：字符设备文件 (character)  
l：符号链接文件(symbolic link file)  
p：命令管道文件(pipe)  
s：套接字文件(socket)  
文件权限: 9位，每3位一组，每一组：rwx(读，写，执行)，当改组不具有某一权限用-代替。  
第一组为: 文件拥有者的权限， 该文件的拥有者可以读写，但不可执行；  
第二组为: 同群组的权限  
第三组为: 其他非本群组的权限

