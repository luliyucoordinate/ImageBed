---
layout: post
title: Leetcode 1006：笨阶乘（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-3-10 00:00:00
---

通常，正整数 `n` 的阶乘是所有小于或等于 `n` 的正整数的乘积。例如，`factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1`。

相反，我们设计了一个笨阶乘 `clumsy`：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。

例如，`clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1`。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。

另外，我们使用的除法是地板除法（*floor division*），所以 `10 * 9 / 8` 等于 `11`。这保证结果是一个整数。

实现上面定义的笨函数：给定一个整数 `N`，它返回 `N` 的笨阶乘。

**示例 1：**

```
输入：4
输出：7
解释：7 = 4 * 3 / 2 + 1
```

**示例 2：**

```
输入：10
输出：12
解释：12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1
```

**提示：**

1. `1 <= N <= 10000`
2. `-2^31 <= answer <= 2^31 - 1`  （答案保证符合 32 位整数。）

**解题思路**

这个问题非常简单，我首先想到的是通过栈。但是这里就有一个问题，我们知道我们需要先算乘除再算加减，所以我这里采用的策略是先将乘除算出来，然后算加减。

我们可以通过变量`d`记录我们当前需要什么样的计算（通过模`4`）。如果是乘法的话，我们首先将栈顶元素弹出，然后将遍历的数和栈顶元素想成，结果压入栈中。如果是除法，采用相同处理手段。如果是加减的话，我们直接压栈。

最后我们再遍历栈，进行加和减交替的运算。

```python
class Solution:
    def clumsy(self, N: int) -> int:
        res, d = 0, 0
        stack = list()
        for i in range(N, 0, -1):
            if stack:
                if d % 4 == 0:
                    val = stack.pop()
                    stack.append(val*i)
                elif d % 4 == 1:
                    val = stack.pop()
                    stack.append(val//i)
                elif d % 4 == 2:
                    stack.append(i)
                elif d % 4 == 3:
                    stack.append(i)
                d += 1
            else:
                stack.append(i)
                
        if stack:
            res = stack[0]
            for i, val in enumerate(stack[1:]):
                if i & 1 == 0:
                    res += val
                else:
                    res -= val
        
        return res
```

一个精妙的数学解法，我们可以证明这样的一个式子

- $i*(i-1)/(i-2)=i+1$，当`i>=5`的时候

证明如下

- $i*(i-1)/(i-2)=i*(1 + 1/(i-2))=i+i/(i-2)=i+1+2/(i-2)$
- $2/(i-2)<1$，所以$2<i-2$，所以$i>4$

所以我们的问题就变成了

- $i*(i-1)/(i-2)+(i-3)-(i-4)*(i-5)/(i-6)+rest=(i+1)+(i-3)-(i-3)+rest=i+1+rest$

而`rest`只会是下面四种

- `5-(4*3/2)+1`
- `6-(5*4/3)+2-1`
- `7-(6*5/4)+3-2*1`
- `8-(7*6/5)+4-3*2/1`

```python
class Solution:
    def clumsy(self, N: int) -> int:
        if N <= 2:
            return N
        if N <= 4:
            return N + 3
        
        if (N - 4) % 4 == 0:
            return N + 1
        elif (N - 4) % 4 <= 2:
            return N + 2
        else:
            return N - 1
```

使用`python`的话，我们有一个语法上的`trick`

```python
class Solution:
    def clumsy(self, N: int) -> int:
        op = itertools.cycle("*/+-")
        return eval("".join(str(x) + next(op) for x in range(N, 0, -1))[:-1])
```

reference:

https://leetcode.com/problems/clumsy-factorial/discuss/252250/Python-Cheat

https://leetcode.com/problems/clumsy-factorial/discuss/252279/You-never-think-of-this-amazing-O(1)-solution!!!

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**