---
layout: post
title: C语言语句的机器级表示
category : 计算机系统原理
tags : [notes, 原理]
stickie: true
---


过程调用的机器级表示
===

```c
int add(int x,int y)
{
	return x+y;
}
int main()
{
	int t1 = 125;
	int t2 = 80;
	int sum = add(t1, t2);
	return sum;
}
```
过程调用执行步骤（P为调用者，Q为被调用者）  
1.  P将入口参数放到Q能访问到的地方  
2.  P保存返回地址，然后将控制转移到Q；call指令  
3.  Q保存P的现场，并为自己的非静态局部变量分配空间  
4.  回复Q的过程体；  
5.  Q恢复P的现场，释放局部变量空间；  
6.  Q取出返回地址，将控制转移到P；RET指令  
  IA-32的寄存器使用约定：调用者P保存寄存器（EAX、EDX、ECX），Q可直接使用这三个寄存器。若P在从Q返回后还要用的话，P应在转到Q之前先保存，并在从Q返回后先恢复它们的值再使用。被调用者Q保存寄存器（EBX、ESI、EDI）。Q必须先将它们的值保存在栈中在使用它们，并在返回P之前恢复它们的值。  
  EBP和ESP分别是帧指针寄存器和栈指针寄存器，分别用来指向当前栈帧的底部和顶部。  

入口参数位置
---
movl 参数3,8(%esp)  
movl 参数2,4(%esp)  
movl 参数1,(%esp)  
call add  
call:  
R[esp]<-R[esp]-4  
M[R[esp]] 返回地址（call指令的下一条指令的地址）  
R[eip] add函数首地址  
每个过程开始两条指令  
pushl %ebp  
movl %esp,%ebp  

例子：应始终返回d[0]中的3.14，但是并非如此  

```c
double fun(int i)
{
	volatile double d[1] = {3.14};
	volatile long int a[2];
	a[i] = 1073741824;
	return d[0];
}
```
在vs2015执行中出现了报错Run-Time Check Failure #2 - Stack around the variable 'a' was corrupted.原因在于如果i超出了范围，数组中的数据会破坏栈里面的数据。  

```c
double fun(int i)
{
01161710  push        ebp  
01161711  mov         ebp,esp  
01161713  sub         esp,0E0h  
01161719  push        ebx  
0116171A  push        esi  
0116171B  push        edi  
0116171C  lea         edi,[ebp-0E0h]  
01161722  mov         ecx,38h  
01161727  mov         eax,0CCCCCCCCh  
0116172C  rep stos    dword ptr es:[edi]  
	volatile double d[1] = { 3.14 };
0116172E  movsd       xmm0,mmword ptr [__real@40091eb851eb851f (01166B38h)]  
01161736  movsd       mmword ptr [d],xmm0  
	volatile long int a[2];
	a[i] = 1073741824;
0116173B  mov         eax,dword ptr [i]  
	volatile long int a[2];
	a[i] = 1073741824;//400000000h
0116173E  mov         dword ptr a[eax*4],40000000h  
	return d[0];
01161746  mov         eax,8  
0116174B  imul        ecx,eax,0  
0116174E  fld         qword ptr d[ecx]  
}
```

选择和循环结构
---

```c
if(cond_expr)
	then_statement
else
	else_statement
```
机器级表示

```
	c = cond_expr;
	if(!c)
		goto false_label;
	then_statement
	goto done;
false_label:
	else_statement
done:
```
例子：

```c
int get_cont(int *p1, int *p2)
{
00831790  push        ebp  
00831791  mov         ebp,esp  
00831793  sub         esp,0C0h  
00831799  push        ebx  
0083179A  push        esi  
0083179B  push        edi  
0083179C  lea         edi,[ebp-0C0h]  
008317A2  mov         ecx,30h  
008317A7  mov         eax,0CCCCCCCCh  
008317AC  rep stos    dword ptr es:[edi]  
	if (p1 > p2)
008317AE  mov         eax,dword ptr [p1]  
008317B1  cmp         eax,dword ptr [p2]  //比较
008317B4  jbe         get_cont+2Fh (08317BFh)  
	{
		return *p2;
008317B6  mov         eax,dword ptr [p2]  
008317B9  mov         eax,dword ptr [eax]  
008317BB  jmp         get_cont+34h (08317C4h)  
	}
	else
008317BD  jmp         get_cont+34h (08317C4h)  //这条指令看上去执行不到啊
	{
		return *p1;
008317BF  mov         eax,dword ptr [p1]  
008317C2  mov         eax,dword ptr [eax]  
	}
}
008317C4  pop         edi  
008317C5  pop         esi  
008317C6  pop         ebx  
008317C7  mov         esp,ebp  
008317C9  pop         ebp  
008317CA  ret
```
关于switch语句

```c
int sw_test(int a,int b,int c)
{
00A11810  push        ebp  
00A11811  mov         ebp,esp  
00A11813  sub         esp,0D0h  
00A11819  push        ebx  
00A1181A  push        esi  
00A1181B  push        edi  
00A1181C  lea         edi,[ebp-0D0h]  
00A11822  mov         ecx,34h  
00A11827  mov         eax,0CCCCCCCCh  
00A1182C  rep stos    dword ptr es:[edi]  
	int result;
	switch (a)
00A1182E  mov         eax,dword ptr [a]  //参数a
00A11831  mov         dword ptr [ebp-0D0h],eax  
00A11837  mov         ecx,dword ptr [ebp-0D0h]  
00A1183D  sub         ecx,0Ah  //i=i-10
	int result;
	switch (a)
00A11840  mov         dword ptr [ebp-0D0h],ecx  
00A11846  cmp         dword ptr [ebp-0D0h],7  //i与7比较
00A1184D  ja          $LN6+0Bh (0A1187Bh)  //>7则跳转到输出default
00A1184F  mov         edx,dword ptr [ebp-0D0h]  //edx=i
00A11855  jmp         dword ptr [edx*4+0A1188Ch]  //跳到跳转表的位置
	{
	case 15:
		c = b & 0x0f;
00A1185C  mov         eax,dword ptr [b]  
00A1185F  and         eax,0Fh  
00A11862  mov         dword ptr [c],eax  
	case 10:
		result = c + 50;
00A11865  mov         eax,dword ptr [c]  
00A11868  add         eax,32h  
00A1186B  mov         dword ptr [result],eax  
		break;
00A1186E  jmp         $LN6+11h (0A11881h)  
	case 12:
	case 17:
		result = b + 50;
00A11870  mov         eax,dword ptr [b]  
00A11873  add         eax,32h  
00A11876  mov         dword ptr [result],eax  
		break;
00A11879  jmp         $LN6+11h (0A11881h)  
	default:
		result = a;
00A1187B  mov         eax,dword ptr [a]  
00A1187E  mov         dword ptr [result],eax  
	}
	return result;
00A11881  mov         eax,dword ptr [result]  
}
00A11884  pop         edi  
}
00A11885  pop         esi  
00A11886  pop         ebx  
00A11887  mov         esp,ebp  
00A11889  pop         ebp  
00A1188A  ret  
00A1188B  nop  
00A1188C  sbb         byte ptr gs:[ecx-5EE78500h],ah  
00A11893  add         byte ptr [eax+18h],dh  
00A11896  mov         eax,dword ptr ds:[A1187B00h]  
00A1189B  add         byte ptr [ebx+18h],bh  
00A1189E  mov         eax,dword ptr ds:[A1185C00h]  
00A118A3  add         byte ptr [ebx+18h],bh  
00A118A6  mov         eax,dword ptr ds:[A1187000h]  
00A118AB  add         ah,cl  
```