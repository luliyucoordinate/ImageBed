---
layout: post
title: Leetcode 951：翻转等价二叉树（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-12-8 00:00:00
---

我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。

只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X *翻转等价*于二叉树 Y。

编写一个判断两个二叉树是否是*翻转等价*的函数。这些树由根节点 `root1` 和 `root2` 给出。

**示例：**

```
输入：root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]
输出：true
解释：We flipped at nodes with values 1, 3, and 5.
```

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png" width="400" hegiht="200">
</center>

**提示：**

1. 每棵树最多有 `100` 个节点。
2. 每棵树中的每个值都是唯一的、在 `[0, 99]` 范围内的整数。

**解题思路**

这个问题很明显通过递归来解决。我们定义函数$f(root_1,root_2)$表示以$root_1$和$root_2$为根的结果，那么$f(root_1,root_2)=(f(root_1.left, root_2.left)\&f(root_1.right,root_2.right))||(f(root_1.left, root_2.right)\&f(root_1.right,root_2.left))$。我们接着考虑边界问题，我们判断$root_1==None||root_2==None$，如果成立的话，我们要返回$root_1==root_2$。我们还要判断$root_1.val\neq root_2.val$，如果成立的话，我们返回$False$。

```python
class Solution:
    def flipEquiv(self, root1, root2):
        """
        :type root1: TreeNode
        :type root2: TreeNode
        :rtype: bool
        """
        if root1 == None or root2 == None:
            return root1 == root2
        
        if root1.val != root2.val:
            return False
        
        return (self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right)) or\
               (self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left))
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**