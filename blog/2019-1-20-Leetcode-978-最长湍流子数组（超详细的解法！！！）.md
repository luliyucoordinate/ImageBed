---
layout: post
title: Leetcode 978：最长湍流子数组（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-20 00:00:00
---

当 `A` 的子数组 `A[i], A[i+1], ..., A[j]` 满足下列条件时，我们称其为*湍流子数组*：

- 若 `i <= k < j`，当 `k` 为奇数时， `A[k] > A[k+1]`，且当 `k` 为偶数时，`A[k] < A[k+1]`；
- **或** 若 `i <= k < j`，当 `k` 为偶数时，`A[k] > A[k+1]` ，且当 `k` 为奇数时， `A[k] < A[k+1]`。

也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。

返回 `A` 的最大湍流子数组的**长度**。

**示例 1：**

```
输入：[9,4,2,10,7,8,8,1,9]
输出：5
解释：(A[1] > A[2] < A[3] > A[4] < A[5])
```

**示例 2：**

```
输入：[4,8,12,16]
输出：2
```

**示例 3：**

```
输入：[100]
输出：1
```

**提示：**

1. `1 <= A.length <= 40000`
2. `0 <= A[i] <= 10^9`

**解题思路**

这个问题非常简单，首先想到的最简单的思路就是分别思考两种情况。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/978/2019_1_20_1.png" width="250">
</center>

对于第一种情况，我们只要对当前位置`i`后面的两个位置判断`A[i+2] < A[i + 1] > A[i]`，如果成立我们就在结果上加`2`，当我们发现不满足条件的时候，我们需要判断是那种情况造成的失败

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/978/2019_1_20_2.png" width="300">
</center>

如果是右边这种情况的话，我们还需要再在结果上添加`1`，最后取结果的最大值即可。

```python
class Solution:
    def maxTurbulenceSize(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        res = 1
        i, j = 0, len(A)
        while i < j:
            cur = 1
            while i+2 < j and A[i+2] < A[i + 1] > A[i]:
                cur += 2
                i += 2
            
            if i + 1 < j and A[i+1] > A[i]:
                cur +=1
            i += 1
            res = max(res, cur)
              
        i, j = 0, len(A)
        while i < j:
            cur = 1
            while i+2 < j and A[i+2] > A[i + 1] < A[i]:
                cur += 2
                i += 2
            
            if i + 1 < j and A[i+1] < A[i]:
                cur +=1
            i += 1
            res = max(res, cur)
                
        return res
```

我们通过观察不难发现这样的规律，不论是第一种情况还是第二种情况，它们的边界都在连续两次上或者连续两次下的中间节点，所以我们只需要考虑这些边界位置的距离即可。还要注意的一个地方就是`连续相等`的这种情况，对于这种情况我们直接记录当前位置为边界，然后接着遍历即可。

```python
class Solution:
    def maxTurbulenceSize(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        res, anchor = 1, 0
        A_len = len(A)
        for i in range(1, A_len):
            if A[i] == A[i-1]:
                anchor = i
                continue
            if i == A_len - 1 or A[i-1] <= A[i] <= A[i+1] or A[i-1] >= A[i] >= A[i+1]:
                res = max(res, i - anchor + 1)
                anchor = i
        return res
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**