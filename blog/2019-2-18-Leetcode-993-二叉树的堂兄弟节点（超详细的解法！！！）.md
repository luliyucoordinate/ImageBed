---
layout: post
title: Leetcode 993：二叉树的堂兄弟节点（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-2-18 00:00:00
---

在二叉树中，根节点位于深度 `0` 处，每个深度为 `k` 的节点的子节点位于深度 `k+1` 处。

如果二叉树的两个节点深度相同，但**父节点不同**，则它们是一对*堂兄弟节点*。

我们给出了具有唯一值的二叉树的根节点 `root`，以及树中两个不同节点的值 `x` 和 `y`。

只有与值 `x` 和 `y` 对应的节点是堂兄弟节点时，才返回 `true`。否则，返回 `false`。

 

**示例 1：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2019/02/12/q1248-01.png" width="150">
</center>

```
输入：root = [1,2,3,4], x = 4, y = 3
输出：false
```

**示例 2：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2019/02/12/q1248-02.png" width="150">
</center>

```
输入：root = [1,2,3,null,4,null,5], x = 5, y = 4
输出：true
```

**示例 3：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2019/02/13/q1248-03.png" width="150">
</center>

```
输入：root = [1,2,3,null,4], x = 2, y = 3
输出：false
```

 

**提示：**

1. 二叉树的节点数介于 `2` 到 `100` 之间。
2. 每个节点的值都是唯一的、范围为 `1` 到 `100` 的整数。

**解题思路**

我们很容易想到的一个最简单的做法就是，通过`DFS`分别找到`x`和`y`对应的元素的父节点和高度，我们只要对比节点高度和父节点信息，我们就可以知道最后结果是不是正确。

```python
class Solution:
    def isCousins(self, root: 'TreeNode', x: 'int', y: 'int') -> 'bool':
        def preOrder(pre, root, val, h):
            if root:
                if val == root.val:
                    return h, pre

                return preOrder(root.val, root.left, val, h + 1) or \
                    preOrder(root.val, root.right, val, h + 1)
                
        h1, r1 = preOrder(float('inf'), root, x, 0)
        h2, r2 = preOrder(float('inf'), root, y, 0)
        return h1 == h2 and r1 != r2
```

我们还可以使用`BFS`去做

```python
class Solution:
    def isCousins(self, root: 'TreeNode', x: 'int', y: 'int') -> 'bool':
        q = [root]
        d, xd, yd = 0, -1, -2
        while q:
            for _ in range(len(q)):
                node = q.pop(0)
                if node.val == x:
                    xd = d
                if node.val == y:
                    yd = d
                if node.left and node.right and \
                    (node.left.val == x and node.right.val == y or\
                     node.left.val == y and node.right.val == x):
                    return False

                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            d += 1
        return xd == yd
```

我们关键的一步在与其中的剪枝操作，我们通过判断节点的左右是不是`x`和`y`来判定`x`和`y`是不是拥有相同的父节点。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**