---
layout: post
title: C++多态性
category : cpp
tags : [cpp, 转载]
stickie: true
---

转自[Hackbuteer1的专栏](http://blog.csdn.net/hackbuteer1/article/details/7475622)

C++多态性
===

C++编程语言是一款应用广泛，支持多种程序设计的计算机编程语言。我们今天就会为大家详细介绍其中C++多态性的一些基本知识，以方便大家在学习过程中对此能够有一个充分的掌握。  
多态性可以简单地概括为“一个接口，多种方法”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。多态(polymorphism)，字面意思多种形状。  
C++多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。（这里我觉得要补充，重写的话可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性）而重载则是允许有多个同名的函数，而这些函数的参数列表不同，允许参数个数不同，参数类型不同，或者两者都不同。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载问题。但这并没有体现多态性。  
多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。  
那么多态的作用是什么呢，封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。也就是说，不论传递过来的究竟是那个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。  
最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用到同一个函数，这就无法实现一个接口，多种方法的目的了。  

```c++
#include<iostream>  
using namespace std;  
  
class A  
{  
public:  
    void foo()  
    {  
        printf("1\n");  
    }  
    virtual void fun()  
    {  
        printf("2\n");  
    }  
};  
class B : public A  
{  
public:  
    void foo()  
    {  
        printf("3\n");  
    }  
    void fun()  
    {  
        printf("4\n");  
    }  
};  
int main(void)  
{  
    A a;  
    B b;  
    A *p = &a;  
    p->foo();  
    p->fun();  
    p = &b;  
    p->foo();  
    p->fun();  
    return 0;  
}  
```
第一个p->foo()和p->fun()都很好理解，本身是基类指针，指向的又是基类对象，调用的都是基类本身的函数，因此输出结果就是1、2。  
第二个输出结果就是1、4。p->foo()和p->fun()则是基类指针指向子类对象，正式体现多态的用法，p->foo()由于指针是个基类指针，指向是一个固定偏移量的函数，因此此时指向的就只能是基类的foo()函数的代码了，因此输出的结果还是1。而p->fun()指针是基类指针，指向的fun是一个虚函数，由于每个虚函数都有一个虚函数列表，此时p调用fun()并不是直接调用函数，而是通过虚函数列表找到相应的函数的地址，因此根据指向的对象不同，函数地址也将不同，这里将找到对应的子类的fun()函数的地址，因此输出的结果也会是子类的结果4。  
笔试的题目中还有一个另类测试方法。即  

```c++
B *ptr = (B *)&a;  ptr->foo();  ptr->fun();
```
问这两调用的输出结果。这是一个用子类的指针去指向一个强制转换为子类地址的基类对象。结果，这两句调用的输出结果是3，2。  
并不是很理解这种用法，从原理上来解释，由于B是子类指针，虽然被赋予了基类对象地址，但是ptr->foo()在调用的时候，由于地址偏移量固定，偏移量是子类对象的偏移量，于是即使在指向了一个基类对象的情况下，还是调用到了子类的函数，虽然可能从始到终都没有子类对象的实例化出现。  
而ptr->fun()的调用，可能还是因为C++多态性的原因，由于指向的是一个基类对象，通过虚函数列表的引用，找到了基类中fun()函数的地址，因此调用了基类的函数。由此可见多态性的强大，可以适应各种变化，不论指针是基类的还是子类的，都能找到正确的实现方法。  

总结
---

```c++
Class_B Val_b;
Class_A Val_a = （Class_A*）Val_b;
```
**此刻，Val_a的实函数是Class_A的类型，虚函数是Class_B的类型！！！**
**指针的数据类型是实函数的类型，指针指向的对象的数据类型，是虚函数的数据类型**


重载与覆盖
---
成员函数被重载的特征：  
1.  相同的范围（在同一个类中）；
2.  函数名字相同；
3.  参数不同；
4.  virtual关键字可有可无。 

覆盖是指派生类函数覆盖基类函数，特征是：  
1.  不同的范围（分别位于派生类与基类）；
2.  函数名字相同；
3.  参数相同；
4.  基类函数必须有virtual关键字。

令人迷惑的隐藏规则
---

本来仅仅区别重载与覆盖并不算困难，但是C++的隐藏规则使问题复杂性陡然增加。  
这里“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：  
1.  如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
2.  如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。

```c++
//小结：1、有virtual才可能发生多态现象  
// 2、不发生多态（无virtual）调用就按原类型调用  
#include<iostream>  
using namespace std;  
  
class Base  
{  
public:  
    virtual void f(float x)  
    {  
        cout<<"Base::f(float)"<< x <<endl;  
    }  
    void g(float x)  
    {  
        cout<<"Base::g(float)"<< x <<endl;  
    }  
    void h(float x)  
    {  
        cout<<"Base::h(float)"<< x <<endl;  
    }  
};  
class Derived : public Base  
{  
public:  
    virtual void f(float x)  
    {  
        cout<<"Derived::f(float)"<< x <<endl;   //多态、覆盖  
    }  
    void g(int x)  
    {  
        cout<<"Derived::g(int)"<< x <<endl;     //隐藏  
    }  
    void h(float x)  
    {  
        cout<<"Derived::h(float)"<< x <<endl;   //隐藏  
    }  
};  
int main(void)  
{  
    Derived d;  
    Base *pb = &d;  
    Derived *pd = &d;  
    // Good : behavior depends solely on type of the object  
    pb->f(3.14f);   // Derived::f(float) 3.14  
    pd->f(3.14f);   // Derived::f(float) 3.14  
  
    // Bad : behavior depends on type of the pointer  
    pb->g(3.14f);   // Base::g(float)  3.14  
    pd->g(3.14f);   // Derived::g(int) 3   
  
    // Bad : behavior depends on type of the pointer  
    pb->h(3.14f);   // Base::h(float) 3.14  
    pd->h(3.14f);   // Derived::h(float) 3.14  
    return 0;  
} 
```
上面的程序中：  
1.  函数Derived::f(float)覆盖了Base::f(float)。
2.  函数Derived::g(int)隐藏了Base::g(float)，而不是重载。
3.  函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。


以下内容转自[陈皓专栏](http://blog.csdn.net/haoel/article/details/1948051/)

虚函数表
===

对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。  
这里我们着重看一下这张虚函数表。C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。  
听我扯了那么多，我可以感觉出来你现在可能比以前更加晕头转向了。 没关系，下面就是实际的例子，相信聪明的你一看就明白了。  
假设我们有这样的一个类：  

```c++ 
class Base {
public:
    virtual void f() { cout << "Base::f" << endl; }
    virtual void g() { cout << "Base::g" << endl; }
    virtual void h() { cout << "Base::h" << endl; } 
};
```
按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程：  

```c++ 
typedef void(*Fun)(void);
Base b;
Fun pFun = NULL;

cout << "虚函数表地址：" << (int*)(&b) << endl;
cout << "虚函数表 — 第一个函数地址：" << (int*)*(int*)(&b) << endl;
 
// Invoke the first virtual function 
 pFun = (Fun)*((int*)*(int*)(&b));
 pFun();
```
实际运行经果如下：(Windows XP+VS2003,  Linux 2.6.22 + GCC 4.1.3)  
虚函数表地址：0012FED4  
虚函数表 — 第一个函数地址：0044F148  
Base::f  

通过这个示例，我们可以看到，我们可以通过强行把&b转成int *，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int* 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下：  

```c++
(Fun)*((int*)*(int*)(&b)+0);  // Base::f()
(Fun)*((int*)*(int*)(&b)+1);  // Base::g()
(Fun)*((int*)*(int*)(&b)+2);  // Base::h()
```
这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示：  

<a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zael3bej209703ldfq.jpg" data-lightbox="roadtrip">
<img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zael3bej209703ldfq.jpg" class="img-fluid">
</a>

注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。  
下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。  

一般继承（无虚函数覆盖）
---

下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系：
请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：  

<a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zafqqagj202605ea9x.jpg" data-lightbox="roadtrip">
<img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zafqqagj202605ea9x.jpg" class="img-fluid">
</a>

对于实例：Derive d; 的虚函数表如下：  

<a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zai59quj20fb03ggll.jpg" data-lightbox="roadtrip">
<img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zai59quj20fb03ggll.jpg" class="img-fluid">
</a>

我们可以看到下面几点：  
1.  虚函数按照其声明顺序放于表中。
2.  父类的虚函数在子类的虚函数前面。

我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。  


一般继承（有虚函数覆盖）
---

覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。  

<a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zaiiy6aj202605e745.jpg" data-lightbox="roadtrip">
<img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zaiiy6aj202605e745.jpg" class="img-fluid">
</a>

为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：  

<a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zaj05r5j20dw03gmx4.jpg" data-lightbox="roadtrip">
<img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zaj05r5j20dw03gmx4.jpg" class="img-fluid">
</a>

我们从表中可以看到下面几点，  
1.  覆盖的f()函数被放到了虚表中原来父类虚函数的位置。
2.  没有被覆盖的函数依旧。

这样，我们就可以看到对于下面这样的程序，  

```c++ 
Base *b = new Derive();
b->f();
```
由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。  


多重继承（无虚函数覆盖）
---

下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。  

<a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zajebebj207u05cjre.jpg" data-lightbox="roadtrip">
<img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zajebebj207u05cjre.jpg" class="img-fluid">
</a>

对于子类实例中的虚函数表，是下面这个样子：  

<a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1fg5zajstfbj20dp04tdg1.jpg" data-lightbox="roadtrip">
<img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1fg5zajstfbj20dp04tdg1.jpg" class="img-fluid">
</a>

我们可以看到：  
1.  每个父类都有自己的虚表。
2.  子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）

这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。  


多重继承（有虚函数覆盖）
---

下面我们再来看看，如果发生虚函数覆盖的情况。  
下图中，我们在子类中覆盖了父类的f()函数。  

<a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zak4wnmj207u05cjre.jpg" data-lightbox="roadtrip">
<img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fg5zak4wnmj207u05cjre.jpg" class="img-fluid">
</a>

下面是对于子类实例中的虚函数表的图：  

<a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zakk1ghj20bo04tq34.jpg" data-lightbox="roadtrip">
<img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fg5zakk1ghj20bo04tq34.jpg" class="img-fluid">
</a>

我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如：  

```c++
Derive d;
Base1 *b1 = &d;
Base2 *b2 = &d;
Base3 *b3 = &d;
b1->f(); //Derive::f()
b2->f(); //Derive::f()
b3->f(); //Derive::f()

b1->g(); //Base1::g()
b2->g(); //Base2::g()
b3->g(); //Base3::g()
```

安全性
---
每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。  

1.  通过父类型的指针访问子类自己的虚函数  

我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数：  

```c++ 
Base1 *b1 = new Derive();
b1->f1();  //编译出错
```
任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点）  
2.  访问non-public的虚函数  

另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。  
如：  

```c++
class Base {
    private:
            virtual void f() { cout << "Base::f" << endl; }
 
};
 
class Derive : public Base{
 
};
 
typedef void(*Fun)(void);
 
void main() {
    Derive d;
    Fun  pFun = (Fun)*((int*)*(int*)(&d)+0);
    pFun();
}
```

C++纯虚函数
===

定义
---
纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”   

```c++
virtual void funtion()=0 
```

引入原因
---
1.  为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 
2.  在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。 

为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。  

相似概念
---
1.  多态性 
  指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。 
  a、编译时多态性：通过重载函数实现 
  b、运行时多态性：通过虚函数实现。 
2.  虚函数 
  虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态覆盖（Override）
3.  抽象类 
  包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。
