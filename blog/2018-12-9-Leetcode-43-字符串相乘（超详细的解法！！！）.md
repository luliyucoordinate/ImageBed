---
layout: post
title: Leetcode 43：字符串相乘（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-12-9 00:00:00
---

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**示例 1:**

```
输入: num1 = "2", num2 = "3"
输出: "6"
```

**示例 2:**

```
输入: num1 = "123", num2 = "456"
输出: "56088"
```

**说明：**

1. `num1` 和 `num2` 的长度小于110。
2. `num1` 和 `num2` 只包含数字 `0-9`。
3. `num1` 和 `num2` 均不以零开头，除非是数字 0 本身。
4. **不能使用任何标准库的大数类型（比如 BigInteger）**或**直接将输入转换为整数来处理**。

**解题思路**

对于这个问题，如果你注意到下面的这个规律话就非常简单。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/43/2018_12_9_1.png" width="400" hegiht="400">
</center>

首先要说明的是**我们是按照从左向右的顺序存储的数字**。我们注意到对于`index:i`和`index:j`相乘的话，结果在`index:i+j`和`index:i+j+1`上。

```python
class Solution:
    def multiply(self, num1, num2):
        """
        :type num1: str
        :type num2: str
        :rtype: str
        """
        num1_len, num2_len = len(num1), len(num2)
        res = ['0'] * (num1_len + num2_len)
        for i in range(num2_len-1, -1, -1):
            for j in range(num1_len-1, -1, -1):
                tmp = int(num1[j]) * int(num2[i]) + int(res[i + j + 1])
                res[i + j + 1] = str(tmp%10)
                res[i + j] = str(int(res[i+j]) + tmp // 10)
                
        for i in range(num1_len + num2_len):
            if res[i] != '0':
                return ''.join(res[i:])
        return '0'
```

评论区大佬@[simon2034](https://me.csdn.net/simon2034)提出的一种更简洁的写法

```python
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        res, m, n = 0, len(num1), len(num2)
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                res += int(num1[-i]) * int(num2[-j]) * 10 ** (i + j - 2)
        return str(res)
```

不过这种写法在一定可能上会出现数据溢出的问题（对于其他语言）。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**