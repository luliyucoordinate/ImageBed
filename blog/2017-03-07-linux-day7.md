---
layout: post
title: linux Day7
category : linux
tags : [linux, process, signal, c, shell]
stickie: true
---


Sigaction函数
===

```c++
<signal.h>
Int sigaction(int signo, const structsigactin *act,struct sigactin *oact);
```

检查或修改与指定信号相关联的处理动作，该函数取代signal函数  
参数signo是要检测或者要修改其具体操作的信号编号  
act指针为空，则要修改其动作  
oact指针为空，则系统由oact指针返回该信号的上一个动作

```c++
struct sigaction{
	void (*as_handler) (int);
	void (*sa_sigaction)(int , siginfo_t *,void *);
	sigset_t sa_mask;
	int sa_flags;
	void (*sa_restorer)(void);
}

int signal1(int signo, void (*fun)(int)){
	struct sigaction act, oact;
	act.sa_handler = func;
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;
	return sigaction(signo, &act,&oact);
}
```


守护进程(daemon)
===

守护进程是一个后台进程，他无需用户输入就可以运行，经常提供某种服务  
常见的守护进程有web服务器、邮件服务器以及数据库服务器  
守护进程不能控制终端，所以任何输入或者输出都要做特殊处理  
和多数程序一样，一个守护进程是从shell脚本或者命令行启动，但是他们不是交互式的，没有控制终端。  
父进程在fork子进程退出后就消除了控制终端。  
守护进程既不需要从标准输入设备都信息，也不需要标准输出。  
下一步在子进程中调用setsid，取消进程和任何控制终端的关联。  
下一步是让根目录称为子进程的当前目录，因为任何进程如果他的当前目录是在一个被安装的文件系统上，那么就会妨碍这个文件被卸载。  
接下来设置umask为0，设置权限  
如果一个进程继承父进程的umask055，他屏蔽了group和other的读和执行权。  
如果守护进程接着创建一个文件，group和other用户操作就很麻烦。  


总结为以下步骤：  
1.  父进程fork，执行exit退出
2.  子进程调用setsid
3.  让根目录“/”成为子进程的工作目录
4.  把子进程umask设置为0
5.  关闭不需要的文件描述符



setsid函数
===

```c++
pid_t setsid()
```

setsid函数创建一个新的会话和一个新的进程组，然后守护进程成为他们的领导  
setsid会保证新会话没有终端 
如果调用进程已经是一个进程组的领导进程，setsid调用失败。  
函数调用成功后，返回新会话ID，失败返回-1，设置errno



chdir函数
===

```c++
int chdir(const char *pathname)
```

chdir函数根据参数pathname设置当前工作(注意不一定是文件所在目录)，成功返回0，失败返回-1，设置errno



umask函数
===

```c
mode_t umask(mode_t mask);
```
umask调用把守护进程的umask设置为0，这样取消来自父进程的umask


syslog提供服务
===

openlog打开日志

```c
<syslog.h>
void openlog(const char *ident, int option,int facility);
```
ident参数是要向消息中加入字符串，常用设置程序名  
option有如下几个值  
LOG_CONS      如果系统日志服务器不能写，写入控制台  
LOG_NDELAY    立即打开链接，正常情况下，直到发送一条消息才打开链接  
LOG_PERROR    打印到stderr  
LOG_PID       每条消息包含进程PID  
faciliticy设置消息类型，指定消息重要性。


syslog写入日志

```c
void syslog(int priority, const char*format, …);
```
priority同facility  
closelog关闭日志

```c
void close(void);
```

openlog与closelog是可选项，因为调用syslog函数首次使用自动打开日志文件  
red hat linux的日志文件在/var/log/messages  
守护进程在linux中，可执行文件名后为d，没有扩展名

shell脚本结束守护进程
===

结束进程
```shell
#!/bin/sh
WHOAMI=`whoami`
 
PID=`ps –u $WHOAMI | grep abc | awk ‘{print $1}’`
if(test “$PID” != “”) then
       kill $PID
fi
```
如果要确保程序只启动一次

```shell
\#!/bin/sh

 
WHOAMI=`whoami`
 

PID=`ps –u $WHOAMI | grep abc | awk ‘{print $1}’`
if(test “$PID” = “”) then
       ./abc
fi
```
注意脚本文件的名称不要有’abc’字样，不然执行ps的时候会把脚本名称也print出来



自定义信号
===

捕获SIGUSR1信号
```c++
void catch_Signal(int Sign){
       switch(Sign){
       caseSIGINT:
              printf("SIGINTSignal\n");
              exit(0);
       caseSIGUSR1:
              printf("SIGUSR1Signal\n");
       }
}
int main(int argc,char *argv[]){
       signal(SIGINT,catch_Signal);
       signal(SIGUSR1,catch_Signal);
       printf("pid= %d\n", getpid());
       while(1){
              sleep(1);
       }
       return0;
}
```
发送SIGUSR1信号

```c++
int main(argc,char *argv[]){
       if(argc> 1){
              kill(atoi(argv[1]),SIGUSR1);
              printf("sentto %d\n", atoi(argv[1]));
       }
       return0;
}
```
