---
layout: post
title: 再看c++
category : cpp
tags : [cpp]
stickie: true
---


Object Based基于对象
===
```
延伸文件名(extension file name )不一定是.h或.cpp，也可以是.hpp或者其他
```


头文件的声明
---
```c++
#ifndef __COMPLEX__
#define __COMPLEX__
//forward declarations
#include <cmath>
class ostream;
class complex;

complex &__doapl (complex *this, const complex&);
//class declarations
class complex
{
};
//class definition
complex::function
#endif
函数若在class内部实现，就会定义成inline候选人，如果他不复杂的话，编译器就会把它做成inline
```


access level
---
```
private:
double re, im;
所有的数据都要放在private里面
不被外界使用的函数也要放在private里面
```


constructor
---
```c++
complex(double r = 0, double i =0)    //default argument
:re(r), im(i)                //initialization list, only constructor can use,it’s very nice
{ }
```
```
最好写在inlitialization list 里面，不要写在大括号里。一个是初始化阶段，一个时候后一阶段，效率会很低。
构造函数可以有很多个
名字与类相同，没有返回类型
构造函数放在private，表示这个函数不可以被外界调用，那就无法使用构造了
但是有这样一种设计模式Singleton,外界只能用一份
```
```c++
classs a
{
public:
	static a& getInstance();
	setup() {    }
private:
	a();
	a(const a& rhs);
};
a& a::getInstance()
{
	static a b;
	return b;
}
a::getInstance().setup();
```


函数后面加const
---
```
double real() const { return re; } //不改变里面的数据内容
在类的设计之初要考虑好这个问题，不然后面调用的时候会出现问题
例如：
const complex c1(2,1);      此处想告诉编译器c1是一个不更改内部数据的一个对象   
cout << c1.read();
cout << c1.img();
但是如果设计之初没有加const的话相当于告诉编译器我这个函数内部可能会修改数据
所以在这里这样使用会出错
```


参数的传递
---
```c++
pass by value
complex(double r = 0, double i =0) :
re (r), im (i)
{ }
pass by reference(to const)
complex& operator += (const complex&);  //内部不可以修改传递的值
ostream& operator << (ostream& os, const complex &x);
```
```
这样做的原因在于效率，因为如果参数的大小太大的话，会影响传递速度
返回值的传递也尽量用reference
```


friend
---
```c++
友元函数可以使用类内部的私有变量
friend complex& __doapl (complex*, const complex&);
inline complex& 
__doapl (complex* ths, const complex& r)
{
	ths->re += r.re;
	ths->im += r.im;
}
```
```
这种做法打破了封装，也可以使用函数取私有变量，虽然这样做速度变慢了
注意这里有这样的做法
在类的内部有这样的函数
int func(const complex* param)
{ return param.re + param.im; }
他并没有调用函数取取私有变量，而是直接拿来用，原因
同一个class的各个object互为friends
使用实例：
complex c1(2,1);
complex c2;
c2.func(c1);
```


return by reference 
---
```c++
inline complex&
__doapl (complex* ths, const complex& r)
{
	ths->re += r.re;
	ths->im += r.im;
	return *this;
}
```
```
不可以return by reference的情况，在类的内部建立空间，最后要把空间的reference传出去，
这样做是错误的，因为，函数一结束，函数的空间就会被操作系统重新分配。
传递者无需知道接收者使用什么形式接受，此处用的是reference，这就是c++的优势
```


operator overloading
---
```
成员函数
inline complex&
complex::operator += (const complex& r)
{ return __doapl (this, r); }
所有成员函数都有this，谁调用函数这个谁就是this，this只一个指针，不能够在参数列写出来。
此处返回类型不可为void的原因在于要考虑连续的使用
a+=b+=c
非成员函数
inline double
imag(const complex& x)
{ return x.img (); }
inline complex
operator + (const complex& x, const complex& y)
{ return complex (real (x) +real(y),imag(x)+imag(y)); }
这里没有使用return by reference的原因在于他们返回的必定是local object
这里相加的左值是在函数内部创建的
这里有一个特殊的地方
#include<iostream>
ostream&
operator << (ostream& os, const complex& x)
{ return os << ‘(‘ << real (x) << ‘,’ << imag (x) << ‘)’ ;}
这个overloading只可以是非成员，原因在于cout不知道怎么去处理自定义数据，他在一开始就写死了。
```


temp object
---
```
typename();
他的生命周期在返回后就结束了
```


一些思考
===
```
关于程序的实现是根据需求而定的
首先要考虑用reference可不可以
```
