---
layout: post
title: Leetcode 971：翻转二叉树以匹配先序遍历（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-7 00:00:00
---

给定一个有 `N` 个节点的二叉树，每个节点都有一个不同于其他节点且处于 `{1, ..., N}` 中的值。

通过交换节点的左子节点和右子节点，可以翻转该二叉树中的节点。

考虑从根节点开始的先序遍历报告的 `N` 值序列。将这一 `N` 值序列称为树的行程。

（回想一下，节点的先序遍历意味着我们报告当前节点的值，然后先序遍历左子节点，再先序遍历右子节点。）

我们的目标是翻转**最少的**树中节点，以便树的行程与给定的行程 `voyage` 相匹配。 

如果可以，则返回翻转的所有节点的值的列表。你可以按任何顺序返回答案。

如果不能，则返回列表 `[-1]`。 

**示例 1：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2019/01/02/1219-01.png" width="120">
</center>

```
输入：root = [1,2], voyage = [2,1]
输出：[-1]
```

**示例 2：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2019/01/02/1219-02.png" width="150">
</center>

```
输入：root = [1,2,3], voyage = [1,3,2]
输出：[1]
```

**示例 3：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2019/01/02/1219-02.png" width="150">
</center>

```
输入：root = [1,2,3], voyage = [1,2,3]
输出：[]
```


**提示：**

1. `1 <= N <= 100`

**解题思路**

这个问题非常简单，我们只要遍历`root`，然后遍历`voyage`，比较两者的`val`是不是一样，不一样的话，自然就不对，如果一样的话，继续遍历下去即可。例如

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/971/2019_1_7_1.png" width="180">
</center>

我们发现此时的`root.val`和`voyage[0]`一致，所以我们比较`root.left`和`root.right`。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/971/2019_1_7_2.png" width="200">
</center>

我们发现此时`root.left`和`voyage[1]`不一样，所以我们需要将`root.left`和`root.right`交换。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/971/2019_1_7_3.png" width="200">
</center>

然后继续判断`root.left`和`voyage[1]`，并且判断`voyage[2]`和`root.right`。

```python
class Solution:
    def flipMatchVoyage(self, root, voyage):
        """
        :type root: TreeNode
        :type voyage: List[int]
        :rtype: List[int]
        """
        res = list()
        i = 0
        def dfs(root):
            nonlocal i
            if not root:
                return True
            
            if root.val != voyage[i]:
                return False
            
            i += 1
            if root.left and root.left.val != voyage[i]:
                res.append(root.val)
                root.left, root.right = root.right, root.left
                
            return dfs(root.left) and dfs(root.right)
        
        return res if dfs(root) else [-1]
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**