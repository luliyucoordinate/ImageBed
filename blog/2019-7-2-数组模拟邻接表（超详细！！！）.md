---
layout: post
title: 数组模拟邻接表（超详细！！！）
category : 算法
tags : [c++]
stickie: true
date: 2019-7-2 00:00:00
---

这两天做到了很多这样的问题，所以我就想写一下关于这个问题的一些总结。

首先我们先看一下常见的代码模板

```cpp
struct Edge {
    int to; 	//子节点
    int w;		//权重
    int next;	//每个head链表的下一个节点
} edge[N * 2];
 
int head[N], idx = 0;
 
void add_edge(int from, int to, int w)
{
    edge[idx].to = to;
    edge[idx].w = w;
    edge[idx].next = head[from];
    head[from] = idx++;
}
 
memset(head, -1, sizeof head);
```

这里面比较难理解的地方在与这个加边算法，也就是链式向前星。为了思考的方便，我们先不加上`w`，也就是权重去除。先从一个简单的情况开始思考，也就是存在这样几条边`0,1`、`0,2`、`0,3`、`1,3`、`2,3`。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/GraphToList/2019_7_2_1.png" width="300">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/GraphToList/2019_7_2_2.png" width="100">
</center>

首先考虑添加`0->1`这条边，此时我们的`edge[0] = {to:1, next:-1}`

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/GraphToList/2019_7_2_3.png" width="250">
</center>

此时我们就可以通过`head[0]`找到`edge[0]`，怎么做的呢？可以这样做

```cpp
int i = head[0];
i = edge[i].next;
```

上面这两个代码非常重要，使我们遍历整个图的基础。接着添加边`0->2`，此时我们的`edge[1] = {to:2, next:0}`

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/GraphToList/2019_7_2_4.png" width="280">
</center>

此时我们就可以通过`head[0]`找到`edge[1]`。接下来的过程就是一些重复操作了，最后结果如下

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/GraphToList/2019_7_2_5.png" width="300">
</center>

那么通过这个图，你就可以发现，每个`head(x)`后面存储的实际上就是`x`的所有子节点。

接着我们就需要思考一下如何遍历这个图，首先通过`dfs`

```cpp
void dfs(int u, int u_father)
{
    for (int i = head[u]; ~i; i = edge[i].next)
    {
        int son = edge[i].to;
        if (son != u_father) dfs(son, u);
    }
}
```

其中`u`表示我们当前遍历的节点，而`u_father`表示它的父节点。对于深度优先搜索的话，有了前面的图就很好理解了，就是每次遍历一个`head`的所有节点，再从每个节点开始`dfs`。而`son != u_father`是为了避免往回（父节点）遍历。

接着我们看如何`bfs`

```cpp
int q[N];
bool visited[N];
void bfs(int u)
{
    int hh = 0, tt = 0;
    q[0] = u;
    visited[u] = true;
    while (hh <= tt)
    {
        int t = q[hh++];
        for (int i = h[t]; ~i; i = edge[i].next)
        {
            int son = edge[i].to;
            if (!visited[son])
            {
                q[++tt] = son;
                visited[son] = true;
            }
        }
    }
}
```

对于广度优先搜索的话，有了前面的图就很好理解了，就是每次遍历一个`head`的所有节点。我们每次将当前节点`u`的所有子节点添加到队列`q`中，然后将其标记为访问过了（添加到`visited`中）。终止条件就是遍历到了`-1`，也就是`~i`继续遍历。

最后我们看一个例子

[京东2019笔试：紧急疏散（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/94459928)

reference:

https://www.cnblogs.com/wenruo/p/4680930.html

**如有问题，希望大家指出！！！**