---
layout: post
title: Leetcode 173:二叉搜索树迭代器（超详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-8 00:00:00
---

实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。

调用 `next()` 将返回二叉搜索树中的下一个最小的数。 

**示例：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" width="200">
</center>

```
BSTIterator iterator = new BSTIterator(root);
iterator.next();    // 返回 3
iterator.next();    // 返回 7
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 9
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 15
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 20
iterator.hasNext(); // 返回 false 
```

**提示：**

- `next()` 和 `hasNext()` 操作的时间复杂度是 O(1)，并使用 O(*h*) 内存，其中 *h* 是树的高度。
- 你可以假设 `next()` 调用总是有效的，也就是说，当调用 `next()` 时，BST 中至少存在一个下一个最小的数。

**解题思路**

首先想到的就是暴力破解，通过遍历将二叉树的数据存放到数组中，然后每次`next`操作时取出最小值即可。关于遍历二叉树

[Leetcode 144:二叉树的前序遍历（最优雅的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/80731041)

[Leetcode 94:二叉树的中序遍历（最优雅的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/80809930)

[Leetcode 145:二叉树的后序遍历（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/81044345)

```python
class BSTIterator:
    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.data = list()
        self.inorder(root)

    def inorder(self, root):
        if root:
            self.inorder(root.left)
            self.data.append(root.val)
            self.inorder(root.right)
                  
    def next(self):
        """
        @return the next smallest number
        :rtype: int
        """
        min_val = min(self.data)
        self.data.remove(min_val)
        return min_val
        
    def hasNext(self):
        """
        @return whether we have a next smallest number
        :rtype: bool
        """
        return True if self.data else False
```

由于每次取出最小值，所以这很明显使用最小堆来优化。在`python`中我们不需要自己实现最小堆，只需要`import heapq`即可。

```python
import heapq
class BSTIterator:
    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.data = list()
        self.inorder(root)
        heapq.heapify(self.data)
        
    def inorder(self, root):
        if root:
            self.inorder(root.left)
            self.data.append(root.val)
            self.inorder(root.right)
            
    def next(self):
        """
        @return the next smallest number
        :rtype: int
        """
        return heapq.heappop(self.data)
        
    def hasNext(self):
        """
        @return whether we have a next smallest number
        :rtype: bool
        """
        return True if self.data else False
```

但是这两种做法都有点违背了题目的本意，题目是要求我们建立一个遍历二叉树的迭代器。这个非常简单，我们知道最左值一定是最小值。我们只需要将左边不断压栈，那么栈中存放的就是从大到小的值。调用`next`的时候，我们只需要弹出栈顶元素即可，同时我们需要将`right`加入栈中（非递归先序遍历二叉树的思路）。

```python
class BSTIterator:
    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.stack = list()
        self.pushLeft(root)
        
    def next(self):
        """
        @return the next smallest number
        :rtype: int
        """
        node = self.stack.pop()
        self.pushLeft(node.right)
        return node.val
        
    def pushLeft(self, node):
        while node:
            self.stack.append(node)
            node = node.left
        
    def hasNext(self):
        """
        @return whether we have a next smallest number
        :rtype: bool
        """
        return True if self.stack else False
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**