---
layout: post
title: Leetcode 18:四数之和（最详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-8 00:00:00
---

给定一个包含 *n* 个整数的数组 `nums` 和一个目标值 `target`，判断 `nums` 中是否存在四个元素 *a，b，c* 和 *d* ，使得 *a* + *b* + *c* + *d* 的值与 `target` 相等？找出所有满足条件且不重复的四元组。

**注意：**

答案中不可以包含重复的四元组。

**示例：**

```
给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
```

**解题思路**

这个问题其实和[Leetcode 15:三数之和（最详细解决方案！！！）](https://blog.csdn.net/qq_17550379/article/details/80614597)类似，所以我们可以直接参考这篇文章中的做法。

我们首先想到的做法就是暴力解法

```python
class Solution:
    def fourSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        result = []
        for i, a in enumerate(nums):
            for j, b in enumerate(nums[i + 1:]):
                for k, c in enumerate(nums[j + i + 2:]):
                    for _, d in enumerate(nums[i + j + k + 3:]):
                        if a + b + c + d == 0:
                            result.append([a, b, c, d])
        return result
```

暴力解法是如此的简洁(￣▽￣)"，但是正如大家所知，这种做法的时间复杂度时`O(n^4)`级别的。我们能不能优化为`O(n^3)`级别呢？

我们可以将`d`中的元素都放入查找表，这样我们只需要遍历`a\b\c`三个数组，之后在查找表中查找`0 - a - b - c`就可以将问题解决，我这里就不再赘述地代码。

我们还不满足，有没有更快的解法？有！！！

我们可以参考[Leetcode 15:三数之和（最详细解决方案！！！）](https://blog.csdn.net/qq_17550379/article/details/80614597)文章中的`对撞指针`的思路

```python
class Solution:
    def fourSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        result = list()
        nums_len = len(nums)
        nums.sort()
        for i in range(nums_len - 3):
            if i > 0 and nums[i - 1] == nums[i]:
                continue

            for j in range(i+1, nums_len - 2):
                if j > i + 1 and nums[j] == nums[j - 1]:
                    continue
                l, r = j + 1, nums_len - 1
                while l < r:
                    if nums[i] + nums[j] + nums[l] + nums[r] == target:
                        result.append([nums[i], nums[j], nums[l], nums[r]])
                        while l < r and nums[l] == nums[l + 1]:
                            l += 1
                        while l < r and nums[r] == nums[r - 1]:
                            r -= 1
                        l += 1
                        r -= 1
                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:
                        l += 1
                    else:
                        r -= 1 
        return result
```

这个问题的解法，有一个非常重要的简直操作。

```python
class Solution:
    def fourSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        result = list()
        nums_len = len(nums)
        nums.sort()
        
        for i in range(nums_len - 3):
            if (nums[i] << 2) > target: # prune
                break
            if i > 0 and nums[i - 1] == nums[i]:
                continue
                
            for j in range(nums_len-1, i+2, -1):
                if (nums[j] << 2) < target: # prune
                    break
                if j < nums_len-1 and nums[j] == nums[j + 1] :
                    continue
                    
                l, r = i+1, j-1                
                while l < r:
                    if nums[i] + nums[j] + nums[l] + nums[r] == target:
                        result.append([nums[i], nums[j], nums[l], nums[r]])
                        while l < r and nums[l] == nums[l + 1]:
                            l += 1
                        while l < r and nums[r] == nums[r - 1]:
                            r -= 1
                        l += 1
                        r -= 1
                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:
                        l += 1
                    else:
                        r -= 1 
        return result
```

还有没有更快的写法了？有，我们可以将`c+d`的每一种结果添加到查找表中，这样我们只需要遍历`a\b`连个数组，之后在查找表中查找`0 - a - b`就可以解决问题。

我们可以先建立一个`map`存储`nums`中所有不同的`两个数和`，我们记录他在`nums`中的坐标位置。

```python
class Solution:
    def fourSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        nums.sort()
        result = list()
        nums_len = len(nums)
        if nums_len < 4:
            return result
        
        if nums[0] * 4 > target or nums[nums_len - 1] * 4 < target:
            return result

        nums_map = {}
        for i in range(nums_len-1, 0, -1):
            if i < nums_len - 1 and nums[i] == nums[i + 1]:
                continue
            for j in range(i-1, -1, -1):
                if j < i-1 and nums[j] == nums[j + 1]:
                    continue
                if nums[i] + nums[j] not in nums_map:
                    nums_map[nums[i] + nums[j]] = [[j, i]]
                else:
                    nums_map[nums[i] + nums[j]].append([j, i])

        for i in range(nums_len - 3):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            for j in range(i+1, nums_len - 2):
                if j > i + 1 and nums[j] == nums[j - 1]:
                    continue
                
                dif = target - nums[i] - nums[j]
                if dif not in nums_map:
                    continue
                else:
                    for num in nums_map[dif]:
                        if num[0] > j:
                            result.append([nums[i], nums[j], nums[num[0]], nums[num[1]]])
        return result
```

不管是之前的`二数之和`、`三数之和`还是这里的`四数之和`，其实都可以归结为`k数和`问题（根据特定问题有了不同的优化），我将在下一篇文章[k 数和问题](https://blog.csdn.net/qq_17550379/article/details/83023017)中讲述这类问题的终极奥义O(∩_∩)O

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**