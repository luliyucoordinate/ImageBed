---
layout: post
title: Leetcode 119：杨辉三角II（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-10-26 00:00:00
---

给定一个非负索引 *k*，其中 *k* ≤ 33，返回杨辉三角的第 *k* 行。

<center class="half">
    <img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif">
</center>

在杨辉三角中，每个数是它左上方和右上方的数的和。

**示例:**

```
输入: 3
输出: [1,3,3,1]
```

你可以优化你的算法到 *O*(*k*) 空间复杂度吗？

**解题思路**

这个问题是之前[Leetcode 118：杨辉三角（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/83413663)问题的扩展。我们最简单的思路就是将杨辉三角给求出来，然后再返回对应行即可。

```python
class Solution:
    def getRow(self, rowIndex):
        """
        :type rowIndex: int
        :rtype: List[int]
        """
        result = [[1]*(i+1) for i in range(rowIndex+1)]
        for i in range(rowIndex+1):
            for j in range(1,i):
                result[i][j] = result[i-1][j-1] + result[i-1][j]
        return result[rowIndex]
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**