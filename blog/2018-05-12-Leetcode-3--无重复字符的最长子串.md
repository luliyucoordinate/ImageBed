---
layout: post
title: Leetcode 3:无重复字符的最长子串（最详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-05-12 00:00:00
---


给定一个字符串，找出不含有重复字符的**最长子串**的长度。

**示例：**

给定 `"abcabcbb"` ，没有重复字符的最长子串是 `"abc"` ，那么长度就是3。

给定 `"bbbbb"` ，最长的子串就是 `"b"` ，长度是1。

给定 `"pwwkew"` ，最长子串是 `"wke"` ，长度是3。请注意答案必须是一个**子串**，`"pwke"` 是 *子序列*  而不是子串。

**解题思路**

首先想到的解决思路是先遍历整个字符串，然后对遍历到的每个字符后的字符做处理（检查是否有重复元素），我们通过建立一个空的字符串，如果检查的字符在这个空的字符串中没有的话，我们将他加入这个空字符串中，并且记录这个空字符串的长度。

```python
class Solution:
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        maxLength = 0
        for i,_ in enumerate(s):  #这里没有使用range函数      
            count = 0
            usedChar = str()
            for j in s[i:]: 
                if j not in usedChar:
                    usedChar += j
                    count += 1
                    if maxLength < count:#这里没有使用max函数
                        maxLength = count
                else:                   
                    break
        return maxLength
```

上述代码中我没有使用注释中的做法，是因为那样做消耗的时间会增加很多（尤其这里如果使用`max`函数操作会极大地增加时间消耗，但是有的时候使用`max`函数速度会更快，暂时不清楚原因），大家可以自己测试一下。

另外，我们通过分析可以知道这个算法最差情况的时间复杂度是`O(n^2)`级别的，这显然不是我们想看到的。我们分析一下这个算法的缺陷在哪？

```
p w w k e w
i
    j
usedChar = pw
```

当`j`移动到第二个`w`时，这个时候`j in usedChar`，那么我们跳出循环。接着

```
p w w k e w
  i
    j
usedChar = w 
```

这个步骤其实是没有用的，因为去掉一个元素后，不可能比之前的元素更长了。我们可以直接跳到重复元素之后开始新的循环。

```
p w w k e w
    i
    j
usedChar = w 
```

我们这里借用之前[Leetcode 1:两数之和](https://blog.csdn.net/qq_17550379/article/details/80435039)中使用`hash`表的思想。我们只需遍历一遍字符串即可，我们每次遍历的过程中记录当前遍历到的元素之前，离当前位置最近的重复元素位置。例如

```
h a v e f o n o n l e e t c o d e
            ↑     ↑
            l     i
```

当我们遍历到第`i`个元素的时候，我们知道前面`n`重复了，并且重复的`n`最后一个出现在`l`的位置。当然此时`o`也出现了重复，但是我们需要记录离`i`最近的是谁。最后我们只需记录`i-l`的最大值即可。

```python
class Solution:
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        start = maxLength = 0
        usedChar = {}
        for index, char in enumerate(s):
            if char in usedChar and start <= usedChar[char]:
                start = usedChar[char] + 1
            else:
                maxLength = max(maxLength, index - start + 1)
            usedChar[char] = index
        return maxLength
```

这种解法速度很快，时间复杂度是`O(n)`级别，但是空间复杂度也是`O(n)`级别。这也是我认为这个题目目前为止最精彩的回答！！！

当然这个问题，我们也可以使用[Leetcode 209:长度最小的子数组](https://blog.csdn.net/qq_17550379/article/details/80540430)中提到的滑动窗口思想。

```python
class Solution:
    """
    :type s: str
    :rtype: int
    """
    def lengthOfLongestSubstring(self, s):
        l = 0
        r = 0
        maxLength = 0
        s_len = len(s)
        usedChar = [0] * 256 #通过符号表记录符号出现次数
        while l < s_len:
            if r < s_len and usedChar[ord(s[r])] == 0:
                usedChar[ord(s[r])] += 1
                r += 1
            else:
                usedChar[ord(s[l])] -= 1
                l += 1

            maxLength = max(maxLength, r - l)

        return maxLength
```

这个解法虽然比前面的慢，但是空间复杂度是`O(256)`级别，而时间复杂度同样是`O(n)`级别。

该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)

**如有问题，希望大家指出！！！**