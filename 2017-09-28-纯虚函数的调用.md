---
layout: post
title: 抽象类中的数据
category : cpp
tags : [cpp]
---

[纯虚函数的调用问题](http://blog.csdn.net/qq_17550379/article/details/78441310)中我们谈到了我们可以去调用纯虚函数。

```c++
class Abstract_base
{
public:
	virtual ~Abstract_base();
	virtual void interface() = 0;
	const char* mumble() const { return _mumble;}
protected:
	char *_mumble;
};
class Concrete_derived:public Abstract_base
{
public:
	void Concrete_deriverd();
};
inline void Abstract_base::interface() const
{
    function
      //...
}
inline void Concrete_derived::interface() const
{
    Abstract_base::interface();//静态调用
}
```

不过这可以通过静态调用，不可以通过虚拟机制去调用。

有的初学者这里又会有一个疑问，就是我在抽象类的里面设计了一个数据类型，为什么要在一个接口里面设计数据类型呢？因为如果存在“共享数据”的话，这种设计是合理的。

还有一个问题就是我们该怎么去初始化这个数据呢？我们先看看如果不初始化会出现什么问题。

```c++
void foo()
{
    Concrete_derived trouble;//Abstract_base::_mumble未被初始化
}
```

你看到了问题吗？派生类没有初始化这个数据。那是不是把这个初始化任务交给派生类去做，而不是交给抽象类去做呢？该怎么做呢？

确实，应该由派生类去初始化这个数据。做法如下：

```c++
class Abstract_base
{
public:
	virtual ~Abstract_base();
	virtual void interface() = 0;
	const char* mumble() const { return _mumble;}
protected:
	Abstract_base(char *pc = 0);//增加
	char *_mumble;
};
```

要使用派生类去初始化基类的数据，派生类的唯一要求就是基类必须提供带有唯一参数的保护类型的构造函数。

一般而言class的data member应该被初始化，并且只在constructor中或class的其他member functions中指定初值。其他任何操作都将会破坏封装型，使class的维护变得困难。