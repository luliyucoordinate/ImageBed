---
layout: post
title: Leetcode 303:区域和检索-数组不可变（超详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-9 00:00:00
---

给定一个整数数组  *nums*，求出数组从索引 *i* 到 *j*  (*i* ≤ *j*) 范围内元素的总和，包含 *i,  j* 两点。

**示例：**

```
给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3
```

**说明:**

1. 你可以假设数组不可变。
2. 会多次调用 *sumRange* 方法。

**解题思路**

这个问题非常简单，首先可以想到的是暴力破解。

```python
class NumArray:
    def __init__(self, nums):
        """
        :type nums: List[int]
        """
        self.nums = nums

    def sumRange(self, i, j):
        """
        :type i: int
        :type j: int
        :rtype: int
        """
        return sum(self.nums[i:j+1])
```

居然通过了。因为题目中的条件**数组不可变**，所以对于这个问题其实有一个更好的思路。例如

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/303/2019_1_9_1.png" width="400">
</center>

然后我们将数不断向后累加。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/303/2019_1_9_2.png" width="430">
</center>

当我们要求`[left,right]`区间内的和的时候，我们只需要用`sum[right]-sum[left-1]`即可。

```python
class NumArray:

    def __init__(self, nums):
        """
        :type nums: List[int]
        """
        self.nums = [0]+nums
        for i in range(len(self.nums)):
            self.nums[i] += self.nums[i-1]

    def sumRange(self, i, j):
        """
        :type i: int
        :type j: int
        :rtype: int
        """
        return self.nums[j+1] - self.nums[i]
```

这里我们可以使用`itertools.accumulate`函数。

```python
from itertools import accumulate
class NumArray:

    def __init__(self, nums):
        """
        :type nums: List[int]
        """
        self.nums = [0]+list(accumulate(nums))

    def sumRange(self, i, j):
        """
        :type i: int
        :type j: int
        :rtype: int
        """
        return self.nums[j+1] - self.nums[i]
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**