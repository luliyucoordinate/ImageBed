---
layout: post
title: Leetcode 1018：可被 5 整除的二进制前缀（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-3-31 00:00:00
---

给定由若干 `0` 和 `1` 组成的数组 `A`。我们定义 `N_i`：从 `A[0]` 到 `A[i]` 的第 `i` 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。

返回布尔值列表 `answer`，只有当 `N_i` 可以被 `5` 整除时，答案 `answer[i]` 为 `true`，否则为 `false`。

**示例 1：**

```
输入：[0,1,1]
输出：[true,false,false]
解释：
输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。
```

**示例 2：**

```
输入：[1,1,1]
输出：[false,false,false]
```

**示例 3：**

```
输入：[0,1,1,1,1,1]
输出：[true,false,false,false,true,false]
```

**示例 4：**

```
输入：[1,1,1,0,1]
输出：[false,false,false,false,false]
```

**提示：**

1. `1 <= A.length <= 30000`
2. `A[i]` 为 `0` 或 `1`

**解题思路**

这个问题非常简单，我们定义一个变量`cur=0`，然后遍历`A`中的元素`i`，对`cur<<1`，然后加上`i`，判断结果是不是可以整除`5`即可。

```python
class Solution:
    def prefixesDivBy5(self, A: List[int]) -> List[bool]:
        res, cur = list(), 0
        for i in A:
            cur <<= 1
            cur += i
            if cur % 5 == 0:
                res.append(True)
            else:
                res.append(False)
        return res
```

但是上面的这种写法有一点漏洞，因为在`cur+=i`的过程中我们可能会发生溢出。所以，我们可以每次都取摸。一个简洁的写法

```python
class Solution:
    def prefixesDivBy5(self, A: List[int]) -> List[bool]:
        for i in range(1, len(A)):
            A[i] += A[i - 1] * 2 % 5
        return [a % 5 == 0 for a in A]
```

reference:

https://leetcode.com/problems/binary-prefix-divisible-by-5/discuss/265509/Python-Calculate-Prefix-Mod

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**