---
layout: post
title: Leetcode 1027：最长等差数列（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-4-15 00:00:00
---

给定一个整数数组 `A`，返回 `A` 中最长等差子序列的**长度**。

回想一下，`A` 的子序列是列表 `A[i_1], A[i_2], ..., A[i_k]` 其中 `0 <= i_1 < i_2 < ... < i_k <= A.length - 1`。并且如果 `B[i+1] - B[i]`( `0 <= i < B.length - 1`) 的值都相同，那么序列 `B` 是等差的。

**示例 1：**

```
输入：[3,6,9,12]
输出：4
解释： 
整个数组是公差为 3 的等差数列。
```

**示例 2：**

```
输入：[9,4,7,2,10]
输出：3
解释：
最长的等差子序列是 [4,7,10]。
```

**示例 3：**

```
输入：[20,1,15,3,10,5,8]
输出：4
解释：
最长的等差子序列是 [20,15,10,5]。
```

**提示：**

1. `2 <= A.length <= 2000`
2. `0 <= A[i] <= 10000`

**解题思路**

首先不难想到暴力法，先确定前两个元素，通过前两个元素确定等差数列的差`x`，然后再通过一个变量向后找差为`x`的后续部分。

```python
class Solution:
    def longestArithSeqLength(self, A: List[int]) -> int:
        res, n = 2, len(A)
        for i in range(n-2):
            for j in range(i+1, n-1):
                pre, tmp = j, 2
                d = A[j] - A[i]
                for k in range(j+1, n):
                    if A[k] - A[pre] == d:
                        tmp += 1
                        pre = k
                res = max(res, tmp)
        return res
```

这种算法的时间复杂度是`O(n^3)`，显然是非常慢的。

实际上这个问题和之前问题[Leetcode 300：最长上升子序列（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82871892)非常类似，我们可以使用动态规划来做。我们知道对于等差数列有三种情况

- 上升
- 下降
- 不变

我们可以先定义函数$f(x)$表示以$x$结尾的最长等差数列，那么对于第一种情况就会有下面式子

- $f(x)=1+f(y)\ if\ A[x]>A[y]\ and\ A[x]-A[y]=v$

解释一下这个式子，我们假设等差数列的差为$dis=v$，对于$y\in[0,x)$，存在$A[x]>A[y]$并且$A[x]-A[y]=v$，那么$f(x)=1+f(y)$。同理对于`下降`和`不变`，我们同样可以得到下面两个式子

- $f(x)=1+f(y)\ if\ A[x]<A[y]\ and\ A[y]-A[x]=v$
- $f(x)=1+f(y)\ if\ A[x]=A[y]\ and\ A[x]-A[y]=0$

其实你会发现，当我们不考虑$x$和$y$的前后顺序的时候，上面三个式子表述的是一个式子。

```python
class Solution:
    def longestArithSeqLength(self, A: List[int]) -> int:
        mem = [collections.defaultdict(int) for _ in A]
        res = 1
        for i in range(len(A)):
            for j in range(i+1, len(A)):
                v = A[j] - A[i]
                mem[j][v]=max(mem[i][v] + 1, mem[j][v])
                res = max(res, mem[j][v])
        return res + 1
```

一个更`pythonic`的写法

```python
class Solution:
    def longestArithSeqLength(self, A: List[int]) -> int:
        mem = collections.defaultdict(int)
        for i in range(len(A)):
            for j in range(i + 1, len(A)):
                v = A[j] - A[i]
                mem[v, j] = max(mem[v, j], mem[v, i] + 1)
        return max(mem.values()) + 1
```

我们将代码优化到了`O(n^2)`。

reference:

https://leetcode.com/problems/longest-arithmetic-sequence/discuss/274611/JavaC%2B%2BPython-DP

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**