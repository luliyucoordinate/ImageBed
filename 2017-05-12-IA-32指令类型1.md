---
layout: post
title: IA-32指令类型（1）
category : 计算机系统原理
tags : [notes, 原理]
stickie: true
---


传送指令
===

通用数据传送指令
---
MOV：一般传送，包括movb、movw、movl  
MOVS：符号传送，如movsbw、movswl  
MOVZ：零扩展传送，如movzwl、movzbl  
XCHG：数据交换  
PUSH/POP：入栈出栈，如pushl、pushw、popl、popw  
入栈sp-，出栈sp+

地址传送指令
---
LEA：加载有效地址，如leal (%edx,%eax),%eax的功能为R[eax]<-R[edx]+R[eax]，执行前，若R[edx]=i,R[eax]=j，则执行指令后，R[eax]=i+j

输入输出指令
---
IN和OUT：I/O端口与寄存器之间的交换

标志传送指令
---
PUSHF、POPF：将EFLAG压栈，或将栈顶内容送EFLAG

定点算术运算指令
===

加减运算指令（影响标志、不区分无/带符号）
---
ADD：加，包括addb、addw、addl  
SUB：减，包括subb、subw、subl  
假设R[ax]=fffah，R[bx]=fff0h，则执行指令后“addw %bx,%ax”  
R[ax]=fffah+fff0h=ffeah，bx中内容不变  
CF=1，OF=0，ZF=0，SF=1  
若是无符号数运算，则CF=1说明结果溢出  
若是带符号整数运算，则OF=0说明结果没有溢出

增1/减1运算（影响除CF以外的标志、不区分无/带符号）
---
INC：加，包括incb、incw、incl  
DEC：减，包括decb、decw、decl

取负运算（影响标志、若对0取负、则结果为0且CF清0，否则CF置1）
---
NEG：取负，包括negb、negw、negl

比较运算（做减法得到标志、不区分无/带符号）
---
CMP：比较，包括cmpb、cmpw、cmpl

乘/除运算（不影响标志、区分无/带符号）
---
MUL/IMUL：无符号乘/带符号乘  
DIV/IDIV：无符号乘/带符号乘  
乘法指令：可以给出一个、两个或三个操作数  
若给出一个操作数SRC，则另一个源操作数隐含在AL/AX/EAX中，将SRC和累加器内容相乘，结果存放在AX或DX-AX或EDX-EAX中。DX-AX表示32位乘积的高、低位分别在DX和AX中。n*n=2n  
若指令中给出两个操作数DST和SRC，则将DST和SRC相乘，结果在DST中。n*n=n  
若指令给出三个操作数REG、SRC、IMM，则将SRC和立即数IMM相乘，结果在REG中。n*n=n  
除法指令：只明显指出除数，用EDX-EAX中内容除以指定的除数  
若为8位，则16位被除数在AX寄存器中，商送回AL，余数在AH  
若为16位，则32位被除数在DX-AX寄存器中，商送回AX，余数在DX  
若为32，则被除数在EDX-EAX寄存器中，商送EAX，余数在EDX  
假设R[eax]=000000b4h，R[ebx]=00000011h，M[000000f8h]=000000a0h，执行下面指令mulb %bl功能为$$R[ax]<-R[al]*R[bl]$$，执行结果    $$R[ax]=b4h*11h=0bf4h$$(无符号整数180和17相乘)  
$$R[ax]=b4h*11h=faf4h$$(带符号整数-76和17相乘)  
对于带符号数乘，若乘积只取低n位，则和无符号数相同；若取2n位，则采用布斯乘法。  
执行$$imull -16,(\%eax,\%ebx,4),\%eax$$功能为$$R[eax]<-(-16)*M[R[eax]+R[ebx]*4]$$，执行结果为  
$$R[eax]+R[ebx]*4=000000b4h+00000011h<<2=000000f8h$$  
$$R[eax]=-16*M[000000f8h]=16*(-000000a0h)=ffffff60h<<4=fffff600h$$  

按位运算指令
===

逻辑运算
---
NOT：非，包括notb、notw、notl  
AND：与，包括andb、andw、andl  
OR：或，包括orb、orw、orl  
XOR：异或，包括xorb、xorw、xorl  
TEST：做“与”操作测试，仅影响标志  
只有not指令不影响标志，其他指令OF=CF=0，而ZF和SF则根据结果设置：若全0，则ZF=1；若最高位为1，则SF=1  
假设M[0x1000]=00000f89h,M[0x1004]=000001270h,R[eax]=ff000001h,R[ecx]=00001000h  

```
notw %ax R[ax]=fffeh;  
andl %eax,(%ecx)=00000f89h^ff000001h=00000001h  
orb 4(%ecx),%al=70h | 01h=71h
```

移位运算（左/右移时，最高/最低位送CF）
---
SHL/SHR：逻辑左/右移，包括shlb，shrw，shrl  
SAL/SAR：算数左/右移，左移要判断溢出，右移高位补符号（移位前、后符号位发生变化，则OF=1）包括salb、sarw、sarl  
ROL/ROR：循环左/右移，包括rolb、rorw、roll  
RCL/RCR：带进位循环左/右移，即：将CF作为操作数一部分循环移位，包括rclb、rcrw、rcll  
假设short型变量x被编译器分配在寄存器AX中，R[ax]=ff80h,则以下汇编代码执行后变量x的机器数和真值  

```
movw %ax,%dx    R[dx]<-R[ax]  
salw $2,%ax    1111 1111 1000 0000<<2  
addl %dx,%ax    1111 1110 0000 0000 +1111 1111 1000 0000  
sarw $1,%ax    1111 1101 1000 0000>>1=1111 1110 1100 0000  
```
\$2与\$1表示立即数2和1。

