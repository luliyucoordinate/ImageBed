---
layout: post
title: Leetcode 530：二叉搜索树的最小绝对差（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-2-16 00:00:00
---

给定一个所有节点为非负值的二叉搜索树，求树中任意两节点的差的绝对值的最小值。

**示例 :**

```
输入:

   1
    \
     3
    /
   2

输出:
1

解释:
最小绝对差为1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
```

**注意:** 树中至少有2个节点。

**解题思路**

我们很容易想到一个笨方法，就是通过遍历将树中的元素存放到一个数组中，然后对数组进行排序，最后我们遍历排好序的数组，比较前后元素取出差的绝对值的最小值即可。

```python
class Solution:
    def getMinimumDifference(self, root: 'TreeNode') -> 'int':
        tree = list()
        def preOrder(root):
            if root:
                tree.append(root.val)
                preOrder(root.left)
                preOrder(root.right)
        
        preOrder(root)
        tree.sort()
        pre, res = tree[0], float('inf')
        for cur in tree[1:]:
            res = min(res, cur - pre)
            pre = cur
        return res
```

因为这是一个二叉树，显然我们应该还有更加合适的做法。我们知道二叉树中序遍历是一个有序数组，所以上面的做法我们使用中序遍历的话，我们就不用对结果数组进行排序了。

我们也可以通过一个变量`pre`记录之前元素的大小，然后中序遍历数组的过程中比较当前元素和之前元素的差值即可，这样我们就不用通过数组去记录中间结果了。

```python
class Solution:
    def getMinimumDifference(self, root: 'TreeNode') -> 'int':
        res, pre = float('inf'), float('-inf')
        
        def inOrder(root):
            nonlocal res, pre
            if root:
                inOrder(root.left)
                res = min(res, root.val - pre)
                pre = root.val
                inOrder(root.right)
                
        inOrder(root)
        return res
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**