---
layout: post
title: IA-32指令类型（2）
category : 计算机系统原理
tags : [notes, 原理]
stickie: true
---


控制转移指令
===

指令执行可按顺序或跳转到转移目标指令处执行  
无条件转移指令  
JMP DST：无条件转移到目标指令DST处执行  
条件转移指令  
Jcc DST：cc为条件码，根据标志判断是否满足条件，若条件满足，则转移到目标指令DST处执行，否则按顺序执行  
条件设置  
SET cc DST ：按条件码cc判断的结果保存到 DST（8位寄存器）  
调用和返回指令  
CALL DST：返回地址RA入栈，转DST处执行  
RET：从栈中取出返回地址RA，转到RA  
中断指令

```c
int sum(int a[],unsigned len)
{
	int i,sum = 0;
	for(i =0; i <= len-1; ++i)
	{
		sum += a[i];
	}
	return sum;
}
```
当参数len为0时，返回值应该是0，但是在机器上执行时，却发生了存储器访问异常。  
原因在于len是一个无符号数，len-1得到的是32个1所以，循环时会无限循环，所以这里再次告诉我们尽量不要使用unsigned。  

X87浮点处理指令 
===
IA-32中处理的浮点数类型有三种：float（32位IEEE 754）、double（64位IEEE 754）、long double（80位双精度扩展格式）  
1位符号位s、15位阶码e（偏致常数16383）、1位显示首位有效位j和63位尾数f。它与IEEE 754单精度和双精度浮点格式的一个重要区别是：他没有隐藏位，有效位共64位。  

```c
#include <stdio.h>
double f(int x){
	return 1.0/x;
}
void main()
{
	double a,b;
	int i;
	a = f(10);
	b = f(10);
	i = a== b;
	printf("%d\n", i);
}
#include <stdio.h>
double f(int x){
	return 1.0/x;
}
void main()
{
	double a,b,c;
	int i;
	a = f(10);
	b = f(10);
	c = f(10);
	i = a== b;
	printf("%d\n", i);
}
```
在早期的gcc编译器中，程序一结果0，程序二结果1，原因在于对于数据结果存储时有数据丢失。

```c
#include <stdafx.h>
int main()
{
	int a = 10;
	double*p = (double *)&a;
	printf("%f\n", *p);//0.000000
	printf("%f\n", (double)a);//10.000000
	return 0;
}
```
前后两次打印结果不一样，原因在于后面一种做法是使用了转换指令先把int转为double，而第一个没有。

```
	printf("%f\n", *p);//0.000000
00FB1795  mov         eax,dword ptr [p]  
00FB1798  sub         esp,8  
00FB179B  movsd       xmm0,mmword ptr [eax]  
00FB179F  movsd       mmword ptr [esp],xmm0  
00FB17A4  push        offset string "%f\n" (0FB6B30h)  
00FB17A9  call        _printf (0FB1316h)  
00FB17AE  add         esp,0Ch  
	printf("%f\n", (double)a);//10.000000
00FB17B1  cvtsi2sd    xmm0,dword ptr [a]  
00FB17B6  sub         esp,8  
00FB17B9  movsd       mmword ptr [esp],xmm0  
00FB17BE  push        offset string "%f\n" (0FB6B30h)  
00FB17C3  call        _printf (0FB1316h)  
00FB17C8  add         esp,0Ch  
```
从汇编我们可以看到第二个打印函数中出现了一个cvsi2sd，而这个指令就是用于将双字整数转换成标量双精度浮点值

MMX及SSE指令
===

MMX指令使用8个64位寄存器MM0~MM7，借用8个80位寄存器ST(0)~ST(7)中的64位尾数所占的位，可同时处理8个字节，或4个字，或2个双字，或一个64位数据，是一种SIMD技术。SSE是在MMX基础上提出来的。单指令多数据技术。  
SSE指令集价格80位浮点寄存器扩充到128位多媒体扩展通用寄存器XMM0~XMM7，可同时处理16个字节，或8个字，或4个双字，或两个字节的数据。
