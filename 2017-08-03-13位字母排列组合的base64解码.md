---
layout: post
title: 	13位字母排列组合的base64解码
category : python
tags : [python, 算法, 排列组合]
stickie: true
---

今天碰到这样一个问题：小明今天去妹纸家开 Party, 而妹纸却给他出了一个谜语, 说只要他能答出来, 她就会答应小明一个要求。这是妹纸给小明的谜语序列:`AGV5IULSB3ZLVSE=`

第一眼看到这个字符串，认为是base64加密，随即解密后是一串乱码，问题果然没有这么简单。再仔细看，发现字符串全是英文大写，所以猜测可能将小写改为了大写，总共有8192 种变化

先看这样的做法：

```python
from base64 import *
import re
def basepass(res, arr, pos):
	res.append(''.join(arr))
	i = pos
	for i in xrange(i, len(arr)):
		if arr[i] >= 'A' and arr[i] <= 'Z':
            #这个解法非常妙，有点类似于排列的做法
			arr[i] = arr[i].lower() 	#先挑选一个字母变为小写
			basepass(res, arr, i + 1)	#从剩余的子母中挑选一个字母变为小写
			arr[i] = arr[i].upper()		#原先变为小写的字母变为大写

arr = list('AGV5IULSB3ZLVSE=')
res = []
basepass(res, arr, 0)

res_decode = map(b64decode, res)

for i in res_decode:
	if re.findall(r'\\x', repr(i)):		#这里有一个陷阱，可以参看我的另一篇文章
		continue
	else:
		print i
```

另一种做法是：

```python
import base64,re
from itertools import combinations
s=list('AGV5IULSB3ZLVSE=')

for i in range(len(s)):
    for j in list(combinations([x for x in range(len(s))], i)): #combinations是一个组合函数
        a=list(s)
        for k in j:
           a[k]= a[k].lower()

        r=repr(base64.b64decode(''.join(a)))
        if '\\x' not in r:
            print r[1:-1]
```