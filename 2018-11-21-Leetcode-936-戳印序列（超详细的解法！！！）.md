---
layout: post
title: Leetcode 936：戳印序列（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-21 00:00:00
---

你想要用**小写字母**组成一个目标字符串 `target`。 

开始的时候，序列由 `target.length` 个 `'?'` 记号组成。而你有一个小写字母印章 `stamp`。

在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章上的相应字母。你最多可以进行 `10 * target.length`  个回合。

举个例子，如果初始序列为 "?????"，而你的印章 `stamp` 是 `"abc"`，那么在第一回合，你可以得到 "abc??"、"?abc?"、"??abc"。（请注意，印章必须完全包含在序列的边界内才能盖下去。）

如果可以印出序列，那么返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成。如果不能印出序列，就返回一个空数组。

例如，如果序列是 "ababc"，印章是 `"abc"`，那么我们就可以返回与操作 "?????" -> "abc??" -> "ababc" 相对应的答案 `[0, 2]`；

另外，如果可以印出序列，那么需要保证可以在 `10 * target.length` 个回合内完成。任何超过此数字的答案将不被接受。

**示例 1：**

```
输入：stamp = "abc", target = "ababc"
输出：[0,2]
（[1,0,2] 以及其他一些可能的结果也将作为答案被接受）
```

**示例 2：**

```
输入：stamp = "abca", target = "aabcaca"
输出：[3,0,1]
```

**提示：**

1. `1 <= stamp.length <= target.length <= 1000`
2. `stamp` 和 `target` 只包含小写字母。

**解题思路**

我们首先想到的最简单的方法是通过倒退回到初始点。对于第一个例子的`target`，如果我们退回一步的话就变成了`ab???`，接着再退回一步就变成了`?????`（也就是初始状态）。我们只要倒退的过程中记录`stamp`在`target`中的位置即可。依照这个思路去做的话，我们上来会碰到的问题就是**如何替换stamp为?**。一个非常简单的思路就是从头到尾的遍历和`target`找可以和`stamp`匹配的位置（`?`可以和所有字符匹配），使用的方法是最简单的逐个字符比较，如果匹配成功，我们还要检查`target`是不是都是`?`，如果都是的话，那么显然我们已经有结果了，不需要继续下去了。

我们还有一个边界情况需要考虑，也就是如果我们从头至尾没有匹配到任何的`stamp`的话，我们应该返回`list()`。

```python
class Solution:
    def movesToStamp(self, stamp, target):
        """
        :type stamp: str
        :type target: str
        :rtype: List[int]
        """
        t_len, s_len, target = len(target), len(stamp), list(target)
        
        def check(i):
            for a, b in zip(target[i:i + s_len], stamp):
                if a != '?' and a != b: 
                    return False
            for a in target[i:i + s_len]:
                if a != '?': 
                    return True
            return False

        done, moves = ['?']*t_len, list()
        
        while target != done:
            move = False
            for i in range(t_len - s_len + 1):
                if check(i):
                    move = True
                    moves.append(i)
                    target[i:i + s_len] = done[:s_len]
            if not move: 
                return list()
                
        return list(reversed(moves))
```

这个问题显然还可以通过递归去解决。思路也非常简单，我们通过一个

```
s:a b c
  i
t:a b a b c
  j
```



```python

```



reference:

https://leetcode.com/problems/stamping-the-sequence/discuss/189502/C++Python-12ms-Reverse-and-Greedy-O(N2M)

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**