---
layout: post
title: Leetcode 687：最长同值路径（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-2-15 00:00:00
---

给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

**注意**：两个节点之间的路径长度由它们之间的边数表示。

**示例 1:**

输入:

```
              5
             / \
            4   5
           / \   \
          1   1   5
```

输出:

```
2
```

**示例 2:**

输入:

```
              1
             / \
            4   5
           / \   \
          4   4   5
```

输出:

```
2
```

**注意:** 给定的二叉树不超过10000个结点。 树的高度不超过1000。

**解题思路**

类似问题

[Leetcode 124：二叉树中的最大路径和（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/85323011)

[Leetcode 543：二叉树的直径（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/87374047)

我们定义函数`longestUnivalue`返回左右两边其中最大的路径长度，此时我们有四种情况考虑

- `root.left == root == root.right`
- `root.left == root`
- `root.right == root`
- `root.left ！= root != root.right `

对于第一种情况此时左右孩子和根相同，我们需要更新我们的最大长度`res=max(res,l+r+2)`，并且返回`max(l,r)+1`。对于第二种情况，此时左孩子和根相同，我们需要更新我们的最大长度`res=max(res,l+1)`，并且返回`l+1`。对于第三种情况，此时右孩子和根相同，我们需要更新我们的最大长度`res=max(res,r+1)`，并且返回`r+1`。对于第四种情况，此时只需返回`0`即可。

```python
class Solution:
    def longestUnivaluePath(self, root: 'TreeNode') -> 'int':
        res = 0
        def longestUnivalue(root):
            nonlocal res
            if not root:
                return 0
            l = longestUnivalue(root.left)
            r = longestUnivalue(root.right)
            if root.left and root.right and root.left.val == root.val == root.right.val:
                res = max(res, l + r + 2)
                return max(l, r) + 1
            elif root.left and root.left.val == root.val:
                res = max(res, l+1)
                return l + 1
            elif root.right and root.right.val == root.val:
                res = max(res, r+1)
                return r + 1
            else:
                return 0
            
        longestUnivalue(root)
        return res
```

稍微简化一下上面的代码

```python
class Solution:
    def longestUnivaluePath(self, root: 'TreeNode') -> 'int':
        res = 0
        def longestUnivalue(root):
            nonlocal res
            if not root:
                return 0
            l = longestUnivalue(root.left)
            r = longestUnivalue(root.right)
            pl, pr = 0, 0
            if root.left and root.left.val == root.val:
                pl = l + 1
            if root.right and root.right.val == root.val:
                pr = r + 1
            res = max(res, pl + pr)
            return max(pl, pr)
            
        longestUnivalue(root)
        return res
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**