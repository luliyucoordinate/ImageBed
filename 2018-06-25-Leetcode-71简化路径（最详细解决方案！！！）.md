---
layout: post
title: Leetcode 71:简化路径（最详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-06-25 00:00:00
---

以 Unix 风格给出一个文件的**绝对路径**，你需要简化它。或者换句话说，将其转换为规范路径。

在 Unix 风格的文件系统中，一个点（`.`）表示当前目录本身；此外，两个点 （`..`） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：[Linux / Unix中的绝对路径 vs 相对路径](https://blog.csdn.net/u011327334/article/details/50355600)

请注意，返回的规范路径必须始终以斜杠 `/` 开头，并且两个目录名之间必须只有一个斜杠 `/`。最后一个目录名（如果存在）**不能**以 `/` 结尾。此外，规范路径必须是表示绝对路径的**最短**字符串。

**示例 1：**

```
输入："/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。
```

**示例 2：**

```
输入："/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。
```

**示例 3：**

```
输入："/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
```

**示例 4：**

```
输入："/a/./b/../../c/"
输出："/c"
```

**示例 5：**

```
输入："/a/../../b/../c//.//"
输出："/c"
```

**示例 6：**

```
输入："/a//b////c/d//././/.."
输出："/a/b/c"
```

**解题思路**

思路很简单，我们首先使用`path.split('/')`将字符串切开，然后判断`path.split('/')`中每个元素。如果`=='.'`，我们继续判断下一个。如果`=='..'`，我们`len(stack) != 0`，弹出一个元素。否则我们将这个元素添加到`stack`中。

```python
class Solution:
    def simplifyPath(self, path):
        """
        :type path: str
        :rtype: str
        """
        stack = list()
        path = [p for p in path.split('/') if p]
        for f in path:
            if f == '.': 
                continue
            elif f == '..': 
                if stack: 
                    stack.pop()
            else: 
                stack.append(f)

        return '/'+'/'.join(stack)
```

那么这里有一个问题，我们在`c++`中没有`split`怎么办？我们可以通过`stringstream`模拟这种操作。具体做法如下：

```c++
string tmp;
stringstream s(path);
while (getline(s, tmp, '/')){}
```

**这里要注意一个问题是，在`c++`中对于`空字符串`的判断是`true`。 **

一个`pythonic`的写法

```python
class Solution:
    def simplifyPath(self, path):
        """
        :type path: str
        :rtype: str
        """
        import os.path
        return os.path.abspath(path)
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**