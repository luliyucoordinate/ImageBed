---
layout: post
title: 迭代器种类
category : cpp
tags : [cpp, notes, cpp标准库, 迭代器]
---


Output迭代器
---

输出迭代器（OutputIterator）是能写入所指元素的迭代器（Iterator）。  
实现输出迭代器（OutputIterator）的类型的例子是 std::ostream_iterator。  
当向前迭代器（ForwardIterator）、双向迭代器（BidirectionalIterator）或随机访问迭代器（RandomAccessIterator）在自身的要求之上满足的输出迭代器（OutputIterator）要求时，它被描述为可变的。  

Input迭代器
---

输入迭代器（InputIterator）是能从所指向元素读取的迭代器（Iterator）。输入迭代器（InputIterator）仅保证单趟算法的合法性：一旦 InputIterator i 被自增，则所有其先前值的副本都可能变得非法。  
Input迭代器只能读取元素一次。如果你复制input迭代器，并令源input迭代器和新产生的拷贝都向前读取，可能会遍历到不同的值。  

Forward（前向）迭代器
---
向前迭代器（ForwardIterator）是一种能从所指向元素读取数据的迭代器（Iterator）。  
不同于输入迭代器（InputIterator）和输出迭代器（OutputIterator），它能被用于多趟算法。  
和input迭代器不同的是，两个forward迭代器如果指向同一个元素，operator==会获得true，如果两者都递增，会再次指向同一元素。  
有以下对象和类型提供：  
1.	class forward_list<>
2.	unordered容器

Bidirectional（双向迭代器）
---

双向迭代器（BidirectionalIterator）是能双向移动（即自增与自减）的向前迭代器（ForwardIterator）。  
有以下对象和类型提供：  
1.	class list<>
2.	associative容器

RandomAccess（随机访问）迭代器
---

随机访问迭代器（RandomAccessIterator）是能在常数时间内移动到指向任何元素的双向迭代器（BidirectionalIterator）。  
指向数组元素的指针满足所有随机访问迭代器（RandomAccessIterator）的要求。  
有以下对象和类型提供：  
1.	可随机访问的容器（array、vector、deque）
2.	string（string、wstring）
3.	寻常的c-style（pointer）


Vector迭代器的increment和decrement
---
一般而言你可以递增或递减临时性迭代器，但对于array、vector和string就不行。例子：  

```c++
std::vector<int> coll;
if(coll.size() > 1)
{
	std::sort(++coll.begin(), coll.end());
}
```
编译++coll.begin可能会失败，但是如果使用的是deque就不会。原因是，vector、array和string的迭代器通常被实现为寻常pointer，而C++并不允许你修改任何基础类型的临时类型（包括pointer）的临时对象，但对于struct和class就允许。  
因此，上面的代码对于vector、array和string以外的容器都没问题，因为那些容器的迭代器都不可能是寻常pointer。但对于vector、array和string，上面的代码是否可行就取决于具体实现。  
在c++11之前的做法是使用一个辅助对象::  

```c++
std::vector<int> coll;
if(coll.size() > 1)
{
	std:vector<int>::iterator beg = coll.begin();
	std::sort(++beg, coll.end());
}
```
C++11之后可以使用next   

```c++
std::vector<int> coll;
if(coll.size() > 1)
{
	std::sort(std::next(coll.begin()), coll.end());
}
```