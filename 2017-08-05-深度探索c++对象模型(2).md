---
layout: post
title: 深度探索c++对象模型(2)
category : cpp
tags : [cpp]
stickie: true
---

通常很多C++程序员存在两种误解：

- 没有定义默认构造函数的类都会被编译器生成一个默认构造函数。

-  编译器生成的默认构造函数会明确初始化类中每一个数据成员。

  ​

C++标准规定：如果类的设计者并未为类定义任何构造函数，那么会有一个默认构造函数被暗中生成，而这个暗中生成的默认构造函数通常是不做什么事的(无用的)，下面四种情况除外。

-  包含有带默认构造函数的对象成员的类

-   继承自带有默认构造函数的基类的类

-  带有虚函数的类

-  带有一个虚基类的类

   ​

如果类虚继承自基类，编译器将在所有构造函数中插入准备虚基类位置的代码和提供支持虚基类机制的代码。

如果类声明有虚函数，那么编译器将为之生成虚函数表以存储虚函数地址，并将虚函数指针（vptr）的初始化代码插入到类的所有构造函数中。

如果类的父类有默认构造函数，编译将会对所有的默认构造函数插入调用其父类必要的默认构造函数。必要是指设计者没有显示初始化其父类，调用顺序，依照其继承时声明顺序。

如果类包含带有默认构造函数的对象成员，那么编译器将会为所有的构造函数插入对这些对象成员的默认构造函数进行必要的调用代码，所谓必要是指类设计者设计的构造函数没有对对象成员进行显式初始化。成员对象默认构造函数的调用顺序，依照其声明顺序。

若类没有定义任何构造函数，编译器会为其合成默认构造函数，再执行上述四点。

C++标准将合成的默认构造函数分为 `trivial` 和 `notrivial` 两种，前文所述的四种情况对应于`notrivia`l默认构造函数，其它情况都属于`trivial`。对于一个`trivial`默认构造函数，编译器的态度是，既然它全无用处，干脆就不合成它。
