---
layout: post
title: 字节跳动2019笔试：字符串展开（超详细的解法！！！）
category : 算法
tags : [bytedance, string]
stickie: true
date: 2019-6-25 00:00:00
---

小赵和小钱在练字，小钱对小赵说：你知道吗，我练习的字是有蕴含的。

小赵不服气了，凭什么你的就有蕴含呢？

小钱说，你所看到的并不是我真正练习的字，你需要将我现在写下的字符串里面“%”和“#”之间的字重复符号前的那么多倍，才能看到我真正写的是什么。

你能帮帮小赵吗？

说明：可能存在嵌套的情况，如“3%g2%n##”，返回“gnngnngnn”，输入输出的字符串长度都不超过10000。

输入字符串保证合法，且输出的字符串中只包含大小写英文字母。

**输入格式**

一行带数字和嵌套括号的字符串。

**输出格式**

展开的字符串。

**输入样例**：

```
3%acm#2%acm#
```

**输出样例**：

```
acmacmacmacmacm
```

**解题思路**

这个问题首先不难通过`dfs`处理，我们看一下要处理的边界情况（假设当前遍历到的字符是`str[u]`）

- 如果`str[u]`是数字的话，我们需要继续向后遍历直到`%`（也就是将数字遍历完）
- 如果`str[u]=='%'`，此时我们需要将`++u`，然后递归下去，将递归的结果添加到结果字符串中
- 如果`str[u]=='#'`，此时返回结果字符串即可
- 如果`str[u]`是字符的话，我们将该字符添加到结果字符串中即可

```cpp
#include <iostream>
using namespace std;

int n, u;
string str;
string dfs()
{
    int num = 0;
    string res;
    while (u < n)
    {
        if (str[u] >= '0' && str[u] <= '9')
        {
            num = num * 10 + str[u] - '0';
        }
        else if (str[u] == '%')
        {
            ++u;
            string post = dfs();
            while (num--) res += post;
            num = 0;
        }
        else if (str[u] == '#') return res;
        else res += str[u];
        ++u;
    }
    return res;
}

int main()
{
    cin >> str;
    n = str.size(), u = 0;
    cout << dfs() << endl;
}
```

**如有问题，希望大家指出！！！**