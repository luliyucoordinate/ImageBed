---
layout: post
title: Leetcode 53：最大子序和（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-10-08 00:00:00
---

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例:**

```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为6。
```

**进阶:**

如果你已经实现复杂度为 O(*n*) 的解法，尝试使用更为精妙的分治法求解。

**解题思路**

我们首先可以想到的解法就是暴力解法。我们通过`i`和`j`记录子序列的左右边界，然后遍历所有的边界，寻找区间`[i:j]`和最大是多少即可。

```python
class Solution:
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        res = 0
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                res = max(res, sum(nums[i:j]))
                
        return res
```

这个问题通过递归可以很快速的解决。我们定义函数$f(i)$表示以`nums[i]`结尾的最大子序列和，那么$f(i)=max(f(i-1)+nums[i], nums[i])$。也就是我们要知道`[0:i]`这个区间内的最大值`cur`，那么我们只需要知道`[0:i-1]`这个区间内的最大值`pre`，那么`cur=max(pre+nums[i], nums[i])`。

然后下面这段逻辑就顺理成章了

```python
class Solution:
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        res = float('-inf')
        for i in range(len(nums)):
            cur = self._maxSubArray(nums, i)
            res = max(res, cur)
            
        return res

    def _maxSubArray(self, nums, index):
        if index == 0:
            return nums[0]

        pre = self._maxSubArray(nums, index - 1)
        cur = max(pre+nums[index], nums[index])
        return cur
```

我们同样可以通过记忆化搜索的方法来优化上面这个问题，这里我不再赘述。我们看看怎么通过动态规划来求解这个问题。我们可以将状态方程归纳为

- `cur = max(cur, pre + num) if pre > 0 else cur`

```python
class Solution:
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        pre, cur = 0, float('-inf')
        for num in nums:
            pre += num
            cur = max(cur, pre)
            if pre < 0:
                pre = 0
                
        return cur
```

实际上这也就是`Kadane`算法。通过这个算法我们可以很简单的找到子数组的最大和。我们初始化两个变量`result`和`cur`，分别表示最后的最大值和当前的最大值。算法思路如下

- `cur = cur + num (for num in nums)`
- `cur = 0 if cur < 0`
- `result = cur if cur > result` 

代码如下

```python
class Solution:
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result, cur = float('-inf'), 0
        for num in nums:
            cur += num
            cur = max(cur, 0)
            result = max(result, cur)
        return result
```

实际上也可以将`1,2`顺序换一下，但是要注意初始条件的变化。

```python
class Solution:
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = cur = float('-inf')
        for num in nums:
            cur = max(cur, 0) + num
            result = max(result, cur)
        return result
```

实际上上面这种写法还有一个更为简洁的表示

```python
class Solution:
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        for i in range(1, len(nums)):
            if nums[i-1] > 0:
                nums[i] += nums[i-1]
        return max(nums)
```

至于提高中所说的分治策略，我觉得在这里其实没有必要了。

reference:

https://www.geeksforgeeks.org/?p=576/

https://leetcode.com/problems/maximum-subarray/discuss/20396/Easy-Python-Way

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**