---
layout: post
title: 各种二叉树的判断（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-3-24 00:00:00
---

### 判断完全二叉树

完全二叉树的定义

> 在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

#### 递归实现：

我们知道这样的两个性质，如果我们将`root.index`从`0`开始计算的话

- 左孩子=2*i + 1
- 右孩子=2*i + 2

基于这个性质，我们可以先计算节点的个树，然后每个节点的`index`是不是`>=len(tree)`，如果是的话，那么自然就返回`False`，直到所有节点都访问完。

```python
class Solution:  
    def _isCompleteBT(self, root, index, num):
        if not root:
            return True
        
        if index >= num:
            return False
        return self._isCompleteBT(root.left, index*2 + 1, num) and self._isCompleteBT(root.left, index*2 + 2, num)
    
    def isCompleteBT(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        def countNodes(node):
            if not node:
                return 0
            return 1+ countNodes(node.left) + countNodes(node.right)
        
        num = countNodes(root)
        return self._isCompleteBT(root, 0, num)     
```

我们也可以参看这个问题[Leetcode 958：二叉树的完全性检验（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/85256444)的实现，将上面的代码写的更加简洁。

```python
class Solution:
    def isCompleteTree(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        nodes = [root]
        i = 0
        
        while nodes[i]:
            nodes.append(nodes[i].left)
            nodes.append(nodes[i].right)
            i += 1
            
        return not any(nodes[i:])
```

#### 迭代实现：

我们可以通过BSF遍历整棵二叉树，对于每个节点我们要做这样的判断

- 左孩子为空，右孩子也必须为空
- 左右孩子都为空或者左孩子不为空而右孩子为空，那么接下来要遍历的节点都必须是叶子节点

```python
class Solution:        
    def isCompleteBT(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        
        queue = [root]
        flag = False
        while queue:
            node = queue.pop(0)
            if node.left:
                if flag:
                    return False
                queue.append(node.left)
            else:
                flag = True
                
            if node.right:
                if flag:
                    return False
                queue.append(node.right)
            else:
                flag = True
                
        return True
```

### 判断满二叉树

#### 递归实现：

主要分成这样几种情况：

- `root`空，True
- `root`非空，`root.left`和`root.right`都为空，True
- `root`非空，`root.left`和`root.right`都不为空，递归下去
- `root`非空，`root.left`为空`root.right`不为空，`root.left`不为空`root.right`为空，False

```python
class Solution:        
    def isFullBT(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        
        if not root.left and not root.right:
            return True
        
        if root.left and root.right:
            return self.isFullBT(root.left) and self.isFullBT(root.right)
        
        return False
```

#### 递归实现：

计算树的节点个数`num_nodes`和树的深度`depth`。然后通过`depth`计算出节点数，比较二者是否想同。

```python
class Solution:        
    def isFullBT(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        def countNodes(node):
            if not node:
                return 0
            return 1+ countNodes(node.left) + countNodes(node.right)
        
        def height(node):
            if not node:
                return 0
            return max(height(node.left), height(node.right)) + 1
        
        num_nodes = countNodes(root)
        depth = height(root)
        return True if 2**depth - 1 == num_nodes else False
```

### 判断二叉搜索树

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含**小于**当前节点的数。
- 节点的右子树只包含**大于**当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

 [Leetcode 98：验证二叉搜索树（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82315830)

### 判断平衡二叉树

一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过1。

[Leetcode 110：平衡二叉树（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82081501)