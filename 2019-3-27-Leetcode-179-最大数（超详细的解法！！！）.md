---
layout: post
title: Leetcode 179：最大数（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-3-27 00:00:00
---

给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。

**示例 1:**

```
输入: [10,2]
输出: 210
```

**示例 2:**

```
输入: [3,30,34,5,9]
输出: 9534330
```

**说明:** 输出结果可能非常大，所以你需要返回一个字符串而不是整数。

**解题思路**

这个问题非常简单，我们需要做的就是写一个比较函数`cmp(a,b)`，比较传入的两个数字组成的`str(a)+str(b)`和`str(b)+str(a)`哪个大。

在`python3`中`sort`由于没有`cmp`参数，那么我们就需要通过`cmp_to_key`来实现类似`cmp`的功能。在对两个字符串组合比较的时候，我们没有`cmp`函数可以使用，我们可以通过`(b+a > a+b) - (b+a < a+b)`这种方式模拟`cmp`函数，或者更简洁的写法`int(b+a) - int(a+b)`。

```python
from functools import cmp_to_key
class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        if not nums:
            return ""
        
        nums = list(map(str, nums))
        nums.sort(key=cmp_to_key(lambda x, y: int(y+x) - int(x+y)))
        return '0' if nums[0] == '0' else "".join(nums)
```

当然如果你觉得使用`cmp_to_key`和一系列比较操作很麻烦的话，你也可以写一个比较类

```python
class compare(str):
    def __lt__(x, y):
        return x+y > y+x

class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        if not nums:
            return ""
        nums = sorted(list(map(str, nums)), key=compare)
        return '0' if nums[0] == '0' else "".join(nums)
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**