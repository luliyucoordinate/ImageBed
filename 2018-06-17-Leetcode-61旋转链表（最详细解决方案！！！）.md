---
layout: post
title: Leetcode 61:旋转链表（最详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-06-17 00:00:00
---

给定一个链表，旋转链表，将链表每个节点向右移动 *k* 个位置，其中 *k* 是非负数。

**示例 1:**

```
输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL
```

**示例 2:**

```
输入: 0->1->2->NULL, k = 4
输出: 2->0->1->NULL
解释:
向右旋转 1 步: 2->0->1->NULL
向右旋转 2 步: 1->2->0->NULL
向右旋转 3 步: 0->1->2->NULL
向右旋转 4 步: 2->0->1->NULL
```

**解题思路**

这个问题其实和[Leetcode 19:删除链表的倒数第N个节点（最详细解决方案！！！）](https://blog.csdn.net/qq_17550379/article/details/80717212)是一样的。其实就是一个循环链表

首先，如果`head == None or head.next == None`我们直接返回`head`就可以了。接着我们设置

```
pre 
 1 -> 2 -> 3 -> 4 -> 5 -> NULL
 count=1
```

直到`pre.next!=None`我们退出循环，否则我们`pre=pre.next`、`count++`。

```
                    pre 
 1 -> 2 -> 3 -> 4 -> 5 -> NULL
 count=5
```

然后，我们将链表做成循环链表，只要`pre.next=head`即可。

```
                    pre 
 1 -> 2 -> 3 -> 4 -> 5 
 |                   |
 ---------------------
 count=5
```

接着我们设置一个指针`q=pre`，通过计算`n=count-k%count`，得到我们要向左移动多少距离（因为`q=q.next`是左旋操作）

```
           q        pre 
 1 -> 2 -> 3 -> 4 -> 5 
 |                   |
 ---------------------
 count=5 k=2 n=3
```

接着我们只要设置`ret=q.next`、`q.next=None`，然后返回`ret`即可。

```python
class Solution:
    def rotateRight(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """
        if head == None or head.next == None:
            return head

        pre = head
        count = 1
        while pre.next != None:
            count += 1
            pre = pre.next

        pre.next = head
        n = count - k%count
        q = pre

        for _ in range(n):
            q = q.next

        ret = q.next
        q.next = None
        return ret
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**