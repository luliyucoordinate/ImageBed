---
layout: post
title: Leetcode 213：打家劫舍 II（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-09-24 00:00:00
---

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都**围成一圈，**这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你**在不触动警报装置的情况下，**能够偷窃到的最高金额。

**示例 1:**

```
输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

**示例 2:**

```
输入: [1,2,3,1]
输出: 4
解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**解题思路**

这和问题和之前[Leetcode 198：打家劫舍（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82829381) 问题思路一样，不过这里多了一些考量。因为这里的房子成环，所以最大值出现的情况无非两种。

- `nums[1:]`中存在最大值
- `nums[:-1]`中存在最大值

也就是上述两者情况之一。

```python
class Solution:
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        
        if len(nums) == 1:
            return nums[0]

        pre1, cur1, pre2, cur2 = 0, 0, 0, 0
        for i in nums[:-1]:
            pre1, cur1 = cur1, max(pre1 + i, cur1)
        for i in nums[1:]:
            pre2, cur2 = cur2, max(pre2 + i, cur2)

        return max(cur1, cur2)
```

代码没有变化，所以我们直接使用之前的代码即可。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**