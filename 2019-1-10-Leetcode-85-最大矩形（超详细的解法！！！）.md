---
layout: post
title: Leetcode 85：最大矩形（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-10 00:00:00
---

给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

**示例:**

```
输入:
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
输出: 6
```

**解题思路**

这个问题实际上就是之前[Leetcode 84：柱状图中最大的矩形（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/85093224)问题的拓展。我们可以将这个问题转化为之前的那个问题，也就是我们将此时输入矩阵的每一行以上的所有行看成是一个柱状图。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/85/2018_12_22_1.png" width="300" hegiht="150">
</center>

我们最后会得到上面这个直方图矩阵。

```python
class Solution:
    def maximalRectangle(self, matrix):
        """
        :type matrix: List[List[str]]
        :rtype: int
        """
        if not matrix:
            return 0
        
        r, c = len(matrix), len(matrix[0])
        height, res = [0]*c, 0
        for row in matrix:
            for i in range(c):
                height[i] = height[i] + 1 if row[i] == '1' else 0
            res = max(self.helper(height), res)
            
        return res
    
    def helper(self, row):
        stack = list()
        len_row, i = len(row), 0
        res = 0
        while i < len_row:
            if not stack or row[stack[-1]] <= row[i]:
                stack.append(i)
                i += 1
            else:
                k = stack.pop()
                res = max(res, row[k]*((i-stack[-1]-1) if stack else i))
        while stack:
            k = stack.pop()
            res = max(res, row[k]*((i-stack[-1]-1) if stack else i))
        return res
```

非常酷！！！我们可以将上述的代码继续简化（参考之前问题的最后一种写法）

```python
class Solution:
    def maximalRectangle(self, matrix):
        """
        :type matrix: List[List[str]]
        :rtype: int
        """
        if not matrix:
            return 0
        
        r, c = len(matrix), len(matrix[0])
        height, res = [0]*(c+1), 0
        for row in matrix:
            for i in range(c):
                height[i] = height[i] + 1 if row[i] == '1' else 0
            
            stack = [-1]
            for idx, val in enumerate(height):
                while val < height[stack[-1]]:
                    h = height[stack.pop()]
                    res = max(res, h*(idx - stack[-1] - 1))
                    
                stack.append(idx)
                
        return res
```

这个问题也可以使用动态规划

reference:

https://leetcode.com/problems/maximal-rectangle/discuss/29065/AC-Python-DP-solutioin-120ms-based-on-largest-rectangle-in-histogram

https://leetcode.com/problems/maximal-rectangle/discuss/29054/Share-my-DP-solution

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**