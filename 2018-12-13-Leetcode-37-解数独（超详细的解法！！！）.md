---
layout: post
title: Leetcode 37：格雷编码（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-12-13 00:00:00
---

编写一个程序，通过已填充的空格来解决数独问题。

一个数独的解法需**遵循如下规则**：

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

空白格用 `'.'` 表示。

<center class="half">
    <img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" width="200" hegiht="200">
</center>

一个数独。

<center class="half">
    <img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" width="200" hegiht="200">
</center>

答案被标成红色。

**Note:**

- 给定的数独序列只包含数字 `1-9` 和字符 `'.'` 。
- 你可以假设给定的数独只有唯一解。
- 给定数独永远是 `9x9` 形式的。

**解题思路**

这个之前的问题[Leetcode 51：N皇后（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82770400)其实是一样的，都是通过回溯法来解。我们就要判断我们每次摆放数字是不是有效，我们只要进行如下三种判断即可

- 所有行是不是满足条件
- 所有列是不是满足条件
- 当前的小正方型是不是满足条件

```python
def isValid(self, board, row, col, c):
    for i in range(9):
        if board[i][col] == c or board[row][i] == c or\
            board[row//3*3+i//3][col//3*3+i%3] == c:
            return False

    return True
```

这里我使用了一些`trick`。接着我们只要从到位遍历`board`，如果当前的位置不是`"."`的话，我们就一次放入`"123456789"`挨个尝试。

```python
class Solution:
    def solveSudoku(self, board):
        """
        :type board: List[List[str]]
        :rtype: void Do not return anything, modify board in-place instead.
        """
        self.helper(board)
        
    def helper(self, board):
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    continue
                for c in "123456789":
                    if self.isValid(board, i, j, c):
                        board[i][j] = c        
                        if self.helper(board):
                            return True
                        board[i][j] = '.'
                return False
        return True
                        
    def isValid(self, board, row, col, c):
        for i in range(9):
            if board[i][col] == c or board[row][i] == c or\
                board[row//3*3+i//3][col//3*3+i%3] == c:
                return False

        return True
```

上面这个算法对于一般的应试来说是足够了的。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**