---
layout: post
title: Leetcode 1009：十进制整数的补码（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-3-17 00:00:00
---

每个非负整数 `N` 都有其二进制表示。例如， `5` 可以被表示为二进制 `"101"`，`11` 可以用二进制 `"1011"` 表示，依此类推。注意，除 `N = 0` 外，任何二进制表示中都不含前导零。

二进制的补码表示是将每个 `1` 改为 `0` 且每个 `0` 变为 `1`。例如，二进制数 `"101"` 的二进制补码为 `"010"`。

给定十进制数 `N`，返回其二进制表示的补码所对应的十进制整数。

**示例 1：**

```
输入：5
输出：2
解释：5 的二进制表示为 "101"，其二进制补码为 "010"，也就是十进制中的 2 。
```

**示例 2：**

```
输入：7
输出：0
解释：7 的二进制表示为 "111"，其二进制补码为 "000"，也就是十进制中的 0 。
```

**示例 3：**

```
输入：10
输出：5
解释：10 的二进制表示为 "1010"，其二进制补码为 "0101"，也就是十进制中的 5 。 
```

**提示：**

1. `0 <= N < 10^9`

**解题思路**

这个问题非常简单，就是要计算出给定数`n`的补码，但是这里的补码和我们教课书中的定义不同。我们需要将每个 `1` 改为 `0` 、每个 `0` 变为 `1`并且所有的前导零不能变成`1`。那么我们就需要计算出最高`1`的位置。我们可以通过`n>>1`来判断，然后我们将`~n&((1 << (t))-1)`即可。例如

```
n = 5: 101
index = 3
(1 << index) - 1 = 0000 0111
~n = 1111 1010
~n&((1 << index) - 1) = 2
```

我们还需要考虑一个边界情况，当`n==0`的时候，我们的返回结果是`1`。最后代码如下

```python
class Solution:
    def bitwiseComplement(self, N: int) -> int:
        if N == 0:
            return 1
        t, k = 0, N
        while k:
            k >>= 1
            t += 1

        return ~N & ((1 << t)-1) 
```

或者我们最后`return N^((1 << t)-1)`也可以。此题的关键问题在于获取`mask`，也就是将最高位`1`之后的所有位都置为`1`并且之前位置为`0`。我们还可以这样获取`mask`

```python
X = 1
while N > X: 
    X = (X << 1) + 1
```

这也是一个不错的写法。

reference:

https://leetcode.com/problems/complement-of-base-10-integer/discuss/256740/JavaC%2B%2BPython-Find-111.....1111-greater-N

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**