---
layout: post
title: Leetcode 142：环形链表 II（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-08 00:00:00
---

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

**说明：**不允许修改给定的链表。

**进阶：**
你是否可以不用额外空间解决此题？

**解题思路**

这是之前问题[Leetcode 141：环形链表（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/83866566)的提高，我们还是采用快慢指针来做。

我们建立两个指针，一个`slow`一个`fast`，我们令移动速度关系为$V_{fast}=2*V_{slow}$，我们假设环的长度为$V_{slow}*time$的倍数`k`，如果此时`slow`和`fast`都在环内的话，那么在一定时间内两者必定可以相遇（使用相对速度很好理解）。如果此时`slow`的起点是在环的初始点（例如前面例子中的`3`），那么`fast`和`slow`最后一定会在起点相遇（因为$V_{slow}*time*k\%V_{slow}$一定为`0`，其中后面的$V_{slow}$为相对速度）。我们现在的问题就变成了如何判断`slow`在环的初始点，这也非常简单，我们再建立一个`entry`指针，当`slow==fast`的时候，我们判断`slow==entry`，如果是的话，那么`entry`即为环的初始点，否则的话我们将`entry++;slow++;`，判断下一个位置是不是环的起始点。

此处还有一个小问题，如果`slow`和`fast`不是在环内会怎么样？我们前面已经说明了**如果slow和fast的起始点在环的初始点，那么最后一定会在这个点相交**。那么我们不妨假设`slow`和`fast`在环的初始点前$V_{slow}*time*x$距离处（`entry`固定于此），那么我们`slow`和`fast`最后相交位置也一定距离环的起始点$V_{slow}*time*x$（证明同之前）。又我们`entry`和`slow`的前进速度相同，所以它俩最后一定会交于环的起始点。

```python
class Solution:
    def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head == None:
            return None

        fast, slow, entry = head, head, head
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                while slow != entry:
                    slow = slow.next
                    entry = entry.next

                return entry
        return None
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**