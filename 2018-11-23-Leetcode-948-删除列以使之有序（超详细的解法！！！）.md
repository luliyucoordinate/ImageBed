---
layout: post
title: Leetcode 948：删除列以使之有序（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-23 00:00:00
---

你的初始能量为 `P`，初始分数为 `0`，只有一包令牌。

令牌的值为 `token[i]`，每个令牌最多只能使用一次，可能的两种使用方法如下：

- 如果你至少有 `token[i]` 点能量，可以将令牌置为正面朝上，失去 `token[i]` 点能量，并得到 `1` 分。
- 如果我们至少有 `1` 分，可以将令牌置为反面朝上，获得 `token[i]` 点能量，并失去 `1` 分。

在使用任意数量的令牌后，返回我们可以得到的最大分数。

**示例 1：**

```
输入：tokens = [100], P = 50
输出：0
```

**示例 2：**

```
输入：tokens = [100,200], P = 150
输出：1
```

**示例 3：**

```
输入：tokens = [100,200,300,400], P = 200
输出：2
```

**提示：**

1. `tokens.length <= 1000`
2. `0 <= tokens[i] < 10000`
3. `0 <= P < 10000`

**解题思路**

这个问题非常简单，就和买股票一样，我们只要购买价格最低的，然后卖出价格最高的即可。所以我们可以先对`tokens`排序，然后判断`tokens`是不是空（因为我们希望更多次的交易，按照我们的策略，如果交易更多次，就意味着更多的收益）并且同时我们还要判断我们是不是连最低价格的`token`都买不起，上述条件只要一个成立，我们就应该返回结果了。否则我们就要判断我们是不是能买的起最便宜的`token`，如果可以的话就一直买（注意和前面的区别，一个是保障外层循环，一个是内层循环）。然后我们看是不是还有`token`了，有的话，我们挑选最大的将其卖出。然后就继续判断卖出后我们的钱是不是可以继续买价格低的`token`，可以的话就有多少买多少。

```python
class Solution:
    def bagOfTokensScore(self, tokens, p):
        """
        :type tokens: List[int]
        :type P: int
        :rtype: int
        """
        sum_tokens, result = sum(tokens), 0
        tokens.sort()
        while tokens and tokens[0] <= p:
            if p >= sum_tokens:
                return result + len(tokens)
            
            while p >= tokens[0]:
                sum_tokens -= tokens[0]
                p -= tokens[0]
                tokens.pop(0)
                result += 1
                
            if tokens:
                sum_tokens -= tokens[-1]
                p += tokens[-1]
                tokens.pop()
                if result:
                    result -= 1
                    
        return result
```

将上述过程写的更加简洁

```python
class Solution:
    def bagOfTokensScore(self, tokens, p):
        """
        :type tokens: List[int]
        :type P: int
        :rtype: int
        """
        result, cur = 0, 0
        tokens.sort()
        while tokens and cur >= 0:
            if tokens[0] <= p:
                p -= tokens.pop(0)
                cur += 1
                if result < cur:
                    result = cur
                    
                print(result)
            else:
                p += tokens.pop()
                cur -= 1
                
        return result     
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**
