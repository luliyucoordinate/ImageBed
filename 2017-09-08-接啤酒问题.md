---
layout: post
title: 接啤酒
category : cpp
tags : [cpp, 笔试]
stickie: true
---


题目描述
---

酒馆里有m个龙头可供顾客们接啤酒，每个龙头每秒的出酒量相等，都是1。现有n名顾客准备接酒，他们初始的接酒顺序已经确定。将这些顾客按接酒顺序从1到n编号，i号顾客的接酒量为w_i。接酒开始时，1到m号顾客各占一个龙头，并同时打开龙头接酒。当其中某个顾客j完成其接酒量要求wj后，下一名排队等候接酒的顾客k马上接替j顾客的位置开始接酒。这个换人的过程是瞬间完成的，且没有任何酒的浪费。即j顾客第x秒结束时完成接酒，则k顾客第x+1秒立刻开始接酒。若当前接酒人数n不足m，则只有n个龙头供酒，其它m-n个龙头关闭。现在给出n名顾客的接酒量，按照上述规则，问所有顾客都接完酒需要多少秒？

输入描述
---

输入包括两行，第一行为以空格分割的两个数n和m, 分别表示接酒的人数和酒龙头个数，均为正整数。 

第二行n个整数w_i，(1 <= w_i <= 100)表示每个顾客接酒量

输出描述
---

如果输入合法输出接酒所需总时间(秒)。

样例输入
---

5 3 
4 4 1 2 1 

样例输出
---

4

这个问题最简单的做法是使用优先队列，但是我觉得我写的并不是非常的完美

```c++
#include <iostream>
#include <queue>
#include <vector>
#include <functional>


int main(void)
{
	size_t m, n;
	std::priority_queue<int, std::vector<int>, std::greater<int>>  que;
	
	while (std::cin >> n >> m)
	{
		std::vector<int> arr(n);
		for (int i = 0; i < n; ++i)
		{
			std::cin >> arr[i];
		}		
		if (n > m)
		{
			for (int i = 0; i < m; ++i)
			{
				que.push(arr[i]);
			}
			for (int i = m; i < n; ++i)
			{
				int temp = que.top();
				que.pop();
				que.push(arr[i] + temp);
			}
		}
		else
		{
			for (int i = 0; i < n; ++i)
			{
				que.push(arr[i]);
			}
		}
		while ((que.size() - 1) != 0) que.pop();
		std::cout << que.top();
	}
}
```

下面这个使用了一种非常巧妙的方法

```c++
#include <iostream>
#include <vector>

int main(void)
{
	size_t m, n;
	while (std::cin >> n >> m)
	{
		std::vector<size_t> arr(n);
		for (int i = 0; i < n; ++i)
		{
			std::cin >> arr[i];
		}
		int times = 0;
		while (true)
		{
			int flag = 0;	//标记是否有人接水
			int num = 0;	
			for (int i = 0; i < n; ++i)
			{
				if (arr[i] > 0)
				{
					flag = 1;
					--arr[i];
					++num;	//当n > m时，这时候人数大于龙头数
					if (num == m) break;
				}
			}
			if (flag) ++times;
			else break;
		}
		std::cout << times << std::endl;
	}
}
```