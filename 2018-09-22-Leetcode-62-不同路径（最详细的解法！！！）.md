---
layout: post
title: Leetcode 62：不同路径（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-09-22 00:00:00
---

一个机器人位于一个 *m x n* 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" width="500" hegiht="313">
</center>

例如，上图是一个7 x 3 的网格。有多少可能的路径？

**说明：** *m* 和 *n* 的值均不超过 100。

**示例 1:**

```
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```

**示例 2:**

```
输入: m = 7, n = 3
输出: 28
```

**解题思路**

这个问题和[Leetcode 64：最小路径和（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82805129) 很类似，我们同样可以通过递归解决。我们要知道左上角开始有多少路径，那么我们只需要知道左上角的→有多少路径以及↓有多少路径，然后将两者相加即可。

```python
class Solution:
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        return self._uniquePaths(m, n, 0, 0)

    def _uniquePaths(self, m, n, row, col):
        if row == m - 1 and col == n - 1:
            return 1
        
        if row >= m or col >= n:
            return 0

        return self._uniquePaths(m, n, row + 1, col) +\
                         self._uniquePaths(m, n, row, col + 1)
```

注意我们这里的边界条件，实际上我们并且需要严格判断`row == m-1 and col == n-1`，因为我们只要当`row == m-1 or col == n-1`的时候路径就已经确定了。

```python
class Solution:
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        return self._uniquePaths(m, n, 0, 0)

    def _uniquePaths(self, m, n, row, col):
        if row == m - 1 or col == n - 1:
            return 1

        return self._uniquePaths(m, n, row + 1, col) +\
                         self._uniquePaths(m, n, row, col + 1)
```

这是一步非常重要的优化。

但是这样做存在着大量的重复运算（在哪呢？）。我们可以通过**记忆化搜索**的方式来优化上面的问题。

```python
class Solution:
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        mem = [[0]*m for _ in range(n)]
        return self._uniquePaths(m, n, 0, 0, mem)

    def _uniquePaths(self, m, n, row, col, mem):
        if row == n - 1 or col == m - 1:
            return 1

        if row < n and col < m and mem[row][col] != 0:
            return mem[row][col]

        mem[row][col] = self._uniquePaths(m, n, row + 1, col, mem) +\
                         self._uniquePaths(m, n, row, col + 1, mem)
        return mem[row][col]
```

我们同样可以通过迭代的写法，同样也是**动态规划**的方法求解这个问题。对于`x > 1 and y > 1`的点来说，它们的路径就是`(x-1, y) + (x, y-1)`，而对于边界的点（右侧和下方）来说，路径为`1`。那么我们很容易写出下面的代码

```python
class Solution:
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        mem = [[None]*m for _ in range(n)]
        for i in range(m):
            mem[n - 1][i] = 1
        
        for i in range(n):
            mem[i][m - 1] = 1

        for i in range(n - 2, -1, -1):
            for j in range(m - 2, -1, -1):
                mem[i][j] = mem[i + 1][j] + mem[i][j + 1]

        return mem[0][0]
```

我们也可以反过来思考问题，直接从起点出发，而不是从终点出发。

```python
class Solution:
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        mem = [[0]*n for _ in range(m)]
        
        for i in range(m):
            for j in range(n):
                if i or j:
                    mem[i][j] = mem[i-1][j] + mem[i][j-1]
                else:
                    mem[i][j] = 1
                    
        return mem[-1][-1]
```

其实这个问题最简单的思路是通过排列组合解决，实际上这是一个组合问题。对于一个`mxn`的网格来说，我们要知道有多少种路径，那么只要知道`m+n-2`个`step`中，向下的`n-1`个`step`有多少种组合即可，也就是$C_{m+n-2}^{n-1}$。

```python
import math 
class Solution:
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        mole = math.factorial(m + n - 2)
        deno = math.factorial(n - 1) * math.factorial(m - 1)
        return mole//deno  
```

上述代码在使用`c++`写的时候存在数据溢出的风险，最好使用`long long`进行数据存储。另外，一个最简单的做法是，使用`c++`的库函数`lgamma `，并且`lgamma(n)=log((n-1)!) `

```cpp
#include <math.h>
class Solution 
{
public:
    int uniquePaths(int m, int n) 
    {
        return int(exp(lgamma(m+n-1)-lgamma(m)-lgamma(n))+0.5);
    }
};
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**