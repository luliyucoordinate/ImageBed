---
layout: post
title: 声明与定义
category : cpp
tags : [c, notes]
stickie: true
---

转自[小鱼的学习笔记](http://blog.csdn.net/xiaoyusmile/article/details/5420252)

变量的定义、声明
===

变量的声明有两种情况：  
一种是需要建立存储空间的。例如：int  a。在声明的时候就已经建立了存储空间。这种声明是"定义性声明(defining declaration)"，即我们平时所说的“定义”。
另一种是不需要建立存储空间的，只是告诉编译器某变量已经在别处定义过了。例如：extern int a。其中，变量a是在别处定义的。这种声明是"引用性声明(referncing declaration)"，即我们平时所说的“声明”。

从广义的角度来讲，声明中包含着定义，但是并非所有的声明都是定义。即，定义性声明既是定义又是声明，而引用性声明只是声明。例如：int a。它既是声明，同时又是定义。然而对于 extern int a 来讲，它只是声明不是定义。

一般的情况下我们常常这样叙述，把建立空间的声明称之为”定义”，而把不需要建立存储空间的称之为”声明”。很明显这里指的声明是范围比较窄的，也就是说引用性的声明。

例子：

```c++
int a; //定义性声明，分配存储空间，初值不确定
int b = 0; //定义性声明，分配存储空间，赋初值
extern int c; //引用性声明，不分配存储空间，只是告诉编译器这个变量已经在别处定义过了
```

函数的定义、声明
===

函数的定义和声明也是一样，定义需要分配存储空间；声明只是告诉编译器这个函数已经在别处定义过了。  
函数的定义和声明比较好区分。有函数体的即为定义，不带函数体即为声明。

例子：

```c++
//声明
double sqrt(double x);
 
//定义
double sqrt(double x)
{
          return x*x;
}
```

定义与声明的区别
===

1.  是否需要分配存储空间。
2.   在一个作用域中可以重复声明，但不能重复定义。这是由（1）决定的，可以重复几次告诉编译器某个变量、函数已经在别处定义了，但不能重复多次地让编译器为同一个变量、函数分配不同的存储空间。

关于extern要注意的一点
===
extern 只是用来声明全局变量，在一个文件中声明全局变量，声明方法可以如下两种（都一样）：

```c++
extern int a；//第一种
int a；//第二种
```
也就是在一个文件中声明全局变量，extern可以省略；
如果在一个文件中定义了一个全局变量(extern)int a，要想在另一个文件中使用这个变量，则要在另一个文件前面加上全局变量声明，即加上：extern int a；（extern 不可省略）这样两个文件的全局变量a就是同一个，它的值就可以互相使用了，也可以在任意文件中改变了。还要注意的是第二种做法**在c++里面是错的**。

转自[剑圣风暴](http://blog.csdn.net/fukai555/article/details/11403433)


实际情况下一个比较好的处理方式
===
在实际的编程中，全局变量对我们编程来说既是喜又是泪，虽然说项目中尽量避免使用全局变量，但总有些时候不得不使用它，并且可能使用得不少，各个模块可能有含有或多或少的几个全局变量，而当别的模块需要引用的时候，就必须extern它，造成你定义了一遍又声明了一遍，这样就稍显得麻烦。下面介绍一种全局变量的管理方法，至始至终只定义一次，所有的全局变量以某种声明方式放入一个名叫global.h的头文件中，然后别的模块include它就OK。那么如何操作呢？这里还要新建一个同名的global.c源文件，用来定义所有全局变量，注意这里并不是手工一个一个定义，而是采用预处理方式，废话少说见下面程序

global.h

```c++
#ifndef _GLOBAL_H
#define _GLOBAL_H

#ifdef GLOBAL_VAR  
#define GLOBAL_EXTERN   
#else  
#define GLOBAL_EXTERN extern  
#endif  
  
GLOBAL_EXTERN int g_var1;  
GLOBAL_EXTERN int g_var2;

#endif
```
global.c

```c++
#define GLOBAL_VAR  
#include "global.h"  
#undef GLOBAL_VAR  
```
