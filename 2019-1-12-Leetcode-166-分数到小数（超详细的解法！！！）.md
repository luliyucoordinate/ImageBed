---
layout: post
title: Leetcode 166:分数到小数（超详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-12 00:00:00
---

给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。

如果小数部分为循环小数，则将循环的部分括在括号内。

**示例 1:**

```
输入: numerator = 1, denominator = 2
输出: "0.5"
```

**示例 2:**

```
输入: numerator = 2, denominator = 1
输出: "2"
```

**示例 3:**

```
输入: numerator = 2, denominator = 3
输出: "0.(6)"
```

**解题思路**

这个问题很简单，使用`python`的话，很简洁。我们通过`'.'`进行分割，将分割的元素都转换为整数（这样做我们可以去除左边的零的影响）。然后比较此时的两个列表，对短的那个列表补零即可。

```python
class Solution:
    def compareVersion(self, version1, version2):
        """
        :type version1: str
        :type version2: str
        :rtype: int
        """
        v1 = [int(i) for i in version1.split('.')]
        v2 = [int(i) for i in version2.split('.')]
        v1_len, v2_len = len(v1), len(v2)
        
        max_len = max(v1_len, v2_len)
        v1 += [0]*(max_len - v1_len)
        v2 += [0]*(max_len - v2_len)
        
        if v1 > v2:
            return 1
        elif v1 < v2:
            return -1
        else:
            return 0
```

一个`pythonic`的写法

```python
class Solution:
    def compareVersion(self, version1, version2):
        """
        :type version1: str
        :type version2: str
        :rtype: int
        """
        v1, v2 = map(int, version1.split('.')), map(int, version2.split('.'))
        v1, v2 = zip(*itertools.zip_longest(v1, v2, fillvalue = 0))
        return (0, 1, -1)[(v1 > v2) - (v1 < v2)]
```

reference:

https://leetcode.com/problems/compare-version-numbers/discuss/50800/2-4-lines-Python-3-different-ways

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**