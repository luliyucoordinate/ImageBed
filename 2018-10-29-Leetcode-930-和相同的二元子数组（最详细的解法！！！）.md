---
layout: post
title: Leetcode 930：和相同的二元子数组（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-10-29 00:00:00
---

在由若干 `0` 和 `1`  组成的数组 `A` 中，有多少个和为 `S` 的**非空**子数组。

**示例：**

```
输入：A = [1,0,1,0,1], S = 2
输出：4
解释：
如下面黑体所示，有 4 个满足题目要求的子数组：
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]
```

**提示：**

1. `A.length <= 30000`
2. `0 <= S <= A.length`
3. `A[i]` 为 `0` 或 `1`

**解题思路**

这个问题和之前的[Leetcode 560：和为K的数组（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/83510121)非常类似。我们可以直接使用之前的解法。

```python
class Solution:
    def numSubarraysWithSum(self, A, S):
        """
        :type A: List[int]
        :type S: int
        :rtype: int
        """
        result, cur_sum = 0, 0
        sum_dict = {0:1}
        for num in A:
            cur_sum += num
            if cur_sum - S in sum_dict:
                result += sum_dict[cur_sum - S]
            if cur_sum in sum_dict:
                sum_dict[cur_sum] += 1
            else:
                sum_dict[cur_sum] = 1
                
        return result
```

但是这样做就和之前没什么区别了，我们就没有将这题中的**数组由`1`和`0`构成**这个条件用上。我们这里可以不使用`hash_map`，我们只要建立一个`len(A)+1`大小的`list`即可（因为所有元素和不会超过它）。

```python
class Solution:
    def numSubarraysWithSum(self, A, S):
        """
        :type A: List[int]
        :type S: int
        :rtype: int
        """
        result, cur_sum = 0, 0
        sum_dict = [0]*(len(A) + 1)
        sum_dict[0] = 1
        for num in A:
            cur_sum += num
            if cur_sum - S >= 0:
                result += sum_dict[cur_sum - S]
            sum_dict[cur_sum] += 1
                
        return result
```

还有一种不错的解法是，我们首先找出`A`中所有`1`的位置。对于`10101`，所有的位置就是`[0,2,4]`。如果`target=2`，我们最后的结果一定是这样两种情况：包含`0`和`2`，包含`2`和`4`。我们首先看`0`和`2`，我们知道`2`的右边一个`0`，所以如果我们最后的结果包含`0`和`2`两个位置的话，那么只会出现两只情况：区间`[0,2]`和`[0,3]`。而对于`2`和`4`来说，我们知道`2`的左边有一个`0`，所以我们知道最后只会有两个情况：区间`[1,4]`和`[2,4]`，所以我们最后的得到的结果是`1*2+2*1`。对于`S=0`我们要单独考虑，因为没有`1`可选，所以就无法套用公式，而这也非常好处理，实际上就是$C_{n+1}^{2}$，为什么呢？例如 `[0,0,0,0,0]`

```
| 0 | 0 | 0 | 0 | 0 |
```

我们实际上就是要找两个位置，将这区间给切成两份，也就是$C_{6}^2$。

其实上面所举的例子（`10101`）比较特殊，实际我们在计算的时候都是，**左边界的左边零的个数乘上右边界的右边零的个数**，而上面的例子中左边界和右边界（子区间）恰好都在边界上（整个区间），所以对于这种辩解情况我们要单独考虑。非常简单，只要在我们得到的`1`的位置数组的前后加上`-1`和`len(A)`即可。

```python
class Solution:
    def numSubarraysWithSum(self, A, S):
        """
        :type A: List[int]
        :type S: int
        :rtype: int
        """
        result = 0
        indexs = [-1] + [i for i, val in enumerate(A) if val] + [len(A)]
        if not A:
            return result
        
        if S == 0:
            for i in range(len(indexs) - 1):
                w = indexs[i+1] - indexs[i] - 1
                result += w*(w+1)//2
            return result
        
        for i in range(1, len(indexs) - S):
            j = i + S - 1
            if j > len(indexs):
                break
            result += (indexs[i] - indexs[i-1])*(indexs[j+1] - indexs[j])

        return result
```

另外我们也可以不存储`1`的位置，而是存储**间隔`0`的数目**，这样减少了循环的次数。

```python
class Solution:
    def numSubarraysWithSum(self, A, S):
        """
        :type A: List[int]
        :type S: int
        :rtype: int
        """
        zeros, result, cnt = list(), 0, 0
        if not A:
            return result
    
        for num in A:
            if num:
                zeros.append(cnt)
                cnt = 0
            else:
                cnt += 1
        zeros.append(cnt)
        
        if S:
            for i in range(len(zeros) - S):
                result += (zeros[i] + 1)*(zeros[i+S] + 1)
            return result

        if S == 0:
            for i in range(len(zeros)):
                if zeros[i] > 0:
                    result += (zeros[i] + 1)*zeros[i]
            result //= 2
            return result
```

reference:

https://leetcode.com/problems/binary-subarrays-with-sum/solution/

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**