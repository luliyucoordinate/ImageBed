---
layout: post
title: 寻找最大排列问题
category : 算法
tags : [python, 算法]
stickie: true
date: 2018-03-06 00:00:00
---

有八个人去看电影。但是有一部分人只喜欢特殊的座位，大部分人不喜欢自己的座位。我们这要去抽象问题，`a`h和`b`都喜欢`c`的位置，而`c`喜欢`a`的位置。

<center class="center">
<img src="http://wx3.sinaimg.cn/mw690/af2d2659ly1fp2vcsr0l7j20ku08adgw.jpg"  >
</center>

现在我们开始思考这个问题。`a`和`b`都喜欢`c`的位置，那么我们要从`a`和`b`中挑选出一个

- 假设我们选`b`，那么我们删除`a`。这个时候我们发现`c`喜欢`a`的位置，但是`a`被删除了，所以我们这个时候也应该删除`c`，接着自然地我们同样要删除`a`。这个时候我们发现前三部分删完了，这并不是我们想要的，或者说这应该不是最优解。
- 接着我们选`a`，那么我们删除`b`。因为没有人喜欢`b`，所以没有任何位置要删除。

好的，我们回顾这个过程，我们会发现问题所在。因为最初`b`的位置没有人喜欢，所以一开始去除`b`是最好的做法。

好的，我们沿着这个思路继续思考，我们先将`b`和`g`删除。接着我们发现`g`删除后，`g`所指向的`h`就没有被指向了，接着我们很自然地去删除`h`。删除`h`后，我们发现`h`指向的`e`又没人指向了，所以这个时候我们就要删除`e`。删除`e`后，我们发现`e`指向的`d`又没人指向了，所以这个时候我们就要删除`d`。最后，我们得到的结果就是`a, c, f`。

接着我们要做的就是将上述过程抽象成代码

```python
'''
A:最后剩余的座位
B:所有人喜欢的座位集合
C:没有人喜欢的座位
'''
def naive_max_perm(M, A=None):  
    if A is None: # The elt. set not supplied?  
        A = set(range(len(M))) # A = {0, 1, ... , n-1}  
    if len(A) == 1: 
        return A # Base case -- single-elt. A  
    B = set(M[i] for i in A) # The "pointed to" elements  
    C = A - B # "Not pointed to" elements  
    if C: # Any useless elements?  
        A.remove(C.pop()) # Remove one of them  
        return naive_max_perm(M, A) # Solve remaining problem  
    return A # All useful -- return all  
```

我们还有一个更加高效的做法，我们通过对于`所有人喜欢的座位集合`进行技术，例如`a:1`、`b:0`、`c:2`，这种做法减少了上面方案中间过程中创建`B`的开销。

```python
from collections import Counter
def max_perm(M):  
    n = len(M) # How many elements?  
    A = set(range(n)) # A = {0, 1, ... , n-1}   
    count = Counter(M)  
    Q = [i for i in A if count[i] == 0] # Useless elements  
    while Q: # While useless elts. left...  
        i = Q.pop() # Get one  
        A.remove(i) # Remove it  
        j = M[i] # Who's it pointing to?  
        count[j] -= 1 # Not anymore...  
        if count[j] == 0: # Is j useless now?  
            Q.append(j) # Then deal w/it next  
    return A # Return useful elts.
```

但是这种做法是如此的丑陋，远没有第一种做法美妙。