---
layout: post
title: Leetcode 107:二叉树的层次遍历 II（最详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-06-27 00:00:00
---

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：
给定二叉树 `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其自底向上的层次遍历为：

```
[
  [15,7],
  [9,20],
  [3]
]
```

**解题思路**

参考这篇文章[Leetcode 102:二叉树的层次遍历（最详细解决方案！！！）](https://blog.csdn.net/qq_17550379/article/details/80824321)

我们仅需要将`tmp list`不断插入`result`的最前面就可以了。或者我们可以将结果进行`reverse`同样可以。

```python
class Solution:
    def levelOrderBottom(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        q, result = [root], []
        while any(q):
            tmp = list()
            len_q = len(q)
            for _ in range(len_q):
                node = q.pop(0)
                tmp.append(node.val)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)

            result.insert(0, tmp)
        return result
```

另外这个问题还有一种是用递归的写法。

```python
class Solution:
    def _levelOrderBottom(self, level, result, node):
        if node:
            if level > len(result):
                result.insert(0,[])

            result[-level].append(node.val)
            self._levelOrderBottom(level+1, result, node.left)
            self._levelOrderBottom(level+1, result, node.right)

    def levelOrderBottom(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        level, result = 1, list()        
        self._levelOrderBottom(level, result, root)
        return result  
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**
