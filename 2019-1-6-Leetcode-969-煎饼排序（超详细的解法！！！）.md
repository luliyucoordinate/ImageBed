---
layout: post
title: Leetcode 969：煎饼排序（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-6 00:00:00
---

给定数组 `A`，我们可以对其进行*煎饼翻转*：我们选择一些正整数 `k <= A.length`，然后反转 `A` 的前 **k** 个元素的顺序。我们要执行零次或多次煎饼翻转（按顺序一次接一次地进行）以完成对数组 `A` 的排序。

返回能使 `A` 排序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 `10 * A.length` 范围内的有效答案都将被判断为正确。

**示例 1：**

```
输入：[3,2,4,1]
输出：[4,2,4,3]
解释：
我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。
初始状态 A = [3, 2, 4, 1]
第一次翻转后 (k=4): A = [1, 4, 2, 3]
第二次翻转后 (k=2): A = [4, 1, 2, 3]
第三次翻转后 (k=4): A = [3, 2, 1, 4]
第四次翻转后 (k=3): A = [1, 2, 3, 4]，此时已完成排序。 
```

**示例 2：**

```
输入：[1,2,3]
输出：[]
解释：
输入已经排序，因此不需要翻转任何内容。
请注意，其他可能的答案，如[3，3]，也将被接受。 
```

**提示：**

1. `1 <= A.length <= 100`
2. `A[i]` 是 `[1, 2, ..., A.length]` 的排列

**解题思路**

这是一个非常有名的问题。原始问题的难点在于怎么用最少的次数排好序，但是此题放宽了要求（翻转次数在 `10 * A.length` 范围内的有效答案都将被判断为正确），所以我们可以很容易想到的一个方法是：首先找出数组中的最大数，然后将最大数及其之前的全部数进行翻转，例如

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/969/2019_1_6_1.png" width="200">
</center>

我们对`A[:i]`进行翻转。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/969/2019_1_6_2.png" width="200">
</center>

然后再对数组中的所有数进行翻转。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/969/2019_1_6_3.png" width="200">
</center>

这样我们最大的数就排好了，接着再找第二大的数，通过同样的操作即可。代码如下：

```python
class Solution:
    def pancakeSort(self, A):
        """
        :type A: List[int]
        :rtype: List[int]
        """
        res = list()
        for i in range(len(A), 1, -1):
            index = self.findMaxIndex(A[:i])
            A = A[:index][::-1] + A[index:]
            A = A[:i][::-1]
            res += [index, i]
            
        return res
        
    def findMaxIndex(self, A):
        index = 0
        for i in range(1,len(A)):
            if A[i] > A[index]:
                index = i
                
        return index+1
```

由于问题中的**提示A[i]是 [1, 2, ..., A.length]的排列**，所以可以写的更简洁。

```python
class Solution:
    def pancakeSort(self, A):
        """
        :type A: List[int]
        :rtype: List[int]
        """
        res = list()
        for i in range(len(A), 1, -1):
            idx = A.index(i) + 1
            A = A[:idx][::-1] + A[idx:]
            A = A[:i][::-1]
            res += [idx, i]
            
        return res
```

还可以继续简化

```python
class Solution:
    def pancakeSort(self, A):
        """
        :type A: List[int]
        :rtype: List[int]
        """
        res = list()
        for i in range(len(A), 1, -1):
            idx = A.index(i)
            A = A[:idx:-1] + A[:idx]
            res += [idx + 1, i]
            
        return res
```

reference:

https://zh.wikipedia.org/wiki/%E7%85%8E%E9%A4%85%E6%8E%92%E5%BA%8F

https://leetcode.com/problems/pancake-sorting/discuss/214213/JavaC%2B%2BPython-Straight-Forward

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**