---
layout: post
title: Leetcode 209:长度最小的子数组（最详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-05-23 00:00:00
---

给定一个含有 **n** 个正整数的数组和一个正整数 **s ，**找出该数组中满足其和 **≥ s** 的长度最小的子数组**。**如果不存在符合条件的子数组，返回 0。

**示例:** 

```
输入: [2,3,1,2,4,3], s = 7
输出: 2
解释: 子数组 [4,3] 是该条件下的长度最小的子数组。
```

**进阶:**

如果你已经完成了*O*(*n*) 时间复杂度的解法, 请尝试 *O*(*n* log *n*) 时间复杂度的解法。

**解题思路**

我们首先想到的方案是暴力破解，通过遍历所有的子数组找到满足条件的最小子数组。

```python
class Solution:
    def minSubArrayLen(self, s, nums):
        """
        :type s: int
        :type nums: List[int]
        :rtype: int
        """
        minLen = len(nums) + 1
        for i, _ in enumerate(nums):
            sum_all = 0
            for j, tmp in enumerate(nums[i:]):
                sum_all += tmp
                if sum_all >= s:
                    minLen = min(minLen, j + 1)
        if minLen == len(nums) + 1:
            return 0
        
        return minLen
```

但是这种`O(n^2)`解法，我们通过分析发现我们上述算法中有大量重叠运算。我们有没有更快的做法？

我们这样看这个问题，问题要求我们找一个数，并且这个数是在一个有序的区间内。对了！！！可以使用`二分搜索法`，那么我们同时就要考虑判断条件（`二分搜索法`会判断中间元素），我们将`窗口的大小内元素值是否满足和>=s`作为条件。

我们在算法的一开始应该考虑`数组长度的一半`，这里上取整或下取整不影响（但是要前后一致）结果。

```
        p
2   3   1   2   4   3
|       |
```

接着我们就要判断在这样一个窗口（左右都是闭区间）内是否满足上述条件。

```
        |       |
2   3   1   2   4   3
```

我们通过滑动窗口发现有满足条件（一旦出现，直接返回，不用继续寻找了）的情况。我们接着将长度对半

```
        p
2   3   1   2   4   3
|   |
```

我们接着滑动窗口判断剩余空间中是否有满足条件的情况出现

```
2   3   1   2   4   3
                |   |
```

以此类推下去。

```python
class Solution:
    def _windowEx(self, nums, size, s):
        sum = 0
        for i, _ in enumerate(nums):
            if i >= size:
                sum -= nums[i - size]

            sum += nums[i]
                
            if sum >= s:
                return True
        return False
    
    def minSubArrayLen(self, s, nums):
        """
        :type s: int
        :type nums: List[int]
        :rtype: int
        """
        l = 1
        r = len(nums)
        result = 0
        while l <= r:
            mid = l + (r - l)//2
            if self._windowEx(nums, mid, s):
                r = mid - 1
                result = mid
            else:
                l = mid + 1
                
        return result
```

这个算法的时间复杂度就是`O(nlogn)`级别的。我们就会想有没有`O(n)`级别的算法呢？我们是否可以只遍历一遍就可以得到结果？

这个时候我们就会想到之前[Leetcode 167:两数之和 II - 输入有序数组](https://blog.csdn.net/qq_17550379/article/details/80512745)提到的`对撞指针`。我们可以建立两个指针，通过累加两个指针的区间内的值和`s`比较，就可以在`O(n)`级别的时间内得到结果。

```
2  3  1  2  4  3
l <- ->  r
```

由于两个指针移动的过程中，指针之间的距离就像一个窗口一样，我们通过控制窗口的大小，得到我们想要的结果。我们称这种问题是一个滑动窗口问题。

```python
class Solution:
    def minSubArrayLen(self, s, nums):
        """
        :type s: int
        :type nums: List[int]
        :rtype: int
        """
        l = 0
        r = 0
        sum_all = 0
        nums_len = len(nums)
        minLength = nums_len + 1
        while l < nums_len:
            if r < nums_len and sum_all < s:
                sum_all += nums[r]
                r += 1
            else:
                sum_all -= nums[l]
                l += 1
            
            if sum_all >= s:
                minLength = min(minLength, r - l)

        if minLength == nums_len + 1:
            return 0
        
        return minLength
```

该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)

**如有问题，希望大家指出！！！**