---
layout: post
title: Leetcode 72：编辑距离（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-18 00:00:00
---

给定两个单词 *word1* 和 *word2*，计算出将 *word1* 转换成 *word2* 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

1. 插入一个字符
2. 删除一个字符
3. 替换一个字符

**示例 1:**

```
输入: word1 = "horse", word2 = "ros"
输出: 3
解释: 
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2:**

```
输入: word1 = "intention", word2 = "execution"
输出: 5
解释: 
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

**解题思路**

这个问题非常简单，有点类似于LCS问题，所以我们很容易想到通过动态规划来求解这个问题。我们首先思考一下递归过程。我们通过两个指针`i`和`j`分别指向`word1`和`word2`。我们定义函数$f(i,j)$表示`word1[:i]`转换为`word2[:j]`需要的最少步骤。

```
word1: h o r s e
         i
word2: r o s
         j
```

我们首先要比较`word1[i-1]`和`word2[j-1]`是不是相同，如果相同的话，我们就不用做任何操作，所以此时$f(i,j)=f(i-1,j-1)$（`i`和`j`都向前挪一个位置）。

接着对于不相同的时候我们的情况比较复杂，我们有三种处理手段，分别是`insert`、`replace`和`remove`。我们先看`insert`操作。我们`insert`完之后，也就是`word1`中的元素会保持不变，而`j`会向前挪一个位置，也就是$f(i,j)=f(i,j-1)+1$。接着考虑`replace`操作，`replace`会减少`word1`和`word2`中一个需要比较的元素（`i`和`j`会向前挪一个位置），也就是$f(i,j)=f(i-1,j-1)+1$。我们接着考虑最后一个`remove`操作，这个就很容易了，`word1`中会减少一个需要比较的元素，而我们`j`的位置不变，也就是$f(i,j)=f(i-1,j)+1$。所以我们最后的结果相当三者取最小值即可。

- $f(i,j)=min(f(i-1,j),f(i,j-1),f(i-1,j-1))+1\ \ if\ word1[i]\neq word2[j]$
- $f(i,j)=f(i-1,j-1)\ \ \ if \ word1[i]=word2[j]$

接着我们要考虑初始条件，也就是`word1`和`word2`为空的情况，此时也非常简单$f(i,0)=i$、$f(0,j)=j$。所以我们最后的代码也就很容易了

```python
class Solution:
    def minDistance(self, word1, word2):
        """
        :type word1: str
        :type word2: str
        :rtype: int
        """
        word1_len, word2_len = len(word1), len(word2)
        mem = [[0]*(word2_len+1) for _ in range(word1_len+1)]
        for i in range(1, word1_len+1):
            mem[i][0] = i
        for j in range(1, word2_len+1):
            mem[0][j] = j

        for i in range(1, word1_len+1):
            for j in range(1, word2_len+1):
                mem[i][j] = min(mem[i-1][j-1]+(word1[i-1]!=word2[j-1]), mem[i][j-1]+1, mem[i-1][j]+1)

        return mem[-1][-1]
```

这个问题可以使用滚动数组将空间复杂度优化为`O(n)`级别，但其实数组开辟空间和赋值操作也就同样的增加了时间损耗。

由于问题是求最少操作数，所以我们很容易想到通过广度优先遍历来解。只是这里的广度优先遍历和以往的有些区别，我们每次需要访问的边有四种。也就是前文说的`word1[i-1]==word2[j-1]`的一种情况和`word1[i-1]!=word2[j-1]`的三种情况。实际的操作过程非常容易，代码如下

```python
from heapq import heappush, heappop
class Solution:
    def minDistance(self, word1, word2):
        """
        :type word1: str
        :type word2: str
        :rtype: int
        """
        heap = [(0, word1, word2)]
        visited = set()
        while heap:
            d, w1, w2 = heappop(heap)
            if (w1, w2) in visited:
                continue
            visited.add((w1, w2))    
            if w1 == w2:
                return d
            if w1 and w2 and w1[0] == w2[0]:
                heappush(heap, (d, w1[1:], w2[1:]))
            else:
                if w1: 
                    heappush(heap, (d+1, w1[1:], w2)) #delete
                if w1 and w2: 
                    heappush(heap, (d+1, w1[1:], w2[1:])) #replace
                if w2: 
                    heappush(heap, (d+1, w1, w2[1:])) #add
```

实际的代码测试中，使用这种方式实现的代码要比前面使用动态规划完成的速度快。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**