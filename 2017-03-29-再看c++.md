---
layout: post
title: 再看c++
category : cpp
tags : [cpp]
stickie: true
---


未解决的一些问题
===

Specialization特化
---
```c++
template <class Key>
struct hash{};
template<>
struct hash<char>
{
	size_t operator() (char x) const { return x; }
};
```

有时为了需要,针对特定的类型,需要对模板进行特化,也就是特殊处理.例如,stack类模板针对bool类型,因为实际上bool类型只需要一个二进制位，就可以对其进行存储,使用一个字或者一个字节都是浪费存储空间的.


Partial Specialization偏特化
---

个数上

```c++
Template<typename T, typename Alloc=…>
Class vector
{
	…
};
template<typename Alloc=…>
class vector<bool, Alloc> //语法上只允许从左到右的具体化
{…}
```
范围上

```c++
template <typename T>
class C
{
	…
};
template <typename T>
class C <T*>
{
	…
};
C<string> obj1;
C<string*> obj2;
```

Template template parameter 模板模板参数
---
```c++
template<typename T,template <typename T> class Container>
class XCLSs
{
private:
	container<t> c;
public:
};
template<typename T>
using Lst = list<T ,allocator<T>>;
XCLs<string, Lst> mylst2;
```
以下做法是错误的

```c++
XCLs<string, list> mylst1; 原因在于容器可以接受多个参数
```
注意只有这个地方typename class 可以共通

```c++
template<typename T,template <typename T> class SmartPtr>
class XCLSs
{
private:
	SmartPtr<T> c;
public:
    	XCLs() : sp(new T) {}
};
XCLs<string , shared_ptr> p1; //只接收一个参数
```
以下这种写法不再是ttp

```c++
template<class T, class Sequence = deque<T>>
class stack
{};
stack<int> s1;
stack<int, list<int>> s2;
```

c++标准库
---

仿函数functors  
算法algorithms  
迭代器iterators  
容器containers  


variadic templates c++11
---
```c++
template<typename T,typename… Types>//注意这里的。。。是语法
void print(const T& firstArg, const Type&… args)
{
	cout << firstArg <<endl;
	print(args…);
};
print(7.5, “hello”, bitset<16>(377), 42);
```
。。。就是一个pack
auto c++11

```c++
list<string> c;
list<string>::iterator ite;
ite = find(c.begin(), c.end(), target);
```
变成了auto ite = find(c.begin(), c.end(), target);  
这种做法是错误的

```c++
auto ite; //编译器推不出来
ite = ….;
```


ranged-base for(c++11)
---
```c++
for(del : coll)
{
	Statement
}
例子
for(int I : { 2,3,5,6})
{
	cout << I <<endl;
}
vector<double> vec;
for(auto elem : vec)
{
	cout << elem << endl;
}
```

reference
---
```c
int x = 0;
int *p = &x;
int &r = x;	//r代表x
int x2 = 5;
r = x2;		//r不能重新代表其他物体
int &r2 = r;//
```
一定要有初值，设好后，不可以再变化  
object和其reference大小相同，地址也相同，但这是假像  
以下视为same signature

```c++
double image(const double& im) {}
double image(const double im) {}
```
包括括号后面的部分（const）都是签名

```c++
double image(const double& im)  const{}
double image(const double im) {}]
```
这样表示的函数不同


Object model
---

关于vptr和vtbl

```c++
class A
{
public:
	virtual void vfunc1();
	virtual void vfunc2();
	void func1();
	void func2();
private:
	int m_data1, m_data2;
};
class B: public A
{
public:
	virtual void vfunc1();
	void func2();
private:
	int m_data3;
};
class C: public B
{
public:
	virtual void vfunc1();
	void func2();
private:
	int m_data1, m_data4;
};
```
<a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe41ed6rl2j20nw0i2nk6.jpg" data-lightbox="roadtrip">
<img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe41ed6rl2j20nw0i2nk6.jpg" class="img-fluid">
</a>


通过指针向上转型，调用虚函数，把这个调用动作编译为(*p->vptr[n]) (p)动态绑定Dynamic Binding


再看const
---

当成员函数的const和non-const版本同时存在，const object只会调用const版本，non-const object只会调用non-const版本

```c++
charT
operator[] (size_type pos) const
{}//不必考虑copy on write
reference 
operator[] (size_type pos)
{}//必须考虑copy on write
```

关于new，delete
---

前面提到过如下操作  
new先分配内存在调用ctor

```c++
Complex *pc = new Complex(1, 2);
```
编译器转化为

```c++
Complex *pc;
void* mem = operator new (sizeof( Complex) );// 内部调用malloc
pc = static_cast< Complex*>(mem);
pc->Comnplex::Complex(1,2);
```
delete 先调用dtor，在释放内存

```c++
String::~String(ps);
operator delete(ps); // 内部调用free
```
重载::operator new ::operator delete ::operator new[] ::operator delete[]

```c++
inline void *operator new(size_t size)
{}
inline void operator delete(void *ptr)
{}
inline void *operator new(size_t size)
{}
inline void operator delete[](void *ptr)
{}
```
重载member operator new delete

```c++
class Foo
{
public:
	int _id;
	long _data;
	string _str;
public:
	Foo() : _id(0) {}
	Foo(int i ) : _id(1) {}
	~Foo() {}
	static void *operator new(size_t size);
	static void operator delete(void *pdead, size_t size);
	static void *operator new[](size_t size);
	static void operator delete[](void *pdead, size_t size);
};
void Foo::opreator delete(void *pdead, size_t size)
{
	cout << ...
	free(pdead);
}
void* Foo::operator new[](size_t size)
{
	Foo *p = (Foo*) malloc (size);
	cout << ..
	return p;
}
void Foo::operator delete[](void *pdead, size_t size)
{
	cout << ...
	free(pdead);
}
Foo *pf = new Foo; //若无members就调用globals
delete pf;
Foo *pd = ::new Foo;//强制调用globals
::delete pf;

Foo* pArray = new Foo[5];
delete [] pArray;
```

每增加一个虚函数，类的大小增加一个指针的字节  
编译器在构造数组时，后分配4个字节的空间去存储这个数组的大小，这样做可以编译器快速的知道调用几次构造，几次析构


重载new() ,delete()
---

我们可以重载class member operator new() ,写出多个版本，前提时每一个版本的声明必须有独特的参数列，其中第一参数必须是size_t ,其余参数以new所指定的placement arguments为初值。出现new()小括号内的便是p a。

```c++
Foo *pf = new (300,'c') Foo;
//一般重载
void *operator new(size_t size)
{ return malloc(size); }
//placement new()的标准写法
void *operator new(size_t szie, void *start)
{ return start; }
```

我们也可以重载class member operator delete(),但是他们不会被delete调用。只有当new所调用的ctor抛出异常，才会带调用这些重载版的operator delete()。
他只能这样被调用，主要用来clean未完成创建的object所占的memory，即使operator delete() 未能一一对应operator new() ,编译器也不会报错

Basic_string使用new

```c++
template<...>
class basic_string
{
private:
	struct Rep
	{
		void release() { if( --ref == 0) delete this;}
		inline static void* operator new(size_t size);
		inline static void* operator delete(void *);
		inline static Rep* create(size_t);
		...
	};
	...
};
template<class charT, class traits, class Allocator>
inline basic_string<charT, traits, Allocator>::Rep*
basic_string<charT, traits, Allocator>::Rep::
create(size_t extra)
{
	extra = frob_size(extra + 1);
	Rep *p = new(extra) Rep;
	...
	return p;
}
template<class charT, class traits, class Allocator>
inline void *basic_string<charT, traits, Allocator>::Rep::
operator new (size_t s,size_t extra)
{
	return Allocator::allocate(s + extra * sizeof());//重载placement new
}
template<class charT, class traits, class Allocator>
inline void basic_string<charT, traits, Allocator>::Rep::
opreraotr delete(void *ptr)
{
	Allocator::deallocate(ptr...
}

```
