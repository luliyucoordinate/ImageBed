---
layout: post
title: Leetcode 100：相同的树（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-08-11 00:00:00
---

给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例 1:**

```
输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
```

**示例 2:**

```
输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
```

**示例 3:**

```
输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false
```

**解题思路**

这个问题同样使用递归很轻松就可以解决，关键就是要理清楚递归函数的意义。我们判断`p`和`q`的`root、left、right`的值是不是相同即可。这里我们要考虑好终止条件（`p、q`是不是空）

```python
class Solution:
    def isSameTree(self, p, q):
        """
        :type p: TreeNode
        :type q: TreeNode
        :rtype: bool
        """

        if p and q:
            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
        
        if p == None and q == None:
            return True
        else:
            return False
```

同样的，对于可以用递归解决的问题，我们都应该思考一下怎么可以通过迭代去解决。那这个问题怎么通过迭代解决呢？那么我们就会用到`stack`，通过`stack`模拟上面的递归过程。一个较为简单的思路就是二叉树的层序遍历，参看这篇[Leetcode 102:二叉树的层次遍历（最详细解决方案！！！）](http://blog.csdn.net/qq_17550379/article/details/80824320)  ，我们在此基础上稍加修改就可以了。

```python
class Solution:
    def isSameTree(self, p, q):
        """
        :type p: TreeNode
        :type q: TreeNode
        :rtype: bool
        """
        q = [(p, q)]
        while q:
            node1, node2 = q.pop(0)
            if node1 and node2 and node1.val == node2.val:
                q.append((node1.left, node2.left))
                q.append((node1.right, node2.right))
            else:
                if node1 != node2: # node1 == None and node2 != None  node1 != None and node2 == None
                    return False

        return True 
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**