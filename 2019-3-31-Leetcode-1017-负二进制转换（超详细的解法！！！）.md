---
layout: post
title: Leetcode 1017：负二进制转换（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-3-31 00:00:00
---

给出数字 `N`，返回由若干 `"0"` 和 `"1"`组成的字符串，该字符串为 `N` 的**负二进制（base -2）**表示。

除非字符串就是 `"0"`，否则返回的字符串中不能含有前导零。

**示例 1：**

```
输入：2
输出："110"
解释：(-2) ^ 2 + (-2) ^ 1 = 2
```

**示例 2：**

```
输入：3
输出："111"
解释：(-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3
```

**示例 3：**

```
输入：4
输出："100"
解释：(-2) ^ 2 = 4
```

**提示：**

1. `0 <= N <= 10^9`

**解题思路**

这是一个数学问题，我们知道如果是转为二进制的话，就是不断取摸。如果对于转为负二进制采用同样的思路，我们的余数会出现负数，这要怎么办？

我们知道，如果$a/b=c$余数是$d$的话，那么$bc+d=a$，因此$d=a-bc$。我们需要保证我们的余数是正数并且是最小的那个，我们要怎么做？假设$b=-r$，那么$a = (−r)c + d = (−r)c + d − r + r = (−r)(c + 1) + (d + r)$，也就是我们可以对余数$d$加上一个除数的相反数$r$，同时我们对应的商$c$需要加$1$。这样我们就可以保证$d$是一个正数，同时一定是最小的那个（只加了一次$r$）。

```python
class Solution:
    def baseNeg2(self, N: int) -> str:
        if N == 0:
            digits = ['0']
        else:
            digits = []
            while N != 0:
                N, remainder = divmod(N, -2)
                if remainder < 0:
                    N, remainder = N + 1, remainder + 2
                digits.append(str(remainder))
        return ''.join(digits[::-1])
```

reference:

https://www.geeksforgeeks.org/convert-number-negative-base-representation/

https://en.wikipedia.org/wiki/Negative_base

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**