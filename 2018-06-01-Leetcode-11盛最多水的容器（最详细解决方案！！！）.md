---
layout: post
title: Leetcode 11:盛最多水的容器（最详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-06-01 00:00:00
---

给定 *n* 个非负整数 *a*1，*a*2，...，*a*n，每个数代表坐标中的一个点 (*i*, *ai*) 。画 *n* 条垂直线，使得垂直线 *i* 的两个端点分别为 (*i*, *ai*) 和 (*i*, 0)。找出其中的两条线，使得它们与 *x* 轴共同构成的容器可以容纳最多的水。

**注意：**你不能倾斜容器，*n* 至少是2。

<center class="half">
    <img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" width="500" hegiht="313">
</center>

图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

**解题思路**

参照这[Leetcode 125:验证回文串](https://blog.csdn.net/qq_17550379/article/details/80514285)、[Leetcode 344:验证回文串](https://blog.csdn.net/qq_17550379/article/details/80513863)、[Leetcode 167:两数之和 II - 输入有序数组](https://blog.csdn.net/qq_17550379/article/details/80512745)、[Leetcode 345:反转字符串中的元音字母](https://blog.csdn.net/qq_17550379/article/details/80515302)几篇文章中的解题思路。我们通过设置两个指针，分别指向数组的头`l`和尾`r`，计算容器可以容纳多少水`contain`。我们知道想要容乃的水最多，最好的情况是`l`和`r`都是最大，然后二者离的最远，但是这是理想情况，我们最一般的情况是

- 二者离的足够远，但是二者都不是很大
- 二者都很大，但是二者离的近

所以我们一开始从两边考虑就是考虑的第一种可能。如果这个时候`num[l] < num[r]`，我们就需要将`l++`，因为我们的容量由短板决定，所以我们希望短板更长。如果这个时候`num[l] > num[r]`，我们就需要将`r--`。而`num[l] == num[r]`，`l++`或者`r--`都可以。

```python
class Solution:
    def maxArea(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        l = 0
        r = len(height) - 1
        contain = 0
        while l < r:
            contain = max(contain, (r - l) * min(height[l], height[r]))
            if height[l] > height[r]:
                r -= 1
            else:
                l += 1

        return contain
```

该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)

**如有问题，希望大家指出！！！**