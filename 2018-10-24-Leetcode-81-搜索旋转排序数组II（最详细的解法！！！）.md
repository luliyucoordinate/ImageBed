---
layout: post
title: Leetcode 81：搜索旋转排序数组II（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-10-24 00:00:00
---

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,0,1,2,2,5,6]` 可能变为 `[2,5,6,0,0,1,2]` )。

编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 `true`，否则返回 `false`。

**示例 1:**

```
输入: nums = [2,5,6,0,0,1,2], target = 0
输出: true
```

**示例 2:**

```
输入: nums = [2,5,6,0,0,1,2], target = 3
输出: false
```

**进阶:**

- 本题中的 `nums`  可能包含重复元素。
- 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？

**解题思路**

这是之前[Leetcode 33：搜索旋转排列数组（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/83213836)问题的延伸。如果使用之前的方法解决这个问题，会出现错误，例如

```
1  3  1  1  1
      |
```

我们会在`[0:2]`这个区间查找对应元素，但是这样是错误的，这个区间并不是递增区间。那要怎么做呢？

一种最简单的思路就是将`nums`的重复元素去除，然后在使用之前的方法就可以啦。

```python
class Solution:
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: bool
        """
        if not nums:
            return False
        nums = list(set(nums))
        low, high = 0, len(nums) - 1

        while low <= high:
            mid = (low + high) // 2
            if target == nums[mid]:
                return True

            if nums[low] <= nums[mid]:
                if nums[low] <= target <= nums[mid]:
                    high = mid
                else:
                    low = mid + 1
            else:
                if nums[mid] <= target <= nums[high]:
                    low = mid
                else:
                    high = mid - 1

        return False
```

但是这显然不是最好的解法，我们可以针对这个问题写出相应的优化。其实非常简单，我们只要做这样的检查就可以

```
1  3  1  1  1
      |
l     m
```

当`nums[l]==nums[m]`，我们将`l+=1`，也就是

```
1  3  1  1  1
      |
   l  m
```

这样，我们的区间就变得像之前问题一样可以处理了。

```python
class Solution:
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: bool
        """
        if not nums:
            return False

        low, high = 0, len(nums) - 1

        while low <= high:
            mid = (low + high) // 2
            if target == nums[mid]:
                return True

            if nums[low] == nums[mid]:
                low += 1
            elif nums[low] < nums[mid]:
                if nums[low] <= target <= nums[mid]:
                    high = mid
                else:
                    low = mid + 1
            else:
                if nums[mid] <= target <= nums[high]:
                    low = mid
                else:
                    high = mid - 1

        return False
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**