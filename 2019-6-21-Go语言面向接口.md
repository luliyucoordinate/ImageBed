---
layout: post
title: Go语言面向接口
category : go
tags : [go]
stickie: true
date: 2019-6-21 00:00:00
---

# 0x01 duck typing

`python`中的鸭子类型

```python
def duck_run(duck):
    duck.run()
```

与`python`类似，`go`语言中也有鸭子类型。

# 0x02 接口

在`go`语言中接口的类型是`interface`

```go
type Retriever interface {
    Get(url string) string
}
```

接着我们穿件包`retriever`，然后在包中实现`Retriever`

```go
type Retriever struct {
    Contents string
}
func (r Retriever) Get(url string) string {
    return r.Contents
}
```

接着就可以定义鸭子类型

```go
func download(r Retriever) string {
    return r.Get("www.baidu.com")
}
```

接口变量里面包含了`实现者的类型`和`实现者的指针`。

```go
var r Retriever
r = retriever.Retriever{}
fmt.Printf("%T %v\n", r, r) //retriever.Retriever {}
```

我们可以通过`switch type`判断接口类型，有点类似于`cpp`中的`typeid`

```go
switch v := r.(type) {
case retriever.Retriever:
    fmt.Println("Contents: ", v.Contents)
}
```

也可以使用`type assertion`取出接口中的具体类型

```go
t := r.(retriever.Retriever) //r.(type)
```

`interface {}`表示任意类型，通过这个我们可以实现泛型编程。

```go
type Queue []interface{}
func (q *Queue) Push(v interface{}) {
    *q = append(*q, v)
}
```

当然我们也可以写出相应的偏特化

```go
func (q *Queue) Push(v int) { //只能Push int类型
    *q = append(*q, v)
}
```

我们也可以在函数体内实现偏特化

```go
func (q *Queue) Push(v interface{}) {
    *q = append(*q, v.(int))
}
```

前者如果`push`其他类型会出现编译错误，而后者是运行时出错。

# 0x03 常用系统接口

第一个是`Stringer`，类似于`cpp`中的`operator<<`运算符重载

```go
func (r *Retriever) String() string {
	return fmt.Sprintf("{test%s}", r.Contents)
}
```

第二个就是`Reader`、`Writer`

```go
func printContents(reader io.Reader) {	
}
```

对文件的抽象。