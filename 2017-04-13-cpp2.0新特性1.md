---
layout: post
title: cpp2.0新特性(1)
category : cpp
tags : [cpp, cpp第二版]
stickie: true
---


新增加的头文件
===

```c++
#include <type_traits>
#include <unordered_set>
#include <forward_list>
#include <array>
#include <tuple>
#include <regex>
#include <thread>
```


Variadic Templates
===

```c++
void print()
{
//处理最后情况
}
template <typename T,typename... Types>
void print(const T& first, const Types&... args)
{
	cout << first << endl;//递归调用recursive
	print(args...);
}
```
...就是所谓的pack  
用于template parameters ，就是template parameters pack  
用于function parameter types，就是function parameters types pack  
用于function parameters ，就是function parameters pack  
sizeof...(args) yields the number of arguments

```c++
template <typename... values> class tuple;
template <> class tuple<> {};//结束边界
template<typename Head,typename... Tail>
class tuple <Head, Tail...>
	:private tuple <Tail...>
{
	typedef tuple <Tail...> inherited;
public:
	tuple() {}
	tuple(Head v, Tail... vtail)
		:m_head(v), inherited(vtail...) {}
	typename Head::type head() { return m_head; }
	inherited& tail() { return *this; }
protected:
	Head m_head;
};
```

<a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1felc40v9bgj206u0aw42i.jpg" data-lightbox="roadtrip">
<img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1felc40v9bgj206u0aw42i.jpg" class="img-fluid">
</a>


Spaces in template expressions
===

```c++
vector<list<int> >;//ok in each c++ version
vector<list<int>>;//ok in c++ 11
```


nullptr and std::nullptr_t
===

C++11 lets you use nullptr instead of 0 or NULL to specify that a pointer refers to no value.This new feature especially helps to avoid mistakes that occurred when a null ointer was interpreted as an integral value.

```c++
void f(int);
void f(void*)
f(NULL);//valls f(int) if NULL is 0,ambiguous otherwise
f(nullptr); //call f(void*)
nullptr is a new keywords
```


Automatic type deduction with auto 
===

With c++11,you can declare a variable or an object without specifying its specific type by using auto.

```c++
auto i = 42;
double f();
auto d = f();
```
using auto is especially useful where the type is a pretty long and/or complicated expression.

```c++
vector<string> v;
auto pos = v.begin(); //pos has type vector<string>::iterator
```


Uniform initialization
===

Before c++11,programmers,especially novices,could easily become confused by the question of how to initialize a variable or an object.Initialization could happen parentheses, braces,and/or assignment opretators.  
For this reason ,c++11  introduces the concept of uniform initialization ,which means that for any initialization ,you can use one common syntax.This syntax uses braces, so the following is possible now;

```c++
int values[]{ 1,2,3 };
vector<int> v{ 1,2,3 };
complex<double> c{ 4.0,3.0 };//背后有个array<double,2>
```
编译器看到{1,2...}便做出一个initializer_list<T>，它关联至一个array<T,n>。调用函数时该array内的元素可被编译器逐一分解传给函数。但若函数参数是个initializer_list<T>，调用者却不能给予数个T参数然后以为他们会被自动转为一个initializer_list<T>传入。


Initializer lists
===

An initializer list forces so-called value initialization ,which means that even local variables of fundamental data types,which usually have an undefined initial value,are initialized by zero

```c++
int i; //i has undefined value
int j{};//j is initialized by 0
int *p;//i has undefined value
int *q{};//q is initialized by nullptr
```
Note,however,that narrowing initializations –those that reduce precision or where the supplied value gets modified – are not possible with braces.

```c++
int x1(5.3);//x1 to 5
int x2 = 5.3;//x2 to 5
int x3{5.3};//error
int x4 = {5.3};//error
```
To support  the concept of initializer lists for user-defined types,c++11 provides the class template std::initializer_list<> .It can be used to support initializations by a list of values or in any place where you want to process just a list of values.

```c++
void print(std::initializer_list<int> vals)
{
	for (auto p = vals.begin(); p != vals.end(); ++p)
	{
		std::cout << *p << std::endl;
	}
}
print({ 1,2,3 });//与前面不同的是这里面的类型必须相同
```
when there are constructors for both a specific number of arguments and an initializer list, the version with the initializer list is preferred.

```c++
class P
{
public:
	P(int a, int b)
	{
		cout << "fjdsjf" << endl;
	}
	P(initializer_list<int> initlist)
	{
		for (auto i : initlist)
		{
			cout << i << endl;
		}
	}
};
P p(77, 5); //P(int,int)
P q{ 77,5 };//P(initializer_list<>)
P r{ 77,5,42 };//P(initializer_list<>)
P s = { 77,5 };//P(initializer_list<>)
```
Without the constructor for the initializer list, the constructor taking two ints would be called to initialize q and s,while the initialization of r would be invalid.  
Initializer_list objects are automatically constructed as if an array of elements of type T was allocated ,with each of the elements in the list being copy-initialized to its corresponding element in the array,using  any necessary non-narrowing implicit conversions.
The initializer_list object refers to the element of this array without containing them:copying an initializer_list object produces another object referring to the same underlying elements, not to new copies of them (reference semantics).  
The lifetime of this temporary array is the same as the initializer_list object.


Explicit for ctors taking more than one argument
===

```c++
class P
{
public:
	P(int a, int b) { cout << a << " " << b << endl;}
	explicit P(int a, int b, int c) {}
};
P y = (1, 2);//error
P z = (1, 2, 3);//error
P v = { 1,2 };//ok
P w = { 1,2,3 };//error
```
关于上面()这样做的错误原因，我后来想了一下，（）内取得是“，”运算符的结果，将这个结果初始化y，但是没有单个参数的构造函数，所以出现了“初始化: 无法从“int”转换为“P”，此时如果将第一个构造函数改为

```c++
P(int a, int b = 0) {}
```
编译果然通过了，结果和预想的一样

<a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1felc418b1wj20bu023t8h.jpg" data-lightbox="roadtrip">
<img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1felc418b1wj20bu023t8h.jpg" class="img-fluid">
</a>


Range-based for statement
===

```c++
for (decl : coll)
{
	statement;
}
```
No explicit type conversions are possible when elements are initialized as decl inside the for loop.Thus ,the following does not compile:

```c++
class C
{
public:
	explicit C(const std::string& s);
};
std::vector<std::string> vs;
for (const C& elem : vs) //ERROR,no conversion from string to C defined 
{
	std::cout << elem << std::endl;
}
```


=default ,=delete
===

如果你自行定义了一个ctor，那么编译器就不会再给你一个default ctor。  
如果你强行加上=default，就可以重新获得并使用default ctor。

```c++
class Zoo
{
public:
	Zoo(int i1,int i2) : d1(i1),d2(i2);
	Zoo(const Zoo&) = delete;//表示我不使用这个构造函数，default ctor也不会使用
// Zoo(const Zoo&) = default;//ERROR,’Zoo(const Zoo&)’cannot be overload
//对于copy assignment也是类似 的
	Zoo(Zoo&&) = default;//表示使用编译器给我的默认构造函数
	Zoo& operator=(const Zoo&) = default;
	Zoo& operator=(const Zoo&&) = delete;
	virtual ~Zoo();

private:
	int d1, d2;
};
```
=default用于big-5之外没有意义，编译会报错  
=delete可以用在任何函数上  
default ctor和dtor主要是给编译器放置如唤起base classed以及non-static members的ctors和dtors，这个在effective c++中有所提及。  
对于何种类需要自己写big-3呢？  
如果这个类内部有pointer member的话，大多数情况下是需要自己写的，如果没有pointer member的话，基本可以使用default。


Alias template(template typedef)
===

```c++
template <typename T>
using Vec = std::vector<T, MyAlloc<T>>;
```
the term

```c++
Vec<int> coll;
```
is equivalent to

```c++
std::vector<int, MyAlloc<int>> coll;
```
It is not possible to partially or explicitly specialize an alias template.  
难道只是为了少敲几个代码吗？  
看这个例子：  
//函数功能：可以传入不同容器进行测试

```c++
template<typename Container>
void test_moveable(Container cntr)
{
	typedef typename iterator_traits<typename Container::iterator>::value_type T;
	for (long i = 0; i < SIZE; ++i)
		c.insert(c.end(), T());
	output_static_data(*(c.begin()));
	Container<T> c1(c);
	Container<T> c2(std::move(c));
	c1.swap(c2);
}
```
要注意的是container里面的类型也是不定的所以就用到了以下方法：  
template template parameter

```c++
template<typename T,template <class T> class Container>
class XCLs
{
public:
	XCLs()
	{
		for (long i = 0; i < SIZE; ++i)
			c.insert(c.end(), T());
		output_static_data(T());
		Container<T> c1(c);
		Container<T> c2(std::move(c));
		c1.swap(c2);
	}
private:
	Container<T> c;
};
XCLs<MyString,vector> c1;
```
但是这里报错了  
ERROR type/value mismatch at argument 2 in template parameter list for ‘template<class T,template <class >class Container> class XCLs’
原因在于

```c++
template<typename _Tp,typename _Alloc = std::allocator<_Tp>>
class vector: protected _Vector_base<_Tp,_Alloc>
```
虽然第二个参数有默认值但是  
Alias template are never deduced by template argument deduction when deducing a template template parameter  
最终的解决法，这样使用这个类

```c++
template<typename T>
using Vec = vector<T, allocator<T>>;
//上面的东西是不可以写在函数内的
XCLs<MyString,Vec> c1;
```


Type alias(similar to typedef)
===

```c++
//typedef void(*func)(int,int);
using func = void(*)(int,int);
```
There is no difference between a type alias declaration and typedef declaration.This declaration many appear in block scope,class scope or namespace scope.


noexcept
===

```c++
//void foo() noexcept(true);
void foo() noexcept;
```
Declares that foo() won’t throw.If an exception is not handled locally inside foo()-thus,if foo() throws – the program is terminated ,calling std::terminate(),which by default calls std::abort().  
由于noexcept不需要stack unwinding ，程序员从今开始可以表现“绝不抛出”而不需要额外开销。c++11开始不再鼓励使用异常明细。  
You can even specify a condition undef which a function throws no exception.For example,for any type Type,the alobal swap() usually is defined as follows:

```c++
void swap(Type &x, Type& y) noexcept(noexcept(x.wap(y)))
{
	x.swap(y);
}
```
Here,inside noexception(...),you can specify a Boolean condition under which no thrown :Specifying noexcept without condition is a short form of specifying  noexcept(true).  
You need to inform C++(specifivally std::vector)that your move constructor and destructor does not throw.Then the move constructor will be called when the vector frows.If the constructor is not noexcept,std::vector can’t use it,since then it can’t ensure the exception guarantees demanded by the standard.  
Growable containers(会发生memory reallocation) 只有两种:vector 和 deque

```c++
class MyString
{
public:
	MyString(MyString &&str)noexcept
		: _data(str._data), _len(str._len) {...}
private:

};
```


override
===

```c++
struct Base
{
	virtual void vfunc(float) {}
};
struct Derived : Base
{
	//ERROR 'virtual void Derived::vfunc(in)' marked override,but does not override
	virtual void vfunc(int) override {}
	
	virtual void vfunc(float) override {}
};
```


final
===

```c++
struct Base final {};
//ERROR cannot derive from 'final' base 'Base' in derived type 'Derived'
struct Derived : Base {};

struct Base2
{
	virtual void f() final;
};
struct Derived2 : Base2
{
	//ERROR overriding final function
	void f();
};
```

