---
layout: post
title: Go语言内建容器
category : go
tags : [go]
stickie: true
date: 2019-6-20 00:00:00
---

# 0x01 数组

数组的声明

```go
var variable_name [SIZE] variable_type
```

我们当然可以讲`var`省略，因为我们之前在变量声明的时候就是这么干的。但是这么做的话，我们就必须给它赋初值

```go
arr := [3]int{1, 2, 3}
```

类似于`c/c++`中，我们也可以不写出具体的数组大小，但是需要通过`...`指明。

```go
arr := [...]int{1, 2, 3}
```

关于多维数组的定义也非常简单，和其他语言类似（唯一区别就是类型写在后面）

```go
var variable_name [SIZE1][SIZE2] variable_type
```

取数组长度，我们可以使用`len`（这和`python`非常类似）

```go
for i; i < len(arr); i++ {
}
```

数组作为函数参数传递也非常简单（通过值传递，也就是函数内无法修改数组的值）

```go
func (arr [5]int) {
}
```

我们可以使用指针传递修改数组内部值

```go
func (arr *[5]int) {
    //arr[0]
}
```

注意这里和`c/c++`有区别，数组名不能作为头指针使用。在函数内，我们也不需要使用`(*arr)[0]`访问值，只需通过`arr[0]`即可。

# 0x02 切片

切片的声明

```go
var identifier []type
```

和数组非常类似，也就是没有指明数组的大小。

我们可以通过一个数组初始化切片

```go
arr := [...]int{0, 1, 2, 3, 4}
s := arr[:]		//类似于python中的[::]
s := arr[si:ei]	//和python中使用一样
s := arr[si:]
s := arr[:ei]
```

要注意的是，对`s`的操作就是对源数组`arr`的操作（这点和`python`有区别）。`go`语言中切片是一种视图，这和`sql`中的操作类似。

所以前面传数组指针的操作，我们也可以变成传递切片

```go
func (arr []int) {
    //arr[0]
}
```

对于切片，我们还可以定义切片的切片

```go
s := s[:]
```

在切片中也一个初学者难理解的特性，也就是切片的切片是可以"越界的"。

```go
arr := [...]int{0, 1, 2, 3, 4, 5 ,6, 7}
s1 := arr[1:3] // 1, 2
s2 := s1[:5] // 1, 2, 3, 4, 5
```

这其实非常好理解，因为切片实际上是一种视图，也就是我们通过不同的角度观察数组的内容。虽然`s1`只看到了`1, 2`，但是源数组中的`3, 4, 5`还是存在的，那我们再通过`s2`去看的时候依旧是可以看到的。

实际上`slice`的底层实现是通过`ptr`、`len`、`cap`三个变量实现的

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/go_slice/2019_6_20_1.png" width="600">
</center>

其中`ptr`就是我们切片看到的数组其实元素位置，`len`表示我们可以看到的数组长度，而`cap`表示实际的可以看到的数组长度。也就是说，我们使用切片后不能再向前看了，而向后看的过程中不能超过`cap`的长度即可。

我们可以通过`len()`和`cap()`两个函数访问上述的属性。

我们也可以向切片中添加元素

```go
arr := [...]int{0, 1, 2, 3, 4, 5 ,6, 7}
s1 := arr[1:3] // 1, 2
s2 := s1[:5] // 1, 2, 3, 4, 5
s3 := append(s2, 10) // 1, 2, 3, 4, 5, 10
```

注意此时的`arr`会发生变化

```go
arr // 0, 1, 2, 3, 4, 5 ,10, 7
```

这非常好理解，因为我们对视图的操作就是对数组本身的操作。

当我们`append`操作后的数组元素个数超过`cap`的时候，系统会开辟一个更大的数组空间	

```go
arr := [...]int{0, 1, 2, 3, 4, 5 ,6, 7}
s1 := arr[3:8] // 3, 4, 5, 6, 7
s2 := append(s1, 10) // 3, 4, 5, 6, 7, 10
```

而此时的`arr`依旧是`{0, 1, 2, 3, 4, 5 ,6, 7}`。我们通过上面的列子，可以知道系统确实分配了内存空间，但是我们只可以通过`s2`访问到。

我们能不能通过原数组去访问这个空间呢？我们可以这样写

```go
arr := [...]int{0, 1, 2, 3, 4, 5 ,6, 7}
arr := append(arr, 10)
```

此时`arr`就变成了`{0, 1, 2, 3, 4, 5 ,6, 7, 10}`，这是一个非常不错的特性，我们可以理解为可变长数组（类似于`cpp`中的`vector`）。

那么我们可以定义一个空的切片，然后往里面放东西

```go
var arr []int
arr := append(arr, 10)
```

我们在定义切片的时候，也可以指明`len`和`cap`的大小，我们需要通过`make`来建立

```go
arr2 := make([]int, 10)			//len
arr3 := make([]int, 10, 32)		//len cap
```

对于切片的元素删除非常简单，和`python`非常类似

```go
s := s[1:]			//删除头
s := s[:len(s)-1]	//删除尾
```

删除中间元素要麻烦一些，例如删除第`2`个元素

```go
s = append(s[:2], s[3:]...)
```

注意因为`append`的第二个参数是可变长参数，所以我们需要加上`...`表示传入`s[3:]`中的所有元素（这一点我觉得`go`设计的不太好^_^）。

# 0x03 map

`map`的声明

```go
var map_variable map[key_data_type]value_data_type
```

和切片类似，我们也可以使用`make`进行声明

```go
map_variable := make(map[key_data_type]value_data_type)
```

`map`赋初值的话和`python dict`类似

```go
countryCapitalMap := map[string]string{"France": "Paris", "Italy": "Rome", "Japan": "Tokyo", "India": "New delhi"}
```

在`go`语言中`map`是无序的，也就是类似于`cpp`中的`unordered_map`类型。

对于`key`的访问也和其他语言类似

```go
val := countryCapitalMap["France"]
```

当`"France"`不在`countryCapitalMap`中的话，我们实际上会返回一个空串（因为我们定义的`value`类型是字符串）。`go`语言在访问`map`的元素的时候，有一点和其他语言不同，它返回`value`的同时会返回一个`bool`值，表示`key`是不是在`map`中。

```go
val, ok := countryCapitalMap["France"] // ok == True
```

`map`的元素删除，我们可以通过`delete`函数实现

```go
delete(countryCapitalMap, "France")
```

# 0x04 字符串

在`go`语言中字符串是支持`utf8`的

```go
s := "你好啊!"
```

此时`len(s)=10`，因为中文为`3`个字节，而英文是`1`个字节。

我们可以简单验证一下，我们可以将`s`转化为`[]byte`

```go
for _, b := range []byte(s) {
	fmt.Printf("%X ", b)		//E4 BD A0 E5 A5 BD E5 95 8A 21 
}
```

确实如此。

那么我们希望中文的一个字也要按照单个字符计算，怎么做呢？

```go
fmt.Println(utf8.RuneCountInString(s))	//4
```

我们之前说过，在`go`语言中使用`rune`存储单个`utf8`字符，那么我们能不能将`s`转化为`[]rune`呢？

```go
for _, b := range []rune(s) {
	fmt.Printf("%c ", b)		//你 好 啊 ! 
}
```

非常好的东西。