---
layout: post
title: Leetcode 972：相等的有理数（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-7 00:00:00
---

给定两个字符串 `S` 和 `T`，每个字符串代表一个非负有理数，只有当它们表示相同的数字时才返回 **true**；否则，返回 **false**。字符串中可以使用括号来表示有理数的重复部分。

通常，有理数最多可以用三个部分来表示：*整数部分* `<IntegerPart>`、*小数非重复部分* `<NonRepeatingPart>` 和*小数重复部分* `<(><RepeatingPart><)>`。数字可以用以下三种方法之一来表示：

- `<IntegerPart>`（例：0，12，123）
- `<IntegerPart><.><NonRepeatingPart>` （例：0.5，2.12，2.0001）
- `<IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)>`（例：0.1(6)，0.9(9)，0.00(1212)）

十进制展开的重复部分通常在一对圆括号内表示。例如：

1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)

0.1(6) 或 0.1666(6) 或 0.166(66) 都是 1 / 6 的正确表示形式。

**示例 1：**

```
输入：S = "0.(52)", T = "0.5(25)"
输出：true
解释：因为 "0.(52)" 代表 0.52525252...，而 "0.5(25)" 代表 0.52525252525.....，则这两个字符串表示相同的数字。
```

**示例 2：**

```
输入：S = "0.1666(6)", T = "0.166(66)"
输出：true
```

**示例 3：**

```
输入：S = "0.9(9)", T = "1."
输出：true
解释：
"0.9(9)" 代表 0.999999999... 永远重复，等于 1 。[有关说明，请参阅此链接]
"1." 表示数字 1，其格式正确：(IntegerPart) = "1" 且 (NonRepeatingPart) = "" 。 
```

**提示：**

1. 每个部分仅由数字组成。
2. 整数部分 `<IntegerPart>` 不会以 2 个或更多的零开头。（对每个部分的数字没有其他限制）。
3. `1 <= <IntegerPart>.length <= 4`
4. `0 <= <NonRepeatingPart>.length <= 4`
5. `1 <= <RepeatingPart>.length <= 4`

**解题思路**

这个问题如果使用暴力破解的话，那么这个问题就非常简单。我们只需要判断出括号中的数，然后重复个`16`次然后添加到字符串中。为什么是`16`次？我是试出来的，O(∩_∩)O哈哈~。实在不行，尽量较大的值即可。然后将字符串转换为`float`类型，然后判断输入的两个数的差是不是在误差允许的范围内即可。

```python
class Solution:
    def isRationalEqual(self, S, T):
        """
        :type S: str
        :type T: str
        :rtype: bool
        """
        return abs(self.toNumber(S) - self.toNumber(T)) < 1e-15
        
    def toNumber(self, s):
        norep, rep = '', ''
        n = 0
        for i in range(len(s)):
            if s[i] == '(':
                n = i
                norep = s[:i]
            elif s[i] == ')':
                rep = s[n+1:i]
            
        res = s
        if norep != '':
            res = norep
            
        if rep != '':
            res += rep*16
            
        return float(res)
```

一个更简洁的写法。

```python
class Solution:
    def isRationalEqual(self, S, T):
        """
        :type S: str
        :type T: str
        :rtype: bool
        """
        def toNumber(s):
            i = s.find('(')
            if i >= 0:
                s = s[:i] + s[i + 1:-1] * 20
            return float(s[:20])
        
        return toNumber(S) == toNumber(T)
```

贼蠢的问题，呵呵。

reference:

https://leetcode.com/problems/equal-rational-numbers/discuss/214203/JavaC%2B%2BPython-Easy-Cheat

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**