---
layout: post
title: Leetcode 998：最大二叉树 II（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-2-24 00:00:00
---

最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。

给出最大树的根节点 `root`。

就像[之前的问题](https://leetcode-cn.com/problems/maximum-binary-tree/)那样，给定的树是从表 `A`（`root = Construct(A)`）递归地使用下述 `Construct(A)` 例程构造的：

- 如果 `A` 为空，返回 `null`
- 否则，令 `A[i]` 作为 A 的最大元素。创建一个值为 `A[i]` 的根节点 `root`
- `root` 的左子树将被构建为 `Construct([A[0], A[1], ..., A[i-1]])`
- `root` 的右子树将被构建为 `Construct([A[i+1], A[i+2], ..., A[A.length - 1]])`
- 返回 `root`

请注意，我们没有直接给定 A，只有一个根节点 `root = Construct(A)`.

假设 `B` 是 `A` 的副本，并附加值 `val`。保证 `B` 中的值是不同的。

返回 `Construct(B)`。

 

**示例 1：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2019/02/21/maximum-binary-tree-1-1.png" width="200">
    <img src="https://assets.leetcode.com/uploads/2019/02/21/maximum-binary-tree-1-2.png" width="200">
</center>

```
输入：root = [4,1,3,null,null,2], val = 5
输出：[5,4,null,1,3,null,null,2]
解释：A = [1,4,2,3], B = [1,4,2,3,5]
```

**示例 2：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2019/02/21/maximum-binary-tree-2-1.png" width="200">
    <img src="https://assets.leetcode.com/uploads/2019/02/21/maximum-binary-tree-2-2.png" width="200">
</center>

```
输入：root = [5,2,4,null,1], val = 3
输出：[5,2,4,null,1,null,3]
解释：A = [2,1,5,4], B = [2,1,5,4,3]
```

**示例 3：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2019/02/21/maximum-binary-tree-3-1.png" width="200">
    <img src="https://assets.leetcode.com/uploads/2019/02/21/maximum-binary-tree-3-2.png" width="200">
</center>

```
输入：root = [5,2,3,null,1], val = 4
输出：[5,2,4,null,1,3]
解释：A = [2,1,5,3], B = [2,1,5,3,4]
```

**提示：**

1. `1 <= B.length <= 100`

**解题思路**

这个问题是之前问题[Leetcode 654：最大二叉树（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/87905985)的扩展。我们最简单的思路就是通过**中序遍历**获取所有点的值，然后将`val`插入到数组，再通过调用之前问题的函数就可以得到答案了。

```python
class Solution:
    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:
        nums = list()
        def inOrder(root):
            if root:
                inOrder(root.left)
                nums.append(root.val)
                inOrder(root.right)
                
        inOrder(root)
        nums.append(val)
        return self.constructMaximumBinaryTree(nums)
    
    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
        if nums:
            max_val = max(nums)
            max_index = nums.index(max_val)
            root = TreeNode(max_val)
            root.left = self.constructMaximumBinaryTree(nums[:max_index])
            root.right = self.constructMaximumBinaryTree(nums[max_index+1:])
            return root
```

如果你理解了之前问题最后一个解法，那么这个问题就可以更加简洁。

我们就是要找右子树中大于插入元素的第一个节点的位置，然后将当前节点插入其右侧（因为该节点在当前插入节点的左侧），而小于插入元素的节点，现在就变成插在其左侧（因为该节点在当前插入节点的左侧）。

```python
class Solution:
    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:
        tmp = TreeNode(val)
        if root.val < val:
            tmp.left = root
            return tmp
        
        cur = root
        while cur.right:
            if cur.right.val < val:
                tmp.left = cur.right
                cur.right = tmp
                break
            else:
                cur = cur.right
        else:
            cur.right = tmp
        return root
```

当然我们也可以通过递归来解决这个问题

```python
class Solution:
    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:
        if root.val < val:
            tmp = TreeNode(val)
            tmp.left = root
            return tmp
        
        if root.right:
            root.right = self.insertIntoMaxTree(root.right, val)
        else:
            tmp = TreeNode(val)
            root.right = tmp
        return root
```

关键还是之前问题的最后一种解法的思想。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**