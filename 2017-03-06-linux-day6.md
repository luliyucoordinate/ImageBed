---
layout: post
title: linux Day6
category : linux
tags : [linux, signal, c, pipe]
stickie: true
---


结束进程
===

有几个原因造成进程的终止：
1.  return
2.  exit函数
3.  _exit函数
4.  abort函数
5.  信号终止
前三者为正常。后两者不正常，无论为何终止，最后都会执行相同的内核代码，关闭文件，释放内存和其他清理工作。



exit
===

```
int exit(int status)
```
使程序正常终止，返回父进程状态 
与return的区别，可以函数中使用  
abort 

```
void abort(void)
```
abort可以然程序产生core，用于分析崩溃文件  
abort比较粗暴，作为最后的手段使用，碰到内存不足这样的问题时，无法用程序的方式处理时再使用。 
该函数发送SIGABRT信号给调用进程，进程不该忽略这个信号。  
即使进程捕获到这个信号，进程还是会异常退出。让进程捕获的意义在于，在进程中之前执行所需的清理操作。



kill
===

```c
<signal.h>
<sys/types.h>
int kill(pid_t pid, int sig)
```
Kill用来杀死其他进程，pid只要杀的进程，sig要发送的信号（杀死进程SIGKILL，ctrl+c的信号是SIGINT）



so文件
===

so文件在linux中为共享库，类似windows下的dll  
so文件中的函数可以供多个进程调用  
即使不同进程调用一个so文件，并不能实现通信，不在同一个内存空间  
so文件的源文件中不需要main函数  
编译的时候gcc需要加-fPIC选项，使gcc产生与位置无关的代码  
连接的时候gcc需要加-shared选项，生成一个共享库文件  
文件名要以lib开头，扩张名位.so  

so文件的使用需要在.bash_profile中添加export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.  
或者将文件放入linux的系统目录/usr/lib/  
在c文件中添加so文件，首先需要#include头文件  
gcc链接时添加-L参数指明so文件路径，-l参数指明so文件名  
例子： gcc –L. –ltest –o a a.o  
-L.指在当前路径下找so文件  
-ltest为要连接libtest.so这个库文件  
-o a编译后的可执行文件名为a  


当我们在cpp文件中包含头文件，用g++连接库文件时出错

```
(.test+0x19):undefined reference to`max(int, int)’
(.test+0x19):undefined reference to `add(int,int)’
```
我们需要增加带有_cplusplus的预编译指令
 
```c
#ifdef ___cplusplus
extern "C"{
#endif

#ifdef __cplusplus
}
#endif
```


无名管道
===

半双工，只能读或写，只能在相关的、有共同祖先的进程间使用(fork execve)

```c
int pipe(int fledes[2])
```
如果成功建立管道，会打开两个文件描述符，保存在一个整数数组中  
第一个文件描述符用于读取数据，第二个文件描述符用于写入数据  
如果出错返回-1·同时设置errno   
关闭一个管道用close()  
读写管道与读写文件一样，调用write与read函数  
管道是用来交换数据的，试图对一个管道两端进行读写操作是一个严重的错误，只存在一个读一个写。


有名管道
===

有名管道(FIFO)  
长久稳定，存在于文件系统中，可以让无关联的进程之间交换数据  
一个shell命令可以建立有名管道
mkfifo[option] name                   mkfifo创建一个名为name的有名管道  
mkfifo fifo1                          创建一个有名管道fifo1  
cat < fifo1                 	        通过cat命令从fifo1中读取数据  
ls > fifo1                		        将ls命令的结果写入fifo1数据  

创建fifo

```c
int mkfifo(const char *pathname, mode_tmode) 
```
成功返回0，失败返回-1，设置变量errno

删除fifo

```c
int unlink(const char *pathname)
```
成功返回0，失败返回-1，设置变量errno

打开关闭fifo

```c
int open(const char *pathname, int flags)
int close(int fd)
```
open中的参数flags为O_RDONLY 将阻塞open调用，一直到另一个进程为写入数据打开FIFO为止。  
相同的，O_WRONLY也导致阻塞一直到为读出数据打开FIFO为止。



共享内存
===

共享内存是由内核出于在多个进程间交换信息的目的留下的一块内存区。  
如果段的权限设置恰当，每个要访问该断内存的进程都可以把它映射到自己的私有地址空间。  
如果一个进程跟新了段中的数据，其他进程也可以看到。  
一个进程创建的段，里一个进程也可以写。  
每个进程都把它自己对共享内存的映像放入自己的地址空间。

```c
<sys/ipc.h>
<sys/shm.h>
int shmget(key_t key, size_t size, intshm-flg)
```
参数key既可以是IC_PRIVATE(系统设置)，也可以是ftok函数的返回关键字  
size指定段的大小  
flags为8进制，设置权限0xxx  
函数成功返回标识符，失败返回-1  

通过ipcs –m 查看共享内存  
通过ipcrm shm shmid删除共享内存  
附加共享内存

```c
void *shmat(int shmid, const vod *ahmaddr,int shmflg);
int shmdt(const void *shmaddr);`
```
shmid是要附加共享内存的标识符，shmaddr总是设置为0(系统分配)。 
参数shmflg可以为SHM_RDONLY，这意味着附加段是只读的。  
成功返回被附加段的地址，失败-1，设置errno  
函数shmdt是将附加在shmaddr的段从调用进程的地址空间分离出去，这个地址必须是shmat返回的。



捕获信号
===

```c
int pause(void);
```
pause函数挂其他的进程直到消息到达。调用进程必须有能力处理送达的信号，否则信号的默认部署就会发生。  
只有进程捕获到一个信号的时候pause才会返回，信号处理发生在pause返回前执行。  
pause总是返回-1，errno变量设置为EINTR  
每个进程能够决定响应除了SIGSTOP和SIGKILL之外的其他所有信号，这两个信号不能捕获或者忽略。  
当一个进程调用fork的时候，其子进程继承父进程的信号处理方式，所有信号捕捉函数的地址在子进程中是有意义的。



signal函数
===

```c
<signal.h>
void (*signal(int signo, void(*func)(int)))(int );
```
linux/unix处理信号最常用的接口  
signo为信号名，func接受此信号的调用函数，该函数的参数代表捕获到的信号值  
kill –s +信号名+pid    可以看出kill是用来发信号的


发送信号
===

使用kill命令
使用kill函数

```c
<signal.h>
<sys/typed.h>
Int kill(pid_t pid,int sig);
```
pid指定要发信号的进程，sig要发送的信号  
使用raise函数

```c
<signal.h>
int rasie(int signo);
```
kill函数将信号发送给别的进程，raise函数允许进程向自身发送信号。

```c
raise(digno) = kill(getpid(), signo);
```
alarm函数设置一个定时器，当定时器到了就给自己发SIGALRM信号，alarm的默认行为是退出进程，所以必须要捕获。所以最好对每个可捕获的消息，都要写捕获函数。

```c
<unistd.h>
unsigned int alarm(unsigned int seconds);
```
seconds是计时器时间，一个进程只可以设置一次。再次把seconds设置为0，取消alarm。



作业控制信号
===

SIGCHLD          子进程已停止或终止  
SIGCONT          如果进程停止，使其继续进行  
SIGSTOP          停止信号，无法捕获  
SIGTTIN          后台进程组成员读控制终端  
SIGTTOU          后台进程组成员写控制终端  
除了SIFCHLD以外，大多数程序不处理这些信号。Shell程序一般需要处理这些信号。  
信号用于大多数复杂的应用中。

