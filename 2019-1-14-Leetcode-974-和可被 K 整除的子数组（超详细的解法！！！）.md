---
layout: post
title: Leetcode 974：和可被 K 整除的子数组（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-14 00:00:00
---

给定一个整数数组 `A`，返回其中元素之和可被 `K` 整除的（连续、非空）子数组的数目。 

**示例：**

```
输入：A = [4,5,0,-2,-3,1], K = 5
输出：7
解释：
有 7 个子数组满足其元素之和可被 K = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] 
```

**提示：**

1. `1 <= A.length <= 30000`
2. `-10000 <= A[i] <= 10000`
3. `2 <= K <= 10000`

**解题思路**

这个问题和之前的问题[Leetcode 525：连续数组（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/86472802)和[Leetcode 560：和为K的子数组（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/86473609)类似，我们还是使用累加和的做法。同样，我们对于这种问题的关键就是找到对称点（也就是我们关心的是在字典中存什么的问题），由于这个问题是考虑**元素之和可被K整除**，所以我们通过字典去记录**累加和%K**的**余数**即可。接着剩余的问题就和[Leetcode 560：和为K的子数组（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/86473609)一模一样了。

同样考虑边界情况，也就是`pre_sum%K==0`的时候，此时一个好的处理办法就是在初始化`dict`的时候，添加`{0:1}`。

```python
class Solution:
    def subarraysDivByK(self, A, K):
        """
        :type A: List[int]
        :type K: int
        :rtype: int
        """
        pre_sum, res = 0, 0
        dic = {0:1}
        
        for val in A:
            pre_sum = (pre_sum + val) % K
            if pre_sum in dic:
                res += dic[pre_sum]
            dic[pre_sum] = dic.get(pre_sum, 0) + 1
                
        return res 
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**