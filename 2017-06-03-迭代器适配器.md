---
layout: post
title: 迭代器适配器
category : cpp
tags : [cpp, notes, cpp标准库, 迭代器]
---

Reverse（反向）迭代器
---

你可以将正常的迭代器转化为reverse迭代器。当然，原本那个迭代器必须具有双向移动功能。要注意的是，转换前后的迭代器逻辑位置发生了变化。  

```c++
#include <iterator>
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
    // create list with elements from 1 to 9
    vector<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    // find position of element with value 5
    vector<int>::const_iterator pos;
    pos = find (coll.cbegin(), coll.cend(),
                5);

    // print value to which iterator pos refers
    cout << "pos:  " << *pos << endl;

    // convert iterator to reverse iterator rpos
    vector<int>::const_reverse_iterator rpos(pos);

    // print value to which reverse iterator rpos refers
    cout << "rpos: " << *rpos << endl;
}
```
程序输出如下：  

```c++
pos:  5
rpos: 4
```
这是由于reverse迭代器在设计是做了一个小技巧，他实际倒置“半开原则”。reverse迭代器所定义的区间并不包括起点，反而包括了终点。  

Insert（安插型）迭代器
---

```c++
template< class Container >
class insert_iterator : public std::iterator< std::output_iterator_tag,
                                              void,void,void,void >
```
std::insert_iterator是一个输出迭代器，它被构造，在该位置到一个容器中插入元素指出，由所提供的迭代器，使用容器的insert()每当迭代器（不论是否解除引用或不）被分配到的成员函数。递增std::insert_iterator是一个no-op。general inserter对所有标准容器均使用（只有array和forward list除外），因为那些容器都提供insert成员函数。然而对于associative和unordered容器而言，安插位置只是个提示，因为在这两个容器转给你元素的真正位置视为value而定。  
安插动作完成后，general inserter获得刚被安插的那个元素的位置。相当于使用下面的语句：  

```c++
pos = container.insert(pos, value);
++pos;
```
为什么要将insert的返回值赋给pos？原因在于为了确保迭代器的位置始终有效。如果没有这个复制动作，在deque、vector和string中，该general inserter本身可能会失效。  

```c++
template< class Container >
class back_insert_iterator : public std::iterator< std::output_iterator_tag,
                                                   void,void,void,void >
```
std::back_insert_iterator是OutputIterator追加到一个容器，它被构造，使用容器的push_back()每当迭代器（不论是否解除引用或不）被分配到的成员函数。递增std::back_insert_iterator是一个no-op。由于push_back只存在于vector、deque、list和string，所以c++标准库中只有这些容器支持back insert。  

```c++
template< class Container >
class front_insert_iterator : public std::iterator< std::output_iterator_tag,
                                                   void,void,void,void >
```
std::front_insert_iterator是输出预先考虑元素的迭代器，它被修建的容器，使用时容器的push_front()成员函数的迭代器（是否解除引用或不）被分配给的。递增std::front_insert_iterator是一个no-op。由于push_front只在deque、list和forward list有实现，所以只有这些容器可以使用。  

Stream（串流）迭代器
---

```c++
template< class T,
          class CharT = char,
          class Traits = std::char_traits<CharT> >
class ostream_iterator : public std::iterator<std::output_iterator_tag,
                                              void, void, void, void>
```
(until C++17)

```c++
template< class T,
          class CharT = char,
          class Traits = std::char_traits<CharT>>
class ostream_iterator;
```
(since C++17)  
std::ostream_iterator is a single-pass OutputIterator that writes successive objects of type T into the std::basic_ostream object for which it was constructed, using operator<<. Optional delimiter string is written to the output stream after every write operation. The write operation is performed when the iterator (whether dereferenced or not) is assigned to. Incrementing the std::ostream_iterator is a no-op.  
In a typical implementation, the only data members of std::ostream_iterator are a pointer to the associated std::basic_ostream and a pointer to the first character in the delimiter string.
When writing characters, std::ostreambuf_iterator is more efficient, since it avoids the overhead of constructing and destructing the sentry object once per character.  
例子：  

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
using namespace std;

int main()
{
    // create ostream iterator for stream cout
    // - values are separated by a newline character
    ostream_iterator<int> intWriter(cout,"\n");
    // write elements with the usual iterator interface
    *intWriter = 42;
    intWriter++;
    *intWriter = 77;
    intWriter++;
    *intWriter = -5;
    // create collection with elements from 1 to 9
    vector<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    // write all elements without any delimiter
    copy (coll.cbegin(), coll.cend(),
          ostream_iterator<int>(cout));
    cout << endl;
    // write all elements with " < " as delimiter
    copy (coll.cbegin(), coll.cend(),
          ostream_iterator<int>(cout," < "));
    cout << endl;
}
```
结果为：  

```c++
42
77
-5
123456789
1<2<3<4<5<6<7<8<9<
```
注意分隔符类型为const char\*。如果你传入string对象的话，就要调用c_str函数。  

```c++
template< class T,
          class CharT = char,
          class Traits = std::char_traits<CharT>,
          class Distance = std::ptrdiff_t >
class istream_iterator: public std::iterator<std::input_iterator_tag,
                                             T, Distance, const T*, const T&>
```
(until C++17)

```c++
template< class T,
          class CharT = char,
          class Traits = std::char_traits<CharT>,
          class Distance = std::ptrdiff_t >
class istream_iterator;
```
(since C++17)  
std::istream_iterator is a single-pass input iterator that reads successive objects of type T from the std::basic_istream object for which it was constructed, by calling the appropriate operator>>. The actual read operation is performed when the iterator is incremented, not when it is dereferenced. The first object may be read when the iterator is constructed or when the first dereferencing is done. Otherwise, dereferencing only returns a copy of the most recently read object.  
The default-constructed std::istream_iterator is known as the end-of-stream iterator. When a valid std::istream_iterator reaches the end of the underlying stream, it becomes equal to the end-of-stream iterator. Dereferencing or incrementing it further invokes undefined behavior.
A typical implementation of std::istream_iterator holds two data members: a pointer to the associated std::basic_istream object and the most recently read value of type T.  
T must meet the DefaultConstructible, CopyConstructible, and CopyAssignable requirements.  
例子：  

```c++
#include <iostream>
#include <iterator>
using namespace std;

int main()
{
    // create istream iterator that reads integers from cin
    istream_iterator<int> intReader(cin);
    // create end-of-stream iterator
    istream_iterator<int> intReaderEOF;
    // while able to read tokens with istream iterator
    // - write them twice
    while (intReader != intReaderEOF) {
        cout << "once:       " << *intReader << endl;
        cout << "once again: " << *intReader << endl;
        ++intReader;
    }
}
```

输入：  

```c++
1 2 3 f 4
```
结果为：  

```c++
once:       1
once again: 1
once:       2
once again: 2
once:       3
once again: 3
```
结果出现的问题在于，格式错误。  

Move（搬移）迭代器
---

```c++
template< class Iterator >
std::move_iterator<Iterator> make_move_iterator( const Iterator& i );
```
(since C++11)   
(until C++14)  

```c++
template< class Iterator >
std::move_iterator<Iterator> make_move_iterator( Iterator i );
```
(since C++14)   
(until C++17)  

```c++
template< class Iterator >
constexpr std::move_iterator<Iterator> make_move_iterator( Iterator i );
```
(since C++17)  
make_move_iterator is a convenience function template that constructs a std::move_iterator for the given iterator i with the type deduced from the type of the argument.  

Iterator Trait（迭代器特性）
---

```c++
struct input_iterator_tag { };
struct output_iterator_tag { };
struct forward_iterator_tag : public input_iterator_tag { };
struct bidirectional_iterator_tag : public forward_iterator_tag { };
struct random_access_iterator_tag : public bidirectional_iterator_tag { };
```
Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five iterator categories:  
1.  input_iterator_tag corresponds to InputIterator.
2.  output_iterator_tag corresponds to OutputIterator.
3.  forward_iterator_tag corresponds to ForwardIterator.
4.  bidirectional_iterator_tag corresponds to BidirectionalIterator.
5.  random_access_iterator_tag corresponds to RandomAccessIterator.

Iterator category tags carry information that can be used to select the most efficient algorithms for the specific requirement set that is implied by the category.  
For every iterator type, a typedef std::iterator_traits\<Iterator\>::iterator_category is available, which is an alias to one of these five tag types.  

```c++
template< class Iterator>
struct iterator_traits;
template< class T >
struct iterator_traits<T*>;
template< class T >
struct iterator_traits<const T*>;
```

std::iterator_traits is the type trait class that provides uniform interface to the properties of Iterator types. This makes it possible to implement algorithms only in terms of iterators.
The class defines the following types:  
1.  difference_type - a type that can be used to identify distance between iterators
2.  value_type - the type of the values that can be obtained by dereferencing the iterator. This type is void for output iterators.
3.  pointer - defines a pointer to the type iterated over (value_type)
4.  reference - defines a reference to the type iterated over (value_type)
5.  iterator_category - the category of the iterator. Must be one of iterator category tags.

The template can be specialized for user-defined iterators so that the information about the iterator can be retrieved even if the type does not provide the usual typedefs.  

```c++
template< 
    class Category,
    class T,
    class Distance = std::ptrdiff_t,
    class Pointer = T*,
    class Reference = T& 
> struct iterator;
```

(deprecated in C++17)  
std::iterator is the base class provided to simplify definitions of the required types for iterators.  
其中第一个template参数定义迭代器种类，第二个参数用来定义元素类型，第三个参数用来定义difference类型，第四个参数用来定义point而类型，第五个参数用来定义reference类型。  
