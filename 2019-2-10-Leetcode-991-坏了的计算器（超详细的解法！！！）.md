---
layout: post
title: Leetcode 991：坏了的计算器（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-2-10 00:00:00
---

在显示着数字的坏计算器上，我们可以执行以下两种操作：

- **双倍（Double）：**将显示屏上的数字乘 2；
- **递减（Decrement）：**将显示屏上的数字减 1 。

最初，计算器显示数字 `X`。

返回显示数字 `Y` 所需的最小操作数。

**示例 1：**

```
输入：X = 2, Y = 3
输出：2
解释：先进行双倍运算，然后再进行递减运算 {2 -> 4 -> 3}.
```

**示例 2：**

```
输入：X = 5, Y = 8
输出：2
解释：先递减，再双倍 {5 -> 4 -> 8}.
```

**示例 3：**

```
输入：X = 3, Y = 10
输出：3
解释：先双倍，然后递减，再双倍 {3 -> 6 -> 5 -> 10}.
```

**示例 4：**

```
输入：X = 1024, Y = 1
输出：1023
解释：执行递减运算 1023 次
```

**提示：**

1. `1 <= X <= 10^9`
2. `1 <= Y <= 10^9`

**解题思路**

这是一个贪心算法问题。如果`X>=Y`的话，那么问题很容易，直接返回`X-Y`即可。如果`X < Y`并且`Y`是偶数的话，我们`Y//=2`，否则的话`Y+=1`，最后统计做了多少步计算即可。为什么？

首先我们先要明确为什么先除`Y`再`X`减，而不是`X`先乘再减？比如`X-k=Y/2`，而`2X-2k=Y`，那么前者需要`K+1`次操作，而后者需要`2K+1`次操作。所以此时我们知道前者的效率会更高，那么使用前者我们就会出现一个问题。如果`Y`是奇数的话，我们要怎么做呢？此时我们只需要`Y+1`即可，为什么不是`X-1`？如果`X=(Y+1)/2+k`，也就是`2X-2K-1=Y`，只需要`K+2`次，而`X-1`的话，那么`X-K-1=Y/2-1`（此时`Y`是奇数会向下取整，也就是说`X-K=(Y+1)/2=Y/2`），需要`K+3`次。

```python
class Solution:
    def brokenCalc(self, X: 'int', Y: 'int') -> 'int':
        res = 0
        while X < Y:
            res += Y & 1 + 1
            Y = (Y + 1) // 2
        return res + X - Y
```

使用递归的话更加简洁

```python
class Solution:
    def brokenCalc(self, X: 'int', Y: 'int') -> 'int':
        if X >= Y:
            return X - Y
        return 1 + self.brokenCalc(X, Y + 1 if Y % 2 else Y // 2)
```

reference:

https://leetcode.com/problems/broken-calculator/discuss/234484/JavaC%2B%2BPython-Change-Y-to-X-in-1-Line

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**