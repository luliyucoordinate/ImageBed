---
layout: post
title: 字节跳动2019笔试：国庆旅行（超详细的解法！！！）
category : 算法
tags : [bytedance]
stickie: true
date: 2019-6-26 00:00:00
---

小明国庆节来北京玩，北京有N个景点，第 i 个景点的评分用a[i]表示，两个景点i, j之间的距离为$j - i(j > i)$。

小明一天只能游玩两个景点，我们认为总评分是两个景点的评分之和减去两个景点之间的距离，即为$a[i]+a[j]+i-j$。

那么小明选择哪两个景点才会总评分最大呢？

**输入格式**

第一行包含整数N。

第二行分别输入N个景点的评分。

**输出格式**

输出最大评分

**数据范围**

$2≤N≤10^5$,
$1≤a[i]≤1000$

**输入样例**：

```
5
11 6 5 18 12
```

**输出样例**：

```
29
```

**解题思路**

这个问题和[Leetcode 1014：最佳观光组合（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/88792543)是一样的。首先我们假设我们去的两个景点是`i`和`j`，那么最后总评分是`(a[i]+i)+(a[j]-j)`，所以不难想到通过两次循环遍历`i`和`j`。但是数据范围是$10^5$，所以这么做肯定不行。有没有更快的办法？

我们每次遍历`A`中的元素`a`，对于我们遍历过的元素我们当然知道谁是最大的。例如，`[8,1,5,2,6]`，我们遍历到`8`，我们当然知道`8`是那个最大的，接着我们会找第二个数。当我们遍历到`1`的时候，此时`8`距离我们的位置就变成`1`，也就是说`8`会变成`7`，此时我们的和就是`1+7`，是不是最大的和呢？不知道，还要继续遍历下去。接着找到`5`，此时`8`距离`5`是`2`，所以`8`变成了`6`，所以此时的和就变成了`6+5=11`。就这样依次遍历下去，直到所有元素都找完。

```cpp
#include <iostream>
using namespace std;
const int N = 1e5 + 10;
int a[N];

int main()
{
    int n;
    cin >> n;
    for (int i = 0; i < n; ++i) cin >> a[i];
    int cur = 0, res = 0;
    for (int i = 0; i < n; ++i)
    {
        res = max(res, cur + a[i]);
        cur = max(cur, a[i]) - 1;
    }
    cout << res << endl;
}
```

**如有问题，希望大家指出！！！**