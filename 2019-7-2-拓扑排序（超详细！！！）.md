---
layout: post
title: 拓扑排序（超详细！！！）
category : 算法
tags : [c++]
stickie: true
date: 2019-7-2 00:00:00
---

对于一个有向无环图来说拓扑排序的结果遵循如下规则，即如果有一条从顶点$v_i$指向顶点$v_j$的边，那么最后的排序结果中$v_i$一定在$v_j$的前面。例如

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/topsort/2019_7_2_1.png" width="300">
</center>

这个图的拓扑排序就是`1 2 3 4 5`。

同一个图可以有多个拓扑排序结果，对于上面那个图，还有一种排序结果就是`1 2 3 5 4`。

为了可以进行拓扑排序，给定的图中不可以有环。我们可以简单论证一下，假设图中的顶点为$v_1,v_2,v_3...v_n$，并且这些点构成环，也就是说有一条边从$v_i$指向$v_{i+1}$（其中$1\leq i < n$）并且有一条边从$v_{n}$指向$v_1$。那么现在我们进行拓扑排序的话，$v_n$一定要排在$v_1$之前，因为有一条$v_n$指向$v_1$的边。而$v_{i}$一定排在$v_{i+1}$的前面，因为有一条从$v_{i}$指向$v_{i+1}$的边。那么这意味着$v_1$排在$v_n$前面，所以这和前面矛盾。

接着我们思考一下如何找到一个图的拓扑排序。最基本的思路就是找到一组顶点的排列，使得所有指向$v_j$的顶点$v_i$，都排在顶点$v_j$的前面。我们维护一个数组$T$存储拓扑排序结果。因此，对于一个拥有$N$个顶点的图来说，我们先建立一个大小为$N$的数组$in\_degree[]$，其$i^{th}$元素表示$v_i$的入度（也就是所有指向$v_i$点的数量）。我们将顶点$v_i$插入到$T$中的同时，要将$in\_degree[v_j]$减`1`（其中$v_j$表示$v_i$指向的所有点）。在任何时候我们都只能插入$in\_degree[]$为`0`的顶点。

下面是`bfs`的伪代码

```python
topological_sort(N, adj[N][N])
        T = []
        visited = []
        in_degree = []
        for i = 0 to N
                in_degree[i] = visited[i] = 0

        for i = 0 to N
                for j = 0 to N
                        if adj[i][j] is TRUE
                                in_degree[j] = in_degree[j] + 1

        for i = 0 to N
                if in_degree[i] is 0
                        enqueue(Queue, i)
                        visited[i] = TRUE

        while Queue is not Empty
                vertex = get_front(Queue)
                dequeue(Queue)
                T.append(vertex)
                for j = 0 to N
                        if adj[vertex][j] is TRUE and visited[j] is FALSE
                                in_degree[j] = in_degree[j] - 1
                                if in_degree[j] is 0
                                        enqueue(Queue, j)
                                        visited[j] = TRUE
        return T
```

我们举一个例子看看这个算法是如何工作的，考虑下面这个图

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/topsort/2019_7_2_2.png" width="600">
</center>

一开始$in\_degree[0]=0$并且$T$是空

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/topsort/2019_7_2_3.png" width="400">
</center>

所以我们从$queue$中删除`0`，将其添加到$T$中。接着我们将所有`0`指向的点（`1`，`2`，`3`）的入度减`1`。现在$in\_deque[1]=0$，我们将`1`添加到$queue$中

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/topsort/2019_7_2_4.png" width="400">
</center>

接着我们将`1`从$queue$中弹出，然后添加到$T$中。接着我们将所有`1`指向的点（`2`，`4`）的入度减`1`。现在$in\_deque[2]=0$，我们将`2`添加到$queue$中

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/topsort/2019_7_2_5.png" width="400">
</center>

接着做类似操作

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/topsort/2019_7_2_6.png" width="400">
</center>

所以我们最终得到的拓扑排序数组是`0,1,2,3,4,5`。

我们也可以通过`dfs`来处理该问题，使用`dfs`的话，我们就不用建立$in\_degree$数组了。下面是`dfs`的伪代码

```python
T = []
visited = []

topological_sort( cur_vert, N, adj[][] ){
    visited[cur_vert] = true
    for i = 0 to N
        if adj[cur_vert][i] is true and visited[i] is false
        topological_sort(i)
    T.insert_in_beginning(cur_vert)
}
```

reference:

https://www.hackerearth.com/zh/practice/algorithms/graphs/topological-sort/tutorial/

**如有问题，希望大家指出！！！**