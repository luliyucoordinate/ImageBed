---
layout: post
title: 为什么希尔排序表现出来的速度比归并排序快呢？
category : 算法
tags : [shell, merge,  cpp]
stickie: true
date: 2018-03-31 00:00:00
---

我这里给出我测试的时候使用的代码

```c++
template<typename T>
void shellSort(T arr[], int n)
{
	for (int gap = n / 2; gap > 0; gap /= 2)
	{
		for (int i = gap; i < n; ++i)//使用了优化后的插入排序
		{
			T temp = arr[i];
			int j = 0;
			for (j = i; j >= gap && temp < arr[j - gap]; j -= gap)
			{
				arr[j] = arr[j - gap];
			}
			arr[j] = temp;
		}
	}	
}
```

下面是归并排序

```c++
template<typename T>
void __merge(T arr[], int l, int mid, int r)
{
	T *aux = new T[r - l + 1];
	for (int i = l; i <= r; ++i)
	{
		aux[i - l] = arr[i];
	}
	int i = l, j = mid + 1;
	for (int k = l; k <= r; ++k)
	{
		if (i > mid)
		{
			arr[k] = aux[j - l];
			++j;
		}
		else if (j > r)
		{
			arr[k] = aux[i - l];
			++i;
		}
		else if (aux[i - l] < aux[j - l])
		{
			arr[k] = aux[i - l];
			++i;
		}
		else
		{
			arr[k] = aux[j - l];
			++j;
		}
	}
	delete[] aux;
}

template<typename T>
void __mergeSort(T arr[], int l, int r)
{
	if (l - r <= 15)//优化
	{
		insertSortv2(arr, l, r);
		return;
	}
	int mid = (l + r) / 2;		//可能出现溢出
	__mergeSort(arr, l, mid);
	__mergeSort(arr, mid + 1, r);
	if (arr[mid] > arr[mid + 1])//优化
	{
		__merge(arr, l, mid, r);
	}
}

template<typename T>
void mergeSort(T arr[], int n)
{
	__mergeSort(arr, 0, n - 1);
}
```

我分别在10000组无序和部分无序数据下测试

```c++
//完全无序数据
shell Sort : 0.002 s
merge Sort : 0.06 s
//部分无序数据
shell Sort : 0.001 s
merge Sort : 0.001 s
```

我猜测可能是数据过小，所以增加到100000

```c++
//完全无序数据
shell Sort : 0.026 s
merge Sort : 5.192 s
//部分无序数据
shell Sort : 0.008 s
merge Sort : 0.005 s
```

这里的结果就让我感到很奇怪了，当我们的数据量很大的时候，归并排序对于完全无序数据排序居然被希尔排序吊打，这是怎么回事？

嗯~ o(*￣▽￣*)o，我猜测可能是这段代码的原因（递归的层数过深了， 另一种可能是我使用的是VS，所以代码中我不得不使用了new操作，这也可能是原因），所以我又尝试了很多种做法，都没办法打败这个希尔排序。

最后我发现了我代码中的一个bug

```c++
if (l - r <= 15)//优化，应该是r-l
{
    insertSortv2(arr, l, r);
    return;
}
```

最后测试结果是这样的（数据是100000）

```c++
shell Sort : 0.024 s
merge Sort : 0.019 s
shell Sort : 0.007 s
merge Sort : 0.003 s
```





