---
layout: post
title: Leetcode 994：腐烂的橘子（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-2-18 00:00:00
---

在给定的网格中，每个单元格可以有以下三个值之一：

- 值 `0` 代表空单元格；
- 值 `1` 代表新鲜橘子；
- 值 `2` 代表腐烂的橘子。

每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。

返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`。

**示例 1：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2019/02/16/oranges.png" width="700">
</center>

```
输入：[[2,1,1],[1,1,0],[0,1,1]]
输出：4
```

**示例 2：**

```
输入：[[2,1,1],[0,1,1],[1,0,1]]
输出：-1
解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。
```

**示例 3：**

```
输入：[[0,2]]
输出：0
解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。
```

**提示：**

1. `1 <= grid.length <= 10`
2. `1 <= grid[0].length <= 10`
3. `grid[i][j]` 仅为 `0`、`1` 或 `2`

**解题思路**

这个问题类似于岛屿问题，我们只需将所有的烂橘子的坐标存放到一个队列里面，然后通过`BFS`将附近的新鲜橘子腐蚀即可。

```python
class Solution:
    def orangesRotting(self, grid: 'List[List[int]]') -> 'int':
        r, c = len(grid), len(grid[0])
        rot = list()
        for i in range(r):
            for j in range(c):
                if grid[i][j] == 2:
                    rot.append((i, j, 0))
        
        d = [(0,1), (0,-1), (1,0), (-1,0)]
        res = 0
        while rot:
            i, j, res = rot.pop(0)
            for xd, yd in d:
                x = i + xd
                y = j + yd
                if 0 <= x < r and 0 <= y < c and grid[x][y] == 1:
                    grid[x][y] = 2
                    rot.append((x, y, res+1))
            
        if any(1 in row for row in grid):
            return -1
        return res
```

目前没有看到什么比较出奇的想法。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**