---
layout: post
title: Leetcode 953：验证外星语词典（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-12-15 00:00:00
---

某种外星语也使用英文小写字母，但可能顺序 `order` 不同。字母表的顺序（`order`）是一些小写字母的排列。

给定一组用外星语书写的单词 `words`，以及其字母表的顺序 `order`，只有当给定的单词在这种外星语中按字典序排列时，返回 `true`；否则，返回 `false`。

**示例 1：**

```
输入：words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
输出：true
解释：在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。
```

**示例 2：**

```
输入：words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
输出：false
解释：在该语言的字母表中，'d' 位于 'l' 之后，那么 words[0] > words[1]，因此单词序列不是按字典序排列的。
```

**示例 3：**

```
输入：words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"
输出：false
解释：当前三个字符 "app" 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 "apple" > "app"，因为 'l' > '∅'，其中 '∅' 是空白字符，定义为比任何其他字符都小（更多信息）。 
```

**提示：**

1. `1 <= words.length <= 100`
2. `1 <= words[i].length <= 20`
3. `order.length == 26`
4. 在 `words[i]` 和 `order` 中的所有字符都是英文小写字母。

**解题思路**

最简单的思路就是通过`sorted`函数里面的`cmp`函数属性，但是在`python3`中移除了这个东西，但是可以使用`cmp_to_key`替代。

```python
from functools import cmp_to_key
class Solution:
    def isAlienSorted(self, words, order):
        """
        :type words: List[str]
        :type order: str
        :rtype: bool
        """
        words_dict = {c: i for i, c in enumerate(order)}
        
        def helper(x, y):
            nonlocal words_dict
            x_len, y_len = len(x), len(y)
            i, j = 0, 0
            while i < x_len and j < y_len:
                if x[i] == y[j]:
                    i += 1
                    j += 1
                    continue
                if words_dict[x[i]] < words_dict[y[j]]:
                    return -1
                if words_dict[x[i]] > words_dict[y[j]]:
                    return 1
            if i == x_len and j == y_len:
                return 0
            if i < x_len:
                return 1
            if j < y_len:
                return -1
        
        return words == sorted(words, key=cmp_to_key(lambda x, y:helper(x, y)))
```

我们这里使用了一个`dict`去存储我们的`order`中的字母顺序，这样做的好处就是比我们直接使用`index`这个内置函数方法快上许多。对于例1就是

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/953/2018_12_15_1.png" width="700" hegiht="313">
</center>

我们还有一种更加简洁的写法。

```python
class Solution:
    def isAlienSorted(self, words, order):
        """
        :type words: List[str]
        :type order: str
        :rtype: bool
        """
        return words == sorted(words, key=lambda x: list(map(order.index, x)))
```

我们也可以不同排序，直接比较字符对应的数字即可（实际上和第一种方式一样，只是我们现在的实现方式更加的`pythonic`）。

```python
class Solution:
    def isAlienSorted(self, words, order):
        """
        :type words: List[str]
        :type order: str
        :rtype: bool
        """
        order = {c:i for i, c in enumerate(order)}
        
        for word1, word2 in zip(words, words[1:]):
            for a,b in zip(word1, word2):
                if a != b:
                    if order[a] > order[b]:
                        return False
                    break
            else:
                if len(word1) > len(word2):
                    return False
        return True
```

我们也可以将`words`中的单词，通过我们建立的`dict`替换为对应的数字。例如对于例1中的`hello`，我们可以替换为

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/953/2018_12_15_2.png" width="400" hegiht="313">
</center>

我们只要比较替换后字符串即可。

```python
class Solution:
    def isAlienSorted(self, words, order):
        """
        :type words: List[str]
        :type order: str
        :rtype: bool
        """
        m = {c: i for i, c in enumerate(order)}
        words = [[m[c] for c in w] for w in words]
        return all(w1 <= w2 for w1, w2 in zip(words, words[1:]))
```

reference:

https://leetcode.com/problems/verifying-an-alien-dictionary/discuss/203185/JavaC++Python-Mapping-to-Normal-Order

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**