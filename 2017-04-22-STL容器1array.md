---
layout: post
title: STL容器（1）array
category : cpp
tags : [cpp, notes, cpp标准库]
stickie: true
---


Array
===
为了使用array，首先必须加头文件<array>

```c++
#include <array>
```
该类型被定义为一个class template，在命名空间std中：

```c++
namespace std{
	template <typename T, size_t N>
	class Array;
}
```
要注意的是Array并不支持分配器，也就是说不允许指定自己的allocator

Array的能力
---
Array会把元素复制到其内的static C-style array中。这些元素总是拥有一个明确次序。Array允许随机访问，你可以在常量时间内访问任何元素。Array的迭代器属于随机访问迭代器，所以你可以使用任意的STL算法。  
关于初始化，class array有一些独特的语法。注意，array是唯一一个“无任何东西被指定为初值时，会被与初始化”的容器。这意味着对于基础类型，初值可能不明确，而不是0。例如：

```c++
std::array<int,4> x;elements of x have undefined value
```
这里要提一些什么是明确的初始化，对于明确的初始化，基础类型会被设定初值为0：

```c++
int i1;//undefined value
int i2 = int();//initialized with zero
int i3{};//initialized with zero
```
array满足聚合体要求，因此可以使用处置列来设定array，聚合体（aggregate）是一个class或array，不带用户提供的构造函数，也没有private和protected的nostatic的数据成员，也没有base class ，也没有virtual函数。

```c++
std::array<int,3> c = {1,2,3};
```
如果初值列内的元素个数多余array的大小，这样的表达式就不对：

```c++
std::array<int,3> c1 = {1,2,3,4};//ERROR too many values
```
由于没有提供初值列而写的构造函数和assignment操作符，因此“在array声明期间完成初始化”是使用初值列的唯一途径。

```c++
std::array<int,3> a({1,2,3});//ERROR 
std::vecotr<int> v({1,2,3});//OK
```
swap拥有线性复杂度并有以下的影响：iterator和reference不会随着元素的置换而改变所指向的元素。所以置换后，iterator和reference指向那个原本容器，但指向不同元素。

Array的操作
---
如果使用操作符=和swap()，两个array必须具备相同的类型，意思是两者的元素类型和大小必须相同。  
想要访问array内的所有元素，必须使用range-based for循环，或者特定的操作符或迭代器。通常只有使用at()会执行范围检查。如果超出范围，at()会抛出一个out_of_range异常，其它函数不会做检查。对于一个空的array调用operator[]、front和back会导致不明确的行为。

```c++
std::array<Elem,0> c;
std::cout << c.front();//RUNTIME ERROR
```

将array当做C-Style Array
---
如果想要访问array的元素，你不一定使用表达式&a[0]，因为成员函数data()也具备相同用途：

```c++
std::array<char,41> a;
strcpy(a.data(),"hello");
printf("%s\n"，a.data());
printf("%s\n"，&a[0]);
```
但是你必须确保array的大小足够容纳复制进来的数据，而且如果你把其中的内容当做一个C-string来看，你必须放置一个’\0’元素于尾端。
注意，绝对不要用迭代器表现“第一元素的地址”。

```c++
printf("%s\n", a.begin());//ERROR
printf("%s\n", a.data());//OK
```

Tuple接口
---
Array提供tuple接口。因此可以使用tuple_size<>::value去的元素个数，用tuple_element<>::type取得某个特定元素类型，用get取得某个特定元素。例如：

```c++
typedef std::array<std::string,5> FiveStrings;
FiveStrings a = { "hello","how","are","you","hehe"};
std::tuple_size<FiveStrings>::value //5
std::tuple_element<1,FiveStrings>::type //std::string
std::get<1>(a) //std::string("how")
```
