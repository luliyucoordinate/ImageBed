---
layout: post
title: Leetcode 106：从中序与后序遍历序列构造二叉树（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-10-25 00:00:00
---

根据一棵树的中序遍历与后序遍历构造二叉树。

**注意:**
你可以假设树中没有重复的元素。

例如，给出

```
中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

**解题思路**

实际上这个问题和之前[Leetcode 105：从前序与中序遍历序列构造二叉树（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/83343535)是一样的。所以我们使用同样策略即可。

```python
class Solution:
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        if inorder:
            ind = inorder.index(postorder.pop())
            root = TreeNode(inorder[ind])
            root.right = self.buildTree(inorder[ind+1:], postorder)
            root.left = self.buildTree(inorder[:ind], postorder)           
            return root
```

注意上面写法与之前写法的区别，也就是`root.right`和`root.left`的前后位置问题。

同样的可以写出迭代版本。对于迭代的关键还是在于找根节点。我我们通过`postorder`知道`3`是整棵树的根节点，所以我们建立一个`stack`，然后将`3`加入到`stack`中。栈顶是我们每次要考虑的根节点，我们每次从后向前遍历`postorder`中的元素。我们首先考虑`20`应该放在哪？通过`postorder`我们知道`20`一定是`root右子树`的根节点，所以我们将`9`加入到`root(3).right`。

```
stack: 3 20
    3
     \
     20
```

我们接着考虑`7`应该放在哪。我们通过`postorder`知道`7`一定是`20`右子树的根节点，所以我们将`7`放在`20`的右边。

```
stack: 3 20 7
    3
     \
     20
       \
        7
```

接着寻找`7`的左右孩子，我们通过`inorder`推断出`7`没有左右孩子。所以我们将`7`出栈。

```
stack: 3 20
    3
     \
     20
       \
        7
```

我们接着考虑`15`应该放在哪。我们通过`postorder`知道`15`一定是`20`左孩子的根节点。我们将`15`入栈。

```
stack: 3 20 15 
    3
     \
     20
    /  \
   15   7
```

通过`inorder`我们知道`15`没有左右孩子，所以我们将`15`出栈。我们发现`20`的左右子树已经填满了，所以我们将`20`也出栈。

```
stack: 3
    3
     \
     20
    /  \
   15   7
```

我们接着考虑`9`应该放在哪。我们发现`3`的左边还是空的，所以我们将`9`放到`3`的左边。同时将`9`入栈

```
stack: 3 9
    3
   / \
  9  20
    /  \
   15   7
```

接着就是具体实现上的细节。

```python
class Solution:
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        if not inorder or not postorder:
            return 
        
        postorder.reverse()
        root = TreeNode(postorder[0])
        stack = [root]
        i = len(inorder) - 1

        for node in postorder[1:]:
            parent = stack[-1]
            
            if parent.val != inorder[i]:
                parent.right = TreeNode(node)
                stack.append(parent.right)     
            else:
                while stack and stack[-1].val == inorder[i]:
                    parent = stack.pop()
                    i -= 1
                parent.left = TreeNode(node)
                stack.append(parent.left)
                
        return root
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**