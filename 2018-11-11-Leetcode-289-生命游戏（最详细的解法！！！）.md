---
layout: post
title: Leetcode 289：生命游戏（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-11 00:00:00
---

根据[百度百科](https://baike.baidu.com/item/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/2926434?fr=aladdin)，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在1970年发明的细胞自动机。

给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞具有一个初始状态 *live*（1）即为活细胞， 或 *dead*（0）即为死细胞。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：

1. 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
2. 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
3. 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
4. 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；

根据当前状态，写一个函数来计算面板上细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。

**示例:**

```
输入: 
[
  [0,1,0],
  [0,0,1],
  [1,1,1],
  [0,0,0]
]
输出: 
[
  [0,0,0],
  [1,0,1],
  [0,1,1],
  [0,1,0]
]
```

**进阶:**

- 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。
- 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？

**解题思路**

类似问题

[Leetcode 73：矩阵置零（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/83303794)

这个问题非常有意思，有兴趣的同学可以将其做成可视化看看效果，我在后期会给出可视化代码示例。我们回到这个问题，这个问题非常简单，由于**细胞的出生和死亡是同时发生的**（和之前问题类似，如果遍历前面元素直接修改结果会对后面的元素造成影响），所以最简单的做法就是新建一个`matrix`。

```python
class Solution:
    def gameOfLife(self, board):
        """
        :type board: List[List[int]]
        :rtype: void Do not return anything, modify board in-place instead.
        """
        self.w, self.h = len(board[0]), len(board)
        mat = [[0]*self.w for _ in range(self.h)]
        for r in range(self.h):
            for c in range(self.w):
                mat[r][c] = board[r][c]

        for r in range(self.h):
            for c in range(self.w):
                lives = self._neighborsLives(mat, (r, c))
                if lives < 2:
                    board[r][c] = 0
                if lives > 3:
                    board[r][c] = 0
                if lives == 3 and not board[r][c]:
                    board[r][c] = 1

    def _neighborsLives(self, board, node):
        count = 0
        neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0), (-1, -1), (1, 1), (-1, 1), (1, -1)]
        for i, j in neighbors:
            if 0 <= node[0] + i < self.h and\
                0 <= node[1] + j < self.w:
                count += board[node[0]+i][node[1]+j] & 1
        return count
```

如果不是用额外空间该怎么做？我们可以通过状态转换（在之前的问题中我们已经不止一次使用这种策略了），我们知道原先通过`1bit`只能记录当前是死还是活，无法记录之前的状态，如果想要记录之前的状态，我们只有增大信息的容量，增大为多少呢？`2bit`就可以啦。

- die <- die  00
- die <- live  01
- live <- die  10
- live <- live  11

我们这里使用`2bit`表示状态变化（current to next）。我们先遍历`board`，看每个节点周围有多少个初始状态是`live`，如果这个节点原先是`live`并且周围的`2<=lives<4`，我们知道它现在的状态应该是`live->live`，也就是对应上面的编码`3`。如果这个节点原先是`die`并且周围是`lives==3`，我们知道它现在的状态应该是`die->live`，也就是对应上面的编码`2`。这些都做完之后，我们在此遍历`board`，将其中的`2`和`3`调整回来（`live or die`），怎么调呢？很简单，我们注意到我们的`2`和`3`编码很巧妙，直接`>>1`就可以得到一次游戏后的状态了。

```python
class Solution:
    def gameOfLife(self, board):
        """
        :type board: List[List[int]]
        :rtype: void Do not return anything, modify board in-place instead.
        """
        r, c = len(board), len(board[0])
        neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0), (-1, -1), (1, 1), (-1, 1), (1, -1)]
        for i in range(r):
            for j in range(c):
                lives = 0
                for m, n in neighbors:
                    if 0 <= i + m < r and 0 <= j + n < c:
                        lives += board[i+m][j+n] & 1

                if board[i][j] and 2 <= lives < 4:
                    board[i][j] = 3
                
                if not board[i][j] and lives == 3:
                    board[i][j] = 2

        for i in range(r):
            for j in range(c):
                board[i][j] >>= 1
```

要注意我们在[Leetcode 73：矩阵置零（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/83303794)问题中没有采用这种增大信息量的方式，因为我们可以对问题进行全局考虑（也就是一旦输入结果确定，我们就会知道输出结果）。而这个问题按理说应该是可以通过全局考虑的，但是很麻烦，远没有通过增大信息量来解容易。那么之前那个问题应该也可以通过增大信息量来接吧？大家可以试试。

如果矩阵无限大我们该怎么办？我们希望我们存储的信息尽可能少，所以我们可以只记录存活节点的坐标，每次更新记录存活节点坐标的数组。

```python
class Solution:
    def gameOfLife(self, board):
        """
        :type board: List[List[int]]
        :rtype: void Do not return anything, modify board in-place instead.
        """
        live = {(i, j) for i, row in enumerate(board) for j, live in enumerate(row) if live}
        live = self.gameOfLifeInfinite(live)
        for i, row in enumerate(board):
            for j in range(len(row)):
                row[j] = int((i, j) in live)
            
    def gameOfLifeInfinite(self, live):
        neighbors = collections.Counter()
        for i, j in live:
            for I in (i-1, i, i+1):
                for J in (j-1, j, j+1):
                    if I != i or J != j:
                        neighbors[I, J] += 1
        new_live = set()
        for key, val in neighbors.items():
            if val == 3 or val == 2 and key in live:
                new_live.add(key)
        return new_live
```

reference:

https://leetcode.com/problems/game-of-life/discuss/73223/Easiest-JAVA-solution-with-explanation

https://segmentfault.com/a/1190000003819277#articleHeader1

https://leetcode.com/problems/game-of-life/discuss/73217/Infinite-board-solution

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**