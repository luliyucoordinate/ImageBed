---
layout: post
title: Leetcode 1104：二叉树寻路（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-6-30 00:00:00
---

在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 **逐行** 依次按 “之” 字形进行标记。

如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；

而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/1104/tree.png" width="400">
</center>

给你树上某一个节点的标号 `label`，请你返回从根节点到该标号为 `label` 节点的路径，该路径是由途经的节点标号所组成的。 

**示例 1：**

```
输入：label = 14
输出：[1,3,4,14]
```

**示例 2：**

```
输入：label = 26
输出：[1,2,6,10,26] 
```

**提示：**

- `1 <= label <= 10^6`

**解题思路**

这个问题看上去不太好做，我们首先分析一下。首先我们知道每一层有$2^{l-1}$个节点，其中`l`表示第`l`层，每一层的起始数字是$2^{l-1}$，结束数字是$2^{l}-1$，当然这个顺序会根据奇数行和偶数行的不同出现逆向。那么对于给定数字`label`，我们一定可以知道它是第几层第几个。我们假设是`i`层`j`个，那么它的父亲节点一定是`i-1`层`j//2`个。依照这个思路，我们只需要从后向前找到每一层的节点即可。

```python
import math
class Solution:
    def pathInZigZagTree(self, label: int) -> List[int]:
        l = int(math.log(label, 2)) + 1
        index = label - 2**(l - 1)
        res = [0] * l
        
        if (l % 2) == 0:
            index = (2**(l - 1) - index - 1)
            
        for i in range(l, 0, -1):
            res[i - 1] = self.helper(i, index)
            index //= 2
        return res
        
    def helper(self, l, cur):
        t = list(range(2**(l - 1), 2**l))
        if l & 1:
            return t[cur]
        else:
            return t[(2**(l - 1) - cur - 1)]
```



```python
import math
class Solution:
    def pathInZigZagTree(self, label: int) -> List[int]:
        l = int(math.log(label, 2)) + 1
        res = [0] * l
        while label >= 1:
            res[l - 1] = label
            label = (1 << l) - 1 - label + (1 << (l - 1))
            label //= 2
            l -= 1
        return res
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**