---
layout: post
title: Leetcode 121：买卖股票的最佳时机（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-10-26 00:00:00
---

给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```

**示例 2:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**解题思路**

这个问题非常简单，我们可以通过动态规划很快速的解决这个问题。我们最多只交易一次，并且我们每天只有`buy`、`sell`两种状态。对于买来说，我们买之后可以卖出（进入卖状态），也可以不再进行股票交易（还在买状态）。对于卖来说，我们卖出股票后就不再进行股票交易了（还在卖状态）。当天买的话意味着损失`-prices[i]`，当天卖的话意味着增加`prices[i]`，当天卖出总的收益就是`buy+prices[i]`。所以我们最后只要考虑当天买和之前买哪个收益更高，当天卖和之前卖哪个收益更高。所以转移方程就是

- $buy = max(buy,-prices[i])$
- $sell = max(sell, buy+prices[i])$

我们接着要考虑边界问题，很明显一开始我们第一天`buy=-prices[0]`，而`sell=0`（相当于买入后再卖出）。最后我们只要返回`sell`即可。

```python
class Solution:
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        if not prices:
            return 0
        
        buy, sell = -prices[0], 0
        for i in prices[1:]:
            buy = max(buy, -i)
            sell = max(sell, buy + i)

        return sell
```

但是这个问题最简单的处理思路是贪心算法。我们想要在最低的价格买入，然后在最高的价格卖出。我们遍历`prices`这个数组，假设我们遍历到`i`，这个时候我们可以知道`prices[:i]`中的最小值`buy`，那么我们也会知道`prices[:i]`的最大收益（每次计算`max(prices[i]-buy)`）。

```python
class Solution:
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        result, buy = 0, float('inf')
        for price in prices:
            if buy > price:
                buy = price
            
            if result < price - buy:
                result = price - buy

        return result
```

其实这种问题的难点在于判断是不是可以通过贪心解决。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**