---
layout: post
title: Leetcode 451:根据字符出现频率排序（最详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-06-06 00:00:00
---

给定一个字符串，请将字符串里的字符按照出现的频率降序排列。

**示例 1:**

```
输入:
"tree"

输出:
"eert"

解释:
'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。
```

**示例 2:**

```
输入:
"cccaaa"

输出:
"cccaaa"

解释:
'c'和'a'都出现三次。此外，"aaaccc"也是有效的答案。
注意"cacaca"是不正确的，因为相同的字母必须放在一起。
```

**示例 3:**

```
输入:
"Aabb"

输出:
"bbAa"

解释:
此外，"bbaA"也是一个有效的答案，但"Aabb"是不正确的。
注意'A'和'a'被认为是两种不同的字符。
```

**解题思路**

我们首先想到的解题思路是通过一个`dict`存储所有字符出现的次数，然后根据字符出现的次数排序，最后输出排序结果。

```python
class Solution:
    def frequencySort(self, s):
        """
        :type s: str
        :rtype: str
        """
        str_map = {}
        for i in s:
            str_map[i] = str_map.get(i, 0) + 1 

        tmp = sorted(str_map.items(), key=lambda d:d[1], reverse=True)
        return ''.join([key*val for key, val in tmp])
```

我觉得如下这种做法更好

```python
class Solution:
    def frequencySort(self, s):
        """
        :type s: str
        :rtype: str
        """
        str_map = {}
        for i in s:
            str_map[i] = str_map.get(i, 0) + 1 

        return ''.join(sorted([i for i in s], key=lambda a: str_map[a], reverse=True))
```

我们这里给出另外一种写法。

```python
class Solution:
    def frequencySort(self, s):
        """
        :type s: str
        :rtype: str
        """
        return ''.join(c*-n for n,c in sorted((-s.count(c),c) for c in set(s)))
```

我们也可以通过一个`PriorityQueue`解决这个问题。我们首先要实现一个`ch`类，因为`PriorityQueue`插入操作的过程中会有比较操作，所以在这个类里面，我们要实现`__lt__`这个函数。

```python
from queue import PriorityQueue
class ch:
    def __init__(self, key, val):
        self.val = val
        self.key = key
    def __lt__(self, other):
        return self.val > other.val

class Solution:
    def frequencySort(self, s):
        """
        :type s: str
        :rtype: str
        """
        str_map = {}
        for i in s:
            str_map[i] = str_map.get(i, 0) + 1

        qCh = PriorityQueue()
        for key, val in str_map.items():
            if val > 0:
                c = ch(key, val)
                qCh.put(c)

        result = str()
        while not qCh.empty():
            tp = qCh.get()
            result += tp.val*tp.key
        return result
```

上面这些解法的时间复杂度都是`O(nlogn)`级别的，那么我们有没有办法优化到`O(n)`这个级别呢？我们这里有一个很巧妙的解法，利用`list`的`index`间接排序。首先还是统计`s`的元素个数，然后将元素个数作为`index`，而元素类型作为`value`存入到`list`中。

```python
from collections import defaultdict
class Solution:
    def frequencySort(self, s):
        """
        :type s: str
        :rtype: str
        """
        if not s:
            return ''

        mem, maxFre = defaultdict(int), float('-inf')
        for c in s:
            mem[c] += 1
            maxFre = max(maxFre, mem[c])

        vec = [''] * (maxFre + 1)
        for key, val in mem.items():
            vec[val] += key*val

        result = str()
        for i in vec[::-1]:
            result += i

        return result
```

很有意思的做法，实际上这种思想来自于桶排序。

该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)

**如有问题，希望大家指出！！！**