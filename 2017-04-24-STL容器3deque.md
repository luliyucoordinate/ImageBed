---
layout: post
title: STL容器（3）deque
category : cpp
tags : [cpp, notes, cpp标准库]
stickie: true
---


Deque
==
定义于头文件 <deque>

```c++
template<
    class T,
class Allocator = std::allocator<T>> 
class deque;
```

Deque的能力
---
Deque与vector相比，功能上的差异如下：  
1.  两端都可以快速插入和删除元素，而vector只可以后端。
2.  返回元素时deque内部结构会多一个间接过程，所有元素访问和迭代器的动作会慢一些。
3.  迭代器需要在不同的区块间跳转，所以必须是一个smart pointer
4.  在内存区块有限制的系统中，deque可以包含更多元素。
5.  安插和删除元素都将导致指向deque元素的pointer、reference和iterator实效。不过deque的内存分配优于vector，因为其内部结构显示，deque不必在内存充分配时复制所有元素。
6.  deque会释放不再使用的内存区块。deque的内存大小是可以缩减的。

以下情形最好使用deque：  
1.   你需要在两端安插或移除元素。
2.  无需指向容器内的元素。
3.  要求不再使用的元素必须释放。

Deque的操作函数
---
Deque的各项操作只有两点和vector不同：
1.  deque不提供容量操作（capacity和reserve）
2.  deque提供函数完成头部元素的安插和删除

Deque运用实例
---
```c++
#include <iostream>
#include <deque>
#include <string>
#include <algorithm>
#include <iterator>
using namespace std;

int main()
{
    // create empty deque of strings
    deque<string> coll;

    // insert several elements
    coll.assign (3, string("string"));
    coll.push_back ("last string");
    coll.push_front ("first string");

    // print elements separated by newlines
    copy (coll.cbegin(), coll.cend(),
          ostream_iterator<string>(cout,"\n"));
    cout << endl;

    // remove first and last element
    coll.pop_front();
    coll.pop_back();

    // insert "another" into every element but the first
    for (unsigned i=1; i<coll.size(); ++i) {
        coll[i] = "another " + coll[i];
    }

    // change size to four elements
    coll.resize (4, "resized string");

    // print elements separated by newlines
    copy (coll.cbegin(), coll.cend(),
          ostream_iterator<string>(cout,"\n"));
}
```
结果是：

```c++
first string
string
string
string
last string

string
another string
another string 
resized string
```
