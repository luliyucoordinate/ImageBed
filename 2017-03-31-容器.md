---
layout: post
title: 容器 containers
category : cpp
tags : [cpp, stl]
stickie: true
---


stl 六大部件
===

<a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe7jdem29sj20j80dl7cf.jpg" data-lightbox="roadtrip">
<img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe7jdem29sj20j80dl7cf.jpg" class="img-fluid">
</a>


容器containers
===

```c++
前闭后开区间
Begin指向第一个元素，end指向最后一个元素的下一个元素
Container<T> c;
...
Container<T>::iterator ite = c.begin();
for(; ite != c.end(); ite++)
...
Ranged-based for statement c++11
And auto keyword
for( decl : coll) 
{ statement }
std::vector<double> vec;
for( auto elem : vec )
{ std::cout << elem << std::endl; }
for( auto& elem : vec )
{ elem *= 3; }
```
<a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fe7jg3srgsj20py0cik4d.jpg" data-lightbox="roadtrip">
<img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fe7jg3srgsj20py0cik4d.jpg" class="img-fluid">
</a>


Associative containers 使用红黑树Unordered containers 哈希表separate chaining,注意对于vector 和list，forword list用其自带的排序，而对于deque使用全局的排序queue和stack内部使用了deque，而且他们的内部都不会提供iterator

<a href="http://wx1.sinaimg.cn/mw690/af2d2659gy1fe7jg42m1zj20fi0ayq3d.jpg" data-lightbox="roadtrip">
<img src="http://wx1.sinaimg.cn/mw690/af2d2659gy1fe7jg42m1zj20fi0ayq3d.jpg" class="img-fluid">
</a>


在c++11中，slist名为forward_list，hash_set，hash_map名为unordered_set，unordered_man，hash_mutiset，hash_mutimap名为unordered_mutiset，unordered_multimap



容器list
---
```c++
是一个环形双向链表
template <class T>
struct __list_node
{
	typedef void* void_pointer;
	void_pointer prev;
	void_pointer next;
	T data;
}
template <class T, class Alloc = alloc>
class list
{
protected:
	typedef __list_node<T> list_node;
public:
	typedef list_node* link_type;
	typedef __list_iterator<T, T&, T*> iterator;
protected:
	link_type node;
	...
};
template <class T, class Ref, class Ptr>
struct __list_iterator
{
	typedef __list_iterator<T, Ref, Ptr> self;
	typedef bidirectional_iterator_tag iterator_category;
	typedef T value_type;
	typedef Ptr pointer;
	typedef Ref reference;
	typedef __list_node<T>* link_type;
	typedef ptrdiff_t difference_type;

	link_type node;

	reference operator*() const { return (*node).data; }
	pointer operator->() const { return &(operator*()); }
	self &operator++() //prefix
	{ node = (link_type)((*node).next); return *this; }
	self operator++(int) //postfix
{ self tmp = *this; ++*this; return tmp; }
	...
};
```
如果iterator不是一个类的话，那他的内部就不可以使用typedef，例如指针，指针不是一个类，但指针是一种退化的iterator。所以传给算法的时候，有可能是一个指针而不是迭代器

```c++
template <typename T>
inline void 
algorithm (T first, T last)
{
	T::iterator_category;
	T::pointer;
	T::reference;
	T::value_type;
	T::difference_type;
	...
};
```
这个时候就引入了traits萃取机



Taits 特性
---

Iterator traits用以分离class iterators和non-class iterators,这个traits机器不许有分辨iterator是一个class iterator T或是一个native pointer to T

```c++
//to class
template <class T>
struct iterator_tarits
{
	typedef typename T::value_type value_type;
};
//to pointer
Partial specialization 偏特化
template <class T>
struct iterator_traits<T*>
{
	typedef T value_type;
};
template <class T>
struct iterator_traits<const T*>
{
	typedef T value_type;//这里是T不是const T
//如果是const 那他就不能被赋值，那就没有用了
};
//于是但需要知道value type，这样写
template <typename T,...>
void algorithm(...)
{
	typename iterator_taits<T>::value_type v1;
};
```


容器vector
---

如果空间不够的话，需要向操作系统寻求两倍大的空间。

```c++
template <class T, class Alloc = alloc>
class vector
{
public:
	typedef T			value_type;
	typedef value_type*	iterator;
	typedef value_type&	reference;
	typedef size_t		size_type;
protected:
	iterator start;
	iterator finish;//实际大小
	iterator end_of_storage;//理论大小
public:
	iterator begin() { return start; }
	iterator end() { return finish; }
	size_type size() const
	{ return size_type( end() - begin()); }//这样确定size永远不会改变
	size_type capacity() const
	{ return size_type( end_of_storge - begin()); }
	bool empty() const { return beign() == end(); }
	...
};

Vector’s iterator
template <class T,class Alloc = alloc>
class vector
{
public:
	typedef T value_type;
	typedef value_type *iterator;
	...
};
```
使用的是指针萃取机



容器array
---
```c++
template <typename _Tp, std::size_t _Nm>
struct array
{
	typedef _Tp			value_type;
	typedef _Tp*		pointer;
	typedef value_type*	iterator;
	
	value_type _M_instance[_Nm ? _Nm : 1 ];
	
	iterator begin()
	{ return iterator(& _M_instance[0]; }
	
	iterator end()
	{ return iterator(&_M_instance[_Nm]; }
	...
}
```

没有构造和析构  
使用必须指定大小，因为她不可扩充

```c++
array<int,10> myArray;
auto ite = myArray.begin();
ite += 3;
cout << *ite;
```
使用的是指针萃取机



容器deque
---

双向开口的空间

<a href="http://wx4.sinaimg.cn/mw690/af2d2659gy1fe7jktznx7j20qr0gn18c.jpg" data-lightbox="roadtrip">
<img src="http://wx4.sinaimg.cn/mw690/af2d2659gy1fe7jktznx7j20qr0gn18c.jpg" class="img-fluid">
</a>

每个vector里面是一个指针，内存不够的话，分配一个buf，让指针指向buf

```c++
inline size_t __deque_buf_size(size_t n, size_t sz)
{
	return n != 0 ? n : (sz < 512? size_t(512 /sz) :size_t(1);
};
template <class T, class Alloc = alloc, size_t BufSiz = 0>//如果是0使用默认设置，如果不是，使用上面的算式
class deque
{
public:
	typedef T value_type;
	typedef __deque_iterator<T, T&, T*, BufSize> iteartor;
protected:
	typedef pointer *map_pointer;
protected:
	iterator start;
	iterator finish;
	map_pointer map;
	size_type map_size;
public:
	iterator begin() { return start; }
	iterator end() { return finish; }
	size_type size() const { return finish - start; }
	...
};

deque’s iterator
template <class T, class Ref, class Ptr, size_t BufSiz>
struct __deque_iterator
{
	typedef random_access_iterator_tag iterator_category;//注意这里random
	typedef T value_type;
	typedef Ptr pointer;
	typedef Ref reference;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef T** map_pointer;
	typedef __deque_iterator self;
	
	T* cur;
	T* first;
	T* last;
	map_pointer node;
	...
};
```
Deque是如何模拟连续空间的

```c++
reference operator[](size_type n)
{
	return start[difference_type(n)];
}
reference front()
{
	return *start;
}
reference back()
{
	iterator tmp = finish;
	--tmp;
	return *tmp;
}
size_type size() const
{
	return finish - start;
}
bool empty() const
{
	return finish == start;
}
reference operator*() const
{ return *cur; }
pointer opertor->() const
{ return &(operator*()); }
difference_type
operator-(const self& x) const
{
	return difference_type(buffer_size()) * (node - x.node - 1) +
	(cur - first) + (x.last - x.cur );
}
self& operator++()
{
	++cur;
	if(cur == last)
	{	
		set_node(node + 1);
		cur = first;
	}
	return *this;
}
self operator++(int)
{
	self tmp = *this;
	++*this;
	return tmp;
}
self& operator--()
{
	if(cur == last)
	{	
		set_node(node - 1);
		cur = last;
	}
	--cur;
	return *this;
}
self operator--(int)
{
	self tmp = *this;
	--*this;
	return tmp;
}
void set_node(map_pointer new_node)
{
	node = new_node;
	first = *new_node;
	last = first + difference_type(buffer_size());
}
```


容器queue，stack
---

就是变相的deque，deque是双进双出，stack先进后出，queue先进先出  
Stack和queue都可以选择list或queue

```c++
stack<string, list<string>> c;
stack<string> c;//默认是deque
```
Stack或queue都不允许遍历，所以也就不提供iterator  
Stack可以选择vector作为底部结构，但是queue不可以  
Stack与queue都不可以使用set或map作为底部支撑



容器rb_tree
---

红黑数是平衡二叉树中的常用的一种  
平衡二叉树的特征：配列规则有利search和insert，并保持适度平衡。我们不应使用rb_tree的iterators改变元素值。变成层面并未阻绝此事。因为rb_tree即将为set和map服务，而map允许元素的data被改变，只有元素的key才是不可被改编的。Rb_tree提供两种insertion操作：insert_unique和insert_equal。前者表示节点的key一定是整个tree中独一无二的，后者便是节点的key可重复。

```c++
template <class Key, //key的类型
		  class Value,//value是data和key一起，这里指value的类型
		  class KeyOfValue, //key要怎么取出
		  class Compare, //key怎么比大小
		  class Alloc = alloc>
class rb_tree
{
protected:
	typedef __rb_tree_node<Value> rb_tree_node;
	...
public:
	typedef rb_tree_node *link_type;
	...
protected:
	size_type node_count;
	link_type header;
	Compare key_compare;
	...
};
```
用法

```c++
rb_tree<int, //key的类型
		int, //value的类型
		identity<int>, //注意这个gc下的，但是可以自己写
		less<int>
		alloc>
myTree;
template <class Arg, class Result>
struct unary_function
{
	typedef Arg argument_type;
	typedef Result result_type;
};
template <class T>
struct identity: public unary_function<T, T>
{
	const T& operator() (const T& x) const { return x; }
};
template <class Arg1, class Arg2, class Result>
struct binary_function
{
	tyepdef Arg1 first_argument_type;
	typedef Arg2 second_argument_type;
	typedef Result result_type;
};
template<class T>
struct less : public binary_function<T, T, bool>
{
	bool operator()(const T& x, const T& y) const
	{ return x < y; }
};
```
注意没有必要这样做，只是为了更加了解内部原理



容器set、mutiset
---

以rb_tree为底层结构，因此有元素自动排序特性。排序的依据是key，而set/mutiset元素的value和key合一：value就是key  
Set/mutiset提供遍历操作及iterators  
我们无法使用set/mutiset的iterators改变元素值。Set/mutiset的iterator是其底部的re_tree的const iterator，就是为了禁止user对其赋值。Set元素的key必须是独一无二的，因此insert用的rb_tree的insert_unique。Mutiset元素的key可以重复，因此insert用的是rb_tree的insert_equal

```c++
template<	class Key,
			class Compare = less<Key>,
			class Alloc = alloc>
class set
{
public:
	typedef Key key_type;
	typedef Key value_type;
	typedef Compare key_compare;
	typedef Compare value_compare;
private:
	typedef rb_tree<key_type, value_type, 
					identity<value_type>, key_compare, Alloc> rep_type;
	rep_type t;
public:
	typedef typename rep_type ::const_iterator iterator;
	...
};
```


容器map，mutimap
---

Map/mutimap以rb_tree为底层结构，因此有元素自动排序的特性，排序的依据是key  
Set/mutiset提供遍历操作及iterators  
我们无法使用map/mutimap的iterators改变元素的key但可以改变data。因此map/mutimap内部自动将user指定的keytype设为const，如此便能禁止user对元素的key赋值。map元素的key必须是独一无二的，因此insert用的rb_tree的insert_unique。mutimap元素的key可以重复，因此insert用的是rb_tree的insert_equal

```c++
template <	class Key,
			class T,
			class Compare = less<Key>,
			class Alloc = alloc>
class map
{
public:
	typedef Key key_type;
	typedef T data_type;
	typedef T mapped_type;
	typedef pair<const Key, T> value_type;//注意这里将data和key合成为value
	typedef Compare key_compare;
private:
	typedef rb_tree<key_type, value_type,
						select1st<value_type>, key_compare, Alloc> rep_type;
	rep_type t;
public:
	typedef typename rep_type::iterator iterator;
	...
};
```
在mutimap中不可以用[]做insert，必需使用insert  
在map中可以  
Allow for easy lookup with the subscript(@c[])operator.Returns data associated with the key specified subscript.If the key does not exit, a pair with that key is created using default values, which is then returned.  

```c++
mapped_type&
operator[](const key_type& __k)
{
	iterator __i = lower_bound(__k);
	if(__i == end() || key_comp()(__k, (*__i).first))
#if __cpluscplus >= 201103L
	__i = M_t....
#else 
	__i = insert(__i, value_type(__k, mapped_type()));
#endif
	return (*__i).second;
}
```
lower_bound是二分查找，在sorted[first, last)中查找元素value，找到返回一个iterator指向其中的第一个元素。如果没有这样的元素存在，他就会传回最适合按插这个key的iterator。  
但是可以从源代码中看出，使用[]后速度变慢了，调用了lower_bound



容器hashtable
---
<a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe7jku891ij20od090mxf.jpg" data-lightbox="roadtrip">
<img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe7jku891ij20od090mxf.jpg" class="img-fluid">
</a>


如果多个元素放在同一个位置就会发生碰撞，但是如果采用移动位置的方式就会降低效率，最后的方法是，每一个节点做一个链表，把碰撞的元素放入链表中，也就是separate chaining。但是这样做的话，可能会出现单一链表过长，所以就出现了buckets。  
如果按插的元素个数大于buckets个数，于是rehashing，所有的元素要重新按插，这是一件花时间的事情。buckets的数目是按照素数来的。

```c++
template <class Value, class Key, class HashFcn,//HashFcn计算hashcode
			class ExtractKey, class EqualKey,//ExtractKey取出key的方法
			class Alloc = alloc>
class hashtable
{
public:
	typedef HashFcn hasher;
	typedef EqualKey key_equal;
	typedef size_t size_type;
private:
	hasher hash;
	key_equal equals;
	ExtractKey get_key;
	
	typedef __hashtable_node<Value> node;
	vector<node*, Alloc> buckets;
	size_type num_elements;
public:
	size_type bucket_count() const { return buckets.size(); }
	...
};
template <class Value, class Key, class HashFcn,
			class ExtractKey, class EqualKey,
			class Alloc>
struct __hashtable_iterator
{
	...
	node *cur;//指向节点
	hashtable *ht;//指向buckets，这样做和前面的deque做法类似
};
template <class Value>
struct __hashtable_node
{
	__hashtable_node *next;//这个是gc的版本，在vc下面时双向链表
	Value val;
}
```
用法

```c++
hashtable<const char *,
			const char *,
			hash<const char *>,
			identity<const char *>,
			eqstr,
			alloc>
ht(50, hash<const char *>(), eqstr());
ht.insert_unique("fjds");
struct eqstr
{
	bool operator()(const char *s1,const char *s2) const
	{
		return strcmp(s1,s2) == 0;
//注意strcmp有三种返回值-1，0，1，C/C++函数，比较两个字符串，
//设这两个字符串为str1，str2，若str1==str2，则返回零；若
//str1<str2，则返回负数；若str1>str2，则返回正数。
	}
}
template <class Key > struct hash {};//泛化
_STL_TEMPLATE_NULL struct hash<char>//特化
{
	size_t operator() (char x) const { return x; }
}
```
..数值型

```c++
inline size_t __stl_hash_string(const char * s)
{
	unsigned long h = 0;
	for(; *s; ++s)
		h = h*5 + *s;
	return size_t(h);
}
__STL_TEMPLATE_NULL struct hash<char *>//特化
{
	size_t operator() (const char *s ) const { return __stl_hash_string(s); }
}
```
..字符串型但是不是c++的string  
Hash_function的目的就是希望根据元素值算出一个hash code，使得元素经hash code映射后可以得到一个唯一值放入hashtable中。

```c++
iterator find(const key_type &key)
{ 
	size_type n = bkt_num_key(key);
...
}
size_type
bkt_num_key(const key_type& key) const
{
	return bkt_num_key(key, buckets.size());
}
size_type
bkt_num(const value_type &obj) const
{
	return bkt_num_key(get_key(obj));
};
size_type
bkt_num_key(const key_type &key, size_t n) const
{
	return hash(key)%n;
}		 
size_type
bkt_num(const value_type& obj, size_t n)const
{
	return bkt_num_key(get_key(obj) n);
}

```
Before c++11   
Hash_set  
Hash_mutiset  
Hash_map  
Hash_mutimap  

Since c++11  
Unordered_set  
Unordered_multiset  
Unordered_map  
Unordered_multimap

