---
layout: post
title: Leetcode 1028：从先序遍历还原二叉树（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-4-16 00:00:00
---

我们从二叉树的根节点 `root` 开始进行深度优先搜索。

在遍历中的每个节点处，我们输出 `D` 条短划线（其中 `D` 是该节点的深度），然后输出该节点的值。（*如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。*

如果节点只有一个子节点，那么保证该子节点为左子节点。

给出遍历输出 `S`，还原树并返回其根节点 `root`。

**示例 1：**

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/1028/recover-a-tree-from-preorder-traversal.png" width="300">
</center>

```
输入："1-2--3--4-5--6--7"
输出：[1,2,5,3,4,6,7]
```

**示例 2：**

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/1028/screen-shot-2019-04-10-at-114101-pm.png" width="300">
</center>

```
输入："1-2--3---4-5--6---7"
输出：[1,2,5,3,null,6,null,4,null,7]
```

**示例 3：**

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/1028/screen-shot-2019-04-10-at-114955-pm.png" width="300">
</center>

```
输入："1-401--349---90--88"
输出：[1,401,null,349,88,90]
```

**提示：**

- 原始树中的节点数介于 `1` 和 `1000` 之间。
- 每个节点的值介于 `1` 和 `10 ^ 9` 之间。

**解题思路**

首先不难想到暴力法，先确定前两个元素，通过前两个元素确定等差数列的差`x`，然后再通过一个变量向后找差为`x`的后续部分。

```python
class Solution:
    def longestArithSeqLength(self, A: List[int]) -> int:
        res, n = 2, len(A)
        for i in range(n-2):
            for j in range(i+1, n-1):
                pre, tmp = j, 2
                d = A[j] - A[i]
                for k in range(j+1, n):
                    if A[k] - A[pre] == d:
                        tmp += 1
                        pre = k
                res = max(res, tmp)
        return res
```

这种算法的时间复杂度是`O(n^3)`，显然是非常慢的。

实际上这个问题和之前问题[Leetcode 300：最长上升子序列（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82871892)非常类似，我们可以使用动态规划来做。我们知道对于等差数列有三种情况

- 上升
- 下降
- 不变

我们可以先定义函数$f(x)$表示以$x$结尾的最长等差数列，那么对于第一种情况就会有下面式子

- $f(x)=1+f(y)\ if\ A[x]>A[y]\ and\ A[x]-A[y]=v$

解释一下这个式子，我们假设等差数列的差为$dis=v$，对于$y\in[0,x)$，存在$A[x]>A[y]$并且$A[x]-A[y]=v$，那么$f(x)=1+f(y)$。同理对于`下降`和`不变`，我们同样可以得到下面两个式子

- $f(x)=1+f(y)\ if\ A[x]<A[y]\ and\ A[y]-A[x]=v$
- $f(x)=1+f(y)\ if\ A[x]=A[y]\ and\ A[x]-A[y]=0$

其实你会发现，当我们不考虑$x$和$y$的前后顺序的时候，上面三个式子表述的是一个式子。

```python
class Solution:
    def longestArithSeqLength(self, A: List[int]) -> int:
        mem = [collections.defaultdict(int) for _ in A]
        res = 1
        for i in range(len(A)):
            for j in range(i+1, len(A)):
                v = A[j] - A[i]
                mem[j][v]=max(mem[i][v] + 1, mem[j][v])
                res = max(res, mem[j][v])
        return res + 1
```

一个更`pythonic`的写法

```python
class Solution:
    def longestArithSeqLength(self, A: List[int]) -> int:
        mem = collections.defaultdict(int)
        for i in range(len(A)):
            for j in range(i + 1, len(A)):
                v = A[j] - A[i]
                mem[v, j] = max(mem[v, j], mem[v, i] + 1)
        return max(mem.values()) + 1
```

我们将代码优化到了`O(n^2)`。

reference:

https://leetcode.com/problems/longest-arithmetic-sequence/discuss/274611/JavaC%2B%2BPython-DP

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**