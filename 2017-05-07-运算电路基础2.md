---
layout: post
title: 运算电路基础（2）
category : 计算机系统原理
tags : [notes, 原理]
stickie: true
---


C语言中的各类计算
===

C语言中涉及的运算
---
从运算符无法区分逻辑移位和算数移位，由数的类型决定。  
如果是无符号数，那么是逻辑左（右）移。具体规则是：高（低）位移出，低（高）位补0，左移可能溢出。如果左移时高位是1，就发生溢出。  
如果是带符号数，那么是算数左（右）移。具体规则如下：左移，高位移出，低位补0，可能发生溢出。如果移出的位不等于新的符号位，则发生溢出。右移，低位移出，高位补符，可能发生有效数据丢失。  
位扩展和位截断运算，没有专门操作运算符，根据类型转换前、后数据长短确定是扩展还是截断。扩展就是短转长，无符号数（前面补0），带符号数（前面补符号）。截断就是长转短，可能发生溢出。例子：

```c
short si = -32768;
unsigned short usi = si;
int i = si;
unsigned ui = usi;
```
分析结果  
si = -32768  8000  
usi = 32768  8000  
i = -32768  ffff 8000  
ui = 32768  0000 8000  
溢出的例子：  
int i = 32768  
short si = (short) i;  
int j = si;  
最后的结果是i与j不相等，j=-32768，原因是对i截断时发生溢出，超出了16位带符号数能表示的最大值。

条件标志位
---
零标志ZF、溢出标志OF、进借位标志CF、符号标志SF称为条件标志。条件标志在运算电路中产生，被记录到专门的寄存器中。存放标志的寄存器通常称为程序/状态寄存器或标志寄存器。每个标志对应标志寄存器的一个标志位。  
OF：若a与b同号但与sum不同，则1，否则0；C_n⊕C_(n-1)  
SF：sum最高位  
ZF：如sum为0，则1，否则0  
CF：cout⊕sub  
例子：  
若n=8，计算107+46=?  
107    0110 1011  
46     0010 1110  
溢出标志OF=1、零标志ZF=0、符号标志SF=1、进位标志CF=0  
作为无符号数运算的结果是未发生溢出，看CF  
作为带符号数运算的结果是发生溢出，看OF  
做减法用来比较大小，规则：  
无符号数：CF=0时，大于  
带符号数：OF=SF时，大于  
例子：

```c
unsigned int x = 134;
unsigned int y = 246;
int m = x;
int n = y;
unsigned int z1 = x-y;
unsigned int z2 = x+y;
int k1 = m-n;
int k2 = m+n;
```
x和m的机器码是一样的1000 0110，y和n的机器数一样1111 0110，z1和k1的机器数是一样的1001 0000，CF=1，OF=0，SF=1，z2和k2的机器数是一样的0111 1100，CF=1，OF=1，SF=0  
z1的值是144，是错误的值。k1的值是-112  
z2的值是124，是错误的值。k2的值是124，也是错误的值。  

判断溢出的程序
---
对于无符号数  
发生溢出时，一定满足result&lt;x  and  result&gt;y,否则，若$x+y-2^n>=x$，则$y>=2^n$，显然是错误的。

```c
int uadd_ok(unsigned x,unsigned y)
{
	unsigned sum = x + y;
	return sum >= x;
}
int usub_ok(unsigned x,unsigned y)
{
	return uadd_ok(x,-y);
}
```
对与带符号数  
带符号数的溢出包括正溢出和负溢出

```c
int tadd_ok(int x,int y)
{
	int sum = x + y;
	int neg_over = x<0 && y<0 && sum>=0;//负溢出
	int pos_over = x>=0 && y>=0 && xum<0;//正溢出
	return !neg_over && !pos_over;
}
int tsub_ok(int x,int y)
{
	return tadd_ok(x,-y);
}
```
当x=0，y=0x80000000时，判断减法函数是错误的
