---
layout: post
title: 仿函数 functors
category : cpp
tags : [cpp, stl, 仿函数]
stickie: true
---


仿函数functors
===
```c++
//算数类arithmetic
template <class T>
struct plus: public binary_function<T, T, T>
{
	T operator()( const T& x, const T& y) const 
	{ return x + y; }
};
template <class T>
struct minus: public binary_function< T, T,T>
{
	T operator() (const T& x,const T& y) const 
	{ return x - y; }
};
//逻辑运算类logical
template<class T>
struct logical_and : public binary_function <T, T, T>
{
	bool operator()(const T& x, const T& y) const 
	{ return x && y; }
};
//相对关系类relational
template <class T>
struct equal_to : public binary_function<T , T, bool>
{
	bool operator()(const T& x, const T& y) const
	{ return x == y; }
};
```
Stl的仿函数都是继承一个类
自己写的话也要这样做，才可以融入stl

```c++
template <class Arg, class Result>
struct unary_function
{
//一个操作数，如对一个东西取非
	typedef Arg argument_type;
	typedef Result result_type;
};
template <class Arg1, class Arg2, class Result>
struct binary_function
{
	typedef Arg1 first_argument_type;
	typedef Arg2 second_argument_type;
	typedef Result result_type;
};
```

Stl规定每个adaptable function都应该挑选适当的继承。这种继承没有任何的坏处，他的空间没有变大。

