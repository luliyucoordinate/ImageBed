---
layout: post
title: Leetcode 874：模拟行走机器人（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-3-6 00:00:00
---

机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令：

- `-2`：向左转 90 度
- `-1`：向右转 90 度
- `1 <= x <= 9`：向前移动 `x` 个单位长度

在网格上有一些格子被视为障碍物。

第 `i` 个障碍物位于网格点  `(obstacles[i][0], obstacles[i][1])`

如果机器人试图走到障碍物上方，那么它将停留在障碍物的前一个网格方块上，但仍然可以继续该路线的其余部分。

返回从原点到机器人的最大欧式距离的**平方**。 

**示例 1：**

```
输入: commands = [4,-1,3], obstacles = []
输出: 25
解释: 机器人将会到达 (3, 4)
```

**示例 2：**

```
输入: commands = [4,-1,4,-2,4], obstacles = [[2,4]]
输出: 65
解释: 机器人在左转走到 (1, 8) 之前将被困在 (1, 4) 处
```

**提示：**

1. `0 <= commands.length <= 10000`
2. `0 <= obstacles.length <= 10000`
3. `-30000 <= obstacle[i][0] <= 30000`
4. `-30000 <= obstacle[i][1] <= 30000`
5. 答案保证小于 `2 ^ 31`

**解题思路**

这个问题花了我很长时间。结果当我在思考**障碍物**的问题上碰到问题，我的想法是当我们每次前进一次之后，我们需要判断我们当前前进后的结果是不是超过了相同行或者列的障碍物，如果超过的话，那么我们就需要计算我们可以前进的最小值，那么我们就需要对障碍物数组检索，由于数组过大，所以我们可以先排序。每当我们行进一个有效的步长后，我们都需要记录此时前进的最大欧式距离的**平方**。

还有一种做法是我们首先将障碍物数组建立成一个集合。接着我们在每次前进的时候，采用一步一步走的策略，并且我们需要判断我们走的每一步是不是在障碍物上（通过集合查找），如果是的话，我们后面的步数就不用再走了。

最后一个问题就是我们的方位问题，最简单的思路就是建立一个数组存放`up`、`right`、`down`和`left`。然后通过一个遍历记录我们此时在那个方位上（也就是取摸`4`）。

```python
class Solution:
    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:
        d = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        tmp = res = 0
        x, y = 0, 0
        ob = set(map(tuple, obstacles))
        for i in commands:
            if i == -1:
                tmp += 1
            elif i == -2:
                tmp -= 1
            else:
                for _ in range(i):
                    x += d[tmp%4][0]
                    y += d[tmp%4][1]
                    if (x, y) in ob:
                        x -= d[tmp%4][0]
                        y -= d[tmp%4][1]
            res = max(res, x**2 + y**2)
        return res
```

再是用`cpp`的时候需要注意一个问题就是`负数取摸`，它和`python`中不同，我们可以使用一个`trick`，当`i==-2`的时候，我们采用`tmp+=3`。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**