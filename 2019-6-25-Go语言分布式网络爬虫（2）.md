---
layout: post
title: Go语言分布式网络爬虫（2）
category : go
tags : [go]
stickie: true
date: 2019-6-25 00:00:00
---

好的，我们现在又回到了开始，我们之前只是获取了不同城市的信息，而我们的目的是获取租房信息

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/Tiny-Go-Spider/lesson1/2019_6_24_4.png" width="500">
</center>

所以不难想到，我们需要编写一个功能类似于`citylist.go`的文件。我们首先查看租房金额，这个时候就有一个问题了，我们发现这个租金是通过58同城的字体转化过的，所以我们先要获取字体信息。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/Tiny-Go-Spider/lesson3/2019_6_25_2.png" width="600">
</center>

我们新建一个`font`包，用于获取字体信息

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/Tiny-Go-Spider/lesson3/2019_6_25_3.png" width="400">
</center>

```go
const fontName = "online_font.ttf"
func GetFontFile(contents []byte) {
	re := regexp.MustCompile(`base64,(.*?)\'`)
	bs4 := re.FindSubmatch(contents)

	bs4ToStr, err := base64.StdEncoding.DecodeString(string(bs4[1]))
	if err != nil {
		log.Printf("Font: error get font: %v", err)
	}

	if _, err := os.Stat(fontName); !os.IsExist(err) {
		fontFile, err := os.Create(fontName)
		defer fontFile.Close()
		if err != nil {
			log.Printf("Font: write font error: %v", err)
		}
		fontFile.Write(bs4ToStr)
	}
}
```

接着我们需要通过这个字体文件，将我们获取的文字编码转化过来。我在`go`语言的包中没有找到好用的字体处理的包，所以我使用`python`中的`fonttools`的到了下面的映射关系（至于`go`下要怎么处理，后面再想办法）

```go
	FontToUnicode := map[string]string{
		"0x9476": "5",
		"0x958f": "7",
		"0x993c": "0",
		"0x9a4b": "4",
		"0x9e3a": "9",
		"0x9ea3": "1",
		"0x9f64": "6",
		"0x9f92": "2",
		"0x9fa4": "3",
		"0x9fa5": "8",
	}
```

首先我们先要将获取的字体转化为正常的编码，我们将转化函数写到`engine.go`文件中

```go
// engine/engine.go
func Run(seeds ...Request) {
	...
	for len(requests) > 0 {
		...
        ParseHtmlWithFont(&body) //add
		...
	}
}
func ParseHtmlWithFont(contents *[]byte) {
	FontToUnicode := map[string]string{
		"0x9476": "5",
		"0x958f": "7",
		"0x993c": "0",
		"0x9a4b": "4",
		"0x9e3a": "9",
		"0x9ea3": "1",
		"0x9f64": "6",
		"0x9f92": "2",
		"0x9fa4": "3",
		"0x9fa5": "8",
	}
	for k, v := range FontToUnicode {
		t := strings.Replace(k, "0x", "&#x", -1) + ";"
		*contents = bytes.Replace(*contents, []byte(t), []byte(v), -1)
	}
	*contents = bytes.Replace(*contents, []byte("&nbsp;"), []byte(""), -1)
}
```

为了能够描述租房的情况，我们建立一个数据结构用来存放租房信息，为此我们需要新建立一个包`model`，然后建立文件`profile.go`

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/Tiny-Go-Spider/lesson3/2019_6_25_4.png" width="300">
</center>

```go
//model/profile.go
type Profile struct {
    Name string				//房源名称
	Rent int 				//租金
	RentalMethod string 	//租赁方式
	PropertyType string 	//房屋类型
	ImageUrl string			//图片地址
	Floor string 			//楼层
	Oriented string 		//朝向
	Address string 			//地址
	Community string 		//小区
	PropertyCompany string 	//物业公司
	PropertyCosts string 	//物业费
}
```

接着我们在`58/parser`目录下新建一个`profile.go`文件用于处理这些信息，主要是通过一系列的正则表达式解析内容

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/Tiny-Go-Spider/lesson3/2019_6_25_1.png" width="300">
</center>

```go
// 58/parser/profile.go
var rentRe = regexp.MustCompile(`<span class="c_ff552e">[^>]*>(\d*)`)
...
func ParseProfile(contents []byte, name string) engine.ParseResult {
	ParseHtmlWithFont(&contents)

	profile := model.Profile{}
	profile.Name = name
	rent, err := strconv.Atoi(extractString(contents, rentRe))
	if err == nil {
		profile.Rent = rent
	}

	profile.RentalMethod = extractString(contents, rentalMethodRe)
	...

	result := engine.ParseResult{
		Items: []interface{}{profile},
	}
	return result
}

func extractString(contents []byte, re *regexp.Regexp) string {
	match := re.FindSubmatch(contents)
	if len(match) >= 2 {
		return string(match[1])
	} else {
		return ""
	}
}
```

接着我们需要获取该城市有哪些服务

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/Tiny-Go-Spider/lesson1/2019_6_24_2.png" width="600">
</center>

这里为了简单处理，我们只获取租房服务。我们在`parser`目录下新建一个`city.go`文件

```go
// 58/parser/city.go
var localRe = regexp.MustCompile(`locallist:.*listname: '([^']*)'}`)
var rentHouseRe = regexp.MustCompile(`<a href="([^"]*)"[^>]*>租房</a>`)

func ParseCity(contents []byte) engine.ParseResult {
	result := engine.ParseResult{}
	local := localRe.FindSubmatch(contents)
	rent := rentHouseRe.FindSubmatch(contents)
	parseCityUrl := "https://" + string(local[1]) + ".58.com" + string(rent[1])
	result.Items = append(result.Items, string(rent[1]))
	result.Requests = append(result.Requests, engine.Request{
		Url: parseCityUrl,
		ParserFunc: ParseRentHouse,
	})
	return result
}
```

接着我们需要编写服务去遍历租房列表

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/Tiny-Go-Spider/lesson1/2019_6_24_3.png" width="600">
</center>

我们在`parser`目录下新建一个`renthouse.go`文件

```go
var rentHouseListRe = regexp.MustCompile(`<div class="des">[^=]*="([^"]*)"[^>]*>([^<]*)`)
func ParseRentHouse(contents []byte) engine.ParseResult {
	result := engine.ParseResult{}
	matches := rentHouseListRe.FindAllSubmatch(contents, -1)
	for _, m := range matches {
		str := strings.Replace(string(m[2]), " ", "", -1)
		str = strings.Replace(str, "\n", "", -1)
		result.Items = append(result.Items, str)
		result.Requests = append(result.Requests, engine.Request{
			Url:        string(m[1]),
			ParserFunc: engine.NilParser,
		})
	}
	return result
}
```

好的，让我们看一下我们的成果吧^_^

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/Tiny-Go-Spider/lesson3/2019_6_25_5.png" width="600">
</center>

至此我们这一小节的内容完成，我们提交代码到`github`。但是这里还有一个小`bug`，还记得我通过`python`的包`fonttools`获取的字典表吗？在实际测试中，我发现这个字典是不断变换的，也就是说我们需要动态获取这个字典。那么如果通过`go`去动态获得这个字典，我暂时还没有好的办法。(⊙﹏⊙)b

**如果你觉得上述过程对你有一点困难，没关系，可以查看我的[Tiny-Go-Crawler lesson3](https://github.com/luliyucoordinate/Tiny-Go-Crawler/tree/master/lesson3)代码。**

**如有问题，希望大家指出！！！**