---
layout: post
title: Leetcode 1013：将数组分成和相等的三个部分（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-3-24 00:00:00
---

给定一个整数数组 `A`，只有我们可以将其划分为三个和相等的非空部分时才返回 `true`，否则返回 `false`。

形式上，如果我们可以找出索引 `i+1 < j` 且满足 `(A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1])` 就可以将数组三等分。

**示例 1：**

```
输出：[0,2,1,-6,6,-7,9,1,2,0,1]
输出：true
解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1
```

**示例 2：**

```
输入：[0,2,1,-6,6,7,9,-1,2,0,1]
输出：false
```

**示例 3：**

```
输入：[3,3,6,5,-2,2,5,1,-9,4]
输出：true
解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4 
```

**提示：**

1. `3 <= A.length <= 50000`
2. `-10000 <= A[i] <= 10000`

**解题思路**

这个问题非常简单，我们首先计算`sum(A)%3==0`，如果不是的话，自然就不能拆分为`3`份。然后接着判断是不是有`3`份`small//3`即可。

```python
class Solution:
    def canThreePartsEqualSum(self, A: List[int]) -> bool:
        n = len(A)
        total = sum(A)
        if total%3 != 0:
            return False
        
        p = total//3
        tmp, t = 0, 0
        for i in range(n):
            tmp += A[i]
            if tmp == p:
                t = i
                break
        tmp = 0
        for j in range(t+1, n):
            tmp += A[j]
            if tmp == p:
                return sum(A[j+1:]) == p
        return False
```

更加简洁的写法

```python
class Solution:
    def canThreePartsEqualSum(self, A: List[int]) -> bool:
        total, n = sum(A), len(A)
        if total%3 != 0:
            return False
        
        p = total//3
        tmp, t, res = 0, 0, 0
        for i in range(n):
            tmp += A[i]
            if tmp == p:
                tmp = 0
                res += 1
        return res >= 3
```

注意我们最后需要判断`res>=3`，为什么会出现`>3`呢？对于这个例子`[1, -1, 1, -1, 1, -1, 1, -1]`。

reference:

https://leetcode.com/problems/partition-array-into-three-parts-with-equal-sum/discuss/260885/C%2B%2B-6-lines-O(n)-target-sum

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**