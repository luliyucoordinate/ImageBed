---
layout: post
title: Leetcode 988：从叶结点开始的最小字符串（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-2-7 00:00:00
---

给定一颗根结点为 `root` 的二叉树，书中的每个结点都有一个从 `0` 到 `25` 的值，分别代表字母 `'a'` 到 `'z'`：值 `0` 代表 `'a'`，值 `1` 代表 `'b'`，依此类推。

找出按字典序最小的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束。

*（小贴士：字符串中任何较短的前缀在字典序上都是较小的：例如，在字典序上 "ab" 比 "aba" 要小。叶结点是指没有子结点的结点。）*

**示例 1：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2019/01/30/tree1.png" width=200" >
</center>

```
输入：[0,1,2,3,4,3,4]
输出："dba"
```

**示例 2：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2019/01/30/tree2.png" width=200" >
</center>

```
输入：[25,1,3,1,3,0,2]
输出："adz"
```

**示例 3：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2019/02/01/tree3.png" width=200" >
</center>

```
输入：[2,2,1,null,1,0,null,0]
输出："abc"
```

**提示：**

1. 给定树的结点数介于 `1` 和 `1000` 之间。
2. 树中的每个结点都有一个介于 `0` 和 `25` 之间的值。

**解题思路**

这个问题非常简单，直接使用`DFS`即可。我们通过建立一个全局的`res`，深度遍历树的过程中，每当遍历到叶子节点的时候我们都和`res`的结果进行比较。叶子节点也非常容易确定，只需哟判断`node.left and node.right`是不是空即可。

```python
class Solution:
    def smallestFromLeaf(self, root: 'TreeNode') -> 'str':
        self.res = "~"
        self.dfs(root, "")
        return self.res
        
    def dfs(self, root, path):
        if not root:
            return 
        
        path = chr(root.val + 97) + path
        if not root.left and not root.right:
            self.res = min(self.res, path)
        
        self.dfs(root.left, path)
        self.dfs(root.right, path)
```

这里使用了一个`trick`，使用`~`表示比`z`大的字符串。这个问题还有一个更加简洁的解法，就是直接使用递归的方法，如果`node.left and node.right`都为空，那么我们返回`node.val`对应的字符串即可（此时`node`是叶子节点），否则的话我们返回`min(f(node.left)+s, f(node.right)+s)`即可。

```python
class Solution:
    def smallestFromLeaf(self, root: 'TreeNode') -> 'str':
        s = chr(root.val + 97)
        if not root.left and not root.right:
            return s
        elif not root.left:
            return self.smallestFromLeaf(root.right) + s
        elif not root.right:
            return self.smallestFromLeaf(root.left) + s
        return min(self.smallestFromLeaf(root.left) + s, self.smallestFromLeaf(root.right) + s)
```

我们还可以继续简化这个代码，我们可以将只有一个孩子的情况归类到所有**非叶子节点的情况**中。那么此时我们就需要考虑`node==None`的时候（也就是只有一个孩子的时候）。此时返回什么呢？这里有一个`trick`，就是返回`~`（一个比`z`大的字符都可）。

```python
class Solution:
    def smallestFromLeaf(self, root: 'TreeNode') -> 'str':
        if not root:
            return "~"
        s = chr(root.val + 97)
        return s if root.left == root.right else min(self.smallestFromLeaf(root.left)\
                                                     + s, self.smallestFromLeaf(root.right) + s)
```

reference:

https://leetcode.com/problems/smallest-string-starting-from-leaf/discuss/231102/C%2B%2B-3-lines

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**