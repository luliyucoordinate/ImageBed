---
layout: post
title: Leetcode 116：填充同一层的兄弟节点（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-12-27 00:00:00
---

给定一个二叉树

```cpp
struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

**说明:**

- 你只能使用额外常数空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。
- 你可以假设它是一个完美二叉树（即所有叶子节点都在同一层，每个父节点都有两个子节点）。

**示例:**

给定完美二叉树，

```
     1
   /  \
  2    3
 / \  / \
4  5  6  7
```

调用你的函数后，该完美二叉树变为：

```
     1 -> NULL
   /  \
  2 -> 3 -> NULL
 / \  / \
4->5->6->7 -> NULL
```

**解题思路**

首先想到的解法是通过层序遍历，可以参考这篇[Leetcode 102:二叉树的层次遍历（最详细解决方案！！！）](https://blog.csdn.net/qq_17550379/article/details/80824320)

我们可以现将`root`和`None`加入队列，

```python
queue: root None
```

然后将队首元素弹出，首先判断一下`左右孩子`是不是空，将非空的孩子加入队列。

```python
queue: None root.left root.right
```

此时我们发现队首元素为`None`，但是队列不为空，所以我们再加入一个`None`。

```python
queue: root.left root.right None
```

通过上述这种操作，我们就可以将每行的结尾确定，然后我们只要判断当前出队元素`cur`是不是空，如果不是的话，我们就将之前出队的元素`pre.next=cur`。

```python
class Solution:
    # @param root, a tree link node
    # @return nothing
    def connect(self, root):
        if not root:
            return 
        
        q = [root, None]
        while q:
            node = q.pop(0)
            if node:
                node.next = q[0]
                if node.left:
                    q.append(node.left)
                    
                if node.right:
                    q.append(node.right)
            else:
                if q:
                    q.append(None)
```

这个问题可以不用队列来做。我们可以将每一行的第一个元素当成起点，假设我们考虑当前元素`cur`

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/116/2018_12_27_1.png" width="200" hegiht="150">
</center>

如果`cur.left`不为空，那么我们令`cur.left.next=cur.right`。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/116/2018_12_27_2.png" width="200" hegiht="150">
</center>

如果`cur.right`和`cur.next`都不为空，那么我们令`cur.right.next = cur.next.left`。然后`cur=cur.next`，进行下一波。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/116/2018_12_27_4.png" width="200" hegiht="150">
</center>

代码如下。

```python
class Solution:
    # @param root, a tree link node
    # @return nothing
    def connect(self, root):
        node = root
        while node:
            cur = node
            while cur:
                if cur.left:
                    cur.left.next = cur.right
                    
                if cur.right and cur.next:
                    cur.right.next = cur.next.left
                    
                cur = cur.next
            
            node = node.left
```

一个更好的写法。

```python
class Solution:
    # @param root, a tree link node
    # @return nothing
    def connect(self, root):
        while root and root.left:
            node = root.left
            while root:
                root.left.next = root.right
                root.right.next = root.next and root.next.left
                root = root.next
            root = node
```

基于同样的思路，我们可以快速写出递归的方案。

```python
class Solution:
    # @param root, a tree link node
    # @return nothing
    def connect(self, root):
        if not root:
            return 
        
        if root.left:
            root.left.next = root.right
            
        if root.right and root.next:
            root.right.next = root.next.left
            
        self.connect(root.left)
        self.connect(root.right)           
```

reference:

https://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/37472/A-simple-accepted-solution

https://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/37484/7-lines-iterative-real-O(1)-space

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**