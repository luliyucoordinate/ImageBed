---
layout: post
title: cpp2.0新特性(2)
category : cpp
tags : [cpp, cpp第二版]
stickie: true
---


decltype
===

Declval converts any type T to a reference type, making it possible to use member functions in decltype expressions without the need to go through constructors.  
Decltype allows the compiler to infer the return type of a function based on an arbitrary expression and makes perfect forwarding more generic.In past versions,for two arbitrary T1 and T2,there was no way to deduce the type of an expression used these two types.The decltype feature allows you to state, for example, an expression that has template arguments,such as sum<T1,T2>() has the type T1+T2.
By using the new decltype keyword,you can let the complier find out the type of an expression.This is the realization of the often requested typeof feature.However,the existing typeof implementations were inconsistent and incomplete,so C++11 introduced a new keyword.For example:

```c++
map<string,float> coll;
decltype(coll)::value_type elem;
```
One application of decltype is to **declare return types**.Another is to use it **in metaprogramming** or to **pass the type of a lambda**.


Used to declare return types
---
Sometimes,the return type of a function depends on an expression processed with the arguments.However,something like

```c++
template<typename T1, typename T2>
decltype(x+y)add(T1 x,T2 y);
```
was not possible before C++11,because the return expression uses objects not introduced or in scope yet.But with C++11,you can alternatively declare the return type of a function behind the parameter list: 

```c++
template<typename T1,typename T2>
auto add(T1 x,T2 y)->decltype(x+y);
```
This uses the same syntax as for lambdas to declare return types.


In metaprogramming
---

```c++
template<typename T>
void test_decltype(T obj)
{
	map<string, float>::value_type elem;
	map<string, float> coll;
	decltype(coll)::value_type elem2;

	typedef typename decltype(obj)::iterator iType;
	//typedef typename T::iterator iType;

	decltype(obj) anotherObj(obj);
}
```


Pass the type of a lambda
---

```c++
auto cmp =[](const Person& p1,const Person& p2){
	return p1.lastname()<p2.lastname()||
			(p1.lastname() == p2.lastname()&&
			p1.lastname() < p2.lastname());
};
std::set<Person,decltype(cmp)> coll(cmp);
```
对于lambda，我们手上往往只有object，没有type。这是可以使用decltype  
Because you need the type of the lambda for the declaration of the set,decltype must be used ,which yields the type of a lambda object,such as cmp.Note that you also have to pass the lambda object to the constructor of coll;otherwise,coll would call the default constructor for the sorting criterion passed ,and by rule lambdas have no default constructor and no assignment operator.So,for a sorting criterion,a class defining the function objects might still be more intuitive.


Lambdas
===

C++11 introduced lambdas,allowing the definition of inline functionality,which can used as a parameter or a local object.Lambdas change the way the C++ standard library is used.  
A lambda is a definition of functionality that can be defined inside statements and expressions.Thus,you can use a lambdas as an inline function.The minimal lambda function has no parameters and simply does something;

```c++
[]{
	std::cout << "hello lambda" << std::endl;
};
```
You can call it directly:

```c++
[]{
	std::cout << "hello lambda" << std::endl;
}();
```
or pass it to objects to get called:

```c++
Auto l = []{
	std::cout << "hello lambda" << std::endl;
};
l();
```
you can specify a capture to access data of outer scope that is not passed as an argument:  
[=]means that the outer scope is passed to the lambda by value.  
[&]means that the outer scope is passed to the lambda by reference.  
Ex:

```c++
int x = 0;
int y = 41;
auto q = [x,&y] {...};
```
[=,&y]to pass y by reference and all other objects by value.  
Objects are passed by value,but inside the function object defined by the lambda,you have write access to the passed value.

```c++
int id = 0;
auto f = [id]() mutable{
	std::cout << "id:" << id << std::endl;
	++id;//如果没有写mutable，这个还有效吗?
};
id = 42;
f();f();f();
std::cout << if <<std::endl;
```
the type of a lambda is an anonymous function object(or functor)

```c++
class Functor
{
public:
	void operator()()
	{
		std::cout << "id:" << id <<std::endl;
		++id;
	}
private:
	int id;
};
Functor f;
```


pass by value
---

```c++
int id = 0;
auto f = [id]() mutable{
	std::cout << "id:" << id << std::endl;
	++id;
};
id = 42;
f();f();f();
std::cout << if <<std::endl;
```
结果是：

```c++
id:0
id:1
id:2
42
```


pass by reference
---
```c++
int id = 0;
auto f = [&id]() mutable{
	std::cout << "id:" << id << std::endl;
	++id;
};
id = 42;
f();f();f();
std::cout << if <<std::endl;
```
结果是：

```c++
id:42
id:43
id:44
45
```


No mutable
---
```c++
int id = 0;
auto f = [id]() {
    std::cout << "id:" << id << std::endl;
    ++id;//ERROR
};
id = 42;
f();f();f();
std::cout << if <<std::endl;
```
结果是：  
ERROR increment of read-only variable ‘id’


可以申明变量，可以返回变量
---

```c++
auto f = [id]()mutable{
	static int x = 5;
	int y = 6;
	return id;
};
```


再看Variadic Template
===


重写printf()
---
```c++
template<typename T,typename... Args>
void printf(const char* s,T value,Args... args)
{
	while(*s)
	{
		if(*s == '%' && *(++s) != '%')
		{
			std::cout << value;
			printf(++s, args...);
			return;
		}
		std::cout << *s++;
	}
	throw std::logic_error("extra arguments provided to printf");
}
void printf(const char *s)
{
	while(*s)
	{
		if(*s == '%'&&*(++s) != '%')
			throw std::runtime_error("invaild format string: missing arguments");
		std::cout << *s++;
	}
}
```


实现max接受任意个数
---

若参数type都一样，就无需调用variadic templates,使用initializer_list<T>就足够了。

```c++
template<typename _ForwardIterator,
		typename _Compare>
_ForwardIterator
__max_element(_ForwardIterator __first,
				_ForwardIterator __last,
				_Compare _comp)
{
	if(__first == __last) return __first;
	_ForwardIterator __result = __first;
	while(++__first != __last)
		if(__comp(__result, __first))
			__result = __first;
	return __result;
}
template<typename _ForwardIterator>
inline _ForwardIterator
max_element(_ForwardIterator __first,
			_ForwardIterator __last)
{
	return __max_element(__first,__last,
						__iter_less_iter());
}	
template<typename _Tp>
inline _Tp
max(initializer_list<_Tp> __l)
{
	return *max_element(_l.begin(),__l.end());
}
inline _Iter_less_iter 
__iter_less_iter()
{
	return _Iter_less_iter();
}
struct _Iter_less_iter
{
	template<typename _Iterator1,typename _Iterator2>
	bool 
	operator()(_Iterator1 __it1,_Iterator2 __it2) const 
	{
		return *__it1 < *__it2;
	}
};
```


若参数type不同的话，使用variadic templates
---
```c++
int mymax(int n)
{ return n; }
template <typename... Args>
int mymax(int n, Args... args)
{
	return std::max(n, mymax(args...));
}
```


处理first和last元素
---
```c++
template<typename... Args>
ostream& operator<<(ostream& os, const tuple<Args...>& t)
{
	os << "[";
	PRINT_TUPLE<0,sizeof...(Args),Args...>::print(os,t);
	return os << "]";
}
template<int IDX,int MAX, typename... Args>
struct PRINT_TUPLE
{
	static void print (ostream& os,const tuple <Args...>& t)
	{
		os << get<IDX>(t) << (IDX + 1==MAX?"":",");
		PRINT_TUPLE<IDX+1, MAX, Args...>::print(os, t);
	}
};
template<int MAX, typename...Args>
struct PRINT_TUPLE<MAX, MAX, Args...>
{
	static void print (std::ostream& os, const tuple<Args...>& t)
	{}
};
```
测试：

```c++
cout << make_tuple(7.5, string("hello"),bitset<16>(377), 42);
```
结果：

```c++
[7.5,hello,0000000101111001,42]	
```


递归继承recursive inheritance
---

参看[第一讲](http://www.coordinate.wang/cpp/2017/04/13/cpp2.0%E6%96%B0%E7%89%B9%E6%80%A71.html#variadic-templates)
但是里面有一行在这里就要变为

```c++
typename Head::type head() { return m_head;} 
Head head() { return m_head; }//至此这就完美了
```


递归复合recursive composition
---
```c++
template <typename... values> class tuple;
template <> class tuple<> {};//结束边界
template<typename Head,typename... Tail>
class tuple <Head, Tail...>
	:private tuple <Tail...>
{
	typedef tuple <Tail...> inherited;
public:
	tuple() {}
	tuple(Head v, Tail... vtail)
		:m_head(v), m_tail(vtail...) {}
	typename Head::type head() { return m_head; }
	inherited& tail() { return m_tail; }
protected:]
    inherited m_tail;
	Head m_head;
};
```
