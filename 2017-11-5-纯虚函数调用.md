---
layout: post
title: 纯虚函数的调用
category : cpp
tags : [cpp]
---

看到这个标题的时候你可能会惊讶？纯虚函数怎么可以调用呢？看下面这个例子

```c++
class Abstract_base
{
public:
	virtual ~Abstract_base();
	virtual void interface() = 0;
	const char* mumble() const { return _mumble; }
protected:
	char *_mumble;
};
class Concrete_derived :public Abstract_base
{
public:
	void Concrete_deriverd() {};
	virtual void interface();
};
inline void Abstract_base::interface()
{
    function
      //...
}
inline void Concrete_derived::interface()
{
    Abstract_base::interface();//静态调用
}
```

不过只可以通过静态调用，不可以通过虚拟机制去调用。为什么不可以？如果这样做

```c++
Concrete_derived *p = new Abstract_base;//错误，Abstract_Base是一个抽象数据类，不允许构造一个对象
p->interface();
```

你似乎会觉得这没什么！那我接着加大难度

```c++
class Base
{
public:
    Base(){}
    void callFunc();
    virtual ~Base(){};
private:
    virtual void Func() = 0;
};
class Derived:public Base
{
public:
    Derived(){}
private:
    virtual void Func();
};
void Base::Func()
{
  	std::cout << "func in Base!" << std::endl;
}
void Base::callFunc()
{
  	Func();
  	Base::Func();//静态调用纯虚函数
}
void Derived::Func()
{
  	std::cout << "func in Derived!" << std::endl;
}
int main()
{
	Base *pd = new Derived;
	pd->callFunc();
	delete pd;
	system("pause");
}
```

结果是

```c++
func in Derived!
func in Base!
```

你这个时候是不是很困惑？`Base`中的`callFunc`函数分别调用了在`Base`中定义的纯虚函数版本和`Derived`中的实现版本。为什么？`Base`中的`callFunc`函数调用了`Derived`中的**私有虚函数**！它竟然绕过了访问控制机制！为什么？

我们慢慢开始，首先我们知道这里`pd`没有发生动态绑定，因为调用的不是虚函数，这里我们可以明确`pd`调用的是`Base::callFunc()`接着进入`Base::callFunc()`内部。第一个函数`Func()`，这里我们会疑惑，到底是`Base::Func()`还是`Derived::Func()`？这时你可能很快地回答我`Base::Func()`。因为我在 [关于重载、隐藏、重写的一些思考（1）](http://blog.csdn.net/qq_17550379/article/details/78436845) 中谈过类继承里面的作用域问题。此时你坚信这是在`Base`的作用域里面，难道调用的不是`Base::Func()`？但是你要注意的是，我在  [关于重载、隐藏、重写的一些思考（2）](http://blog.csdn.net/qq_17550379/article/details/78436873)中的最后提出了一个观点，就是说virtual函数是存放在虚函数表里面的，虚函数表的空间是类外面的（类通过一个指针指向虚函数表），也就是说虚函数并不在我们的作用域里面。好的，知道了这一点问题就好解决了。

首先，要确定一点是，`Func()`是一个虚函数，它会是一种动态绑定。也就是说这里的`Func` 是根据运行期来决定的。这个时候`pd`实际上是一个`Derived`类型的首地址（Derived虚函数表的地址），自然地会找到`Derived::Func()`，再次强调这个过程是**动态调用**，接着我们使用**静态调用**去访问`Base::Func()`。ok，问题解决了一大半。为什么可以调用`Derived`的私有函数这里也很好理解了。因为这个函数是在虚函数表里面的，而虚函数表中没有私有这个概念，自然就可以了。

好的，接着我们会想为什么会有这么奇怪的做法呢？这其实是一种**`Template Method`设计模式**。

另外还有一个问题，细心的同学会发现，第一个例子是一个抽象类，但是它里面有一个保护成员`char *_mumble` ，问什么会有这样的做法？我们该怎么初始化这个数据？请看纯虚函数中的数据

