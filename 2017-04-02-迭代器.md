---
layout: post
title: 迭代器 iterators
category : cpp
tags : [cpp, stl, 迭代器]
stickie: true
---



迭代器的种类
===
```c++
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forword_iterator_tag :public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};
```
<a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe86or2fp8j20cg06z77f.jpg" data-lightbox="roadtrip">
<img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe86or2fp8j20cg06z77f.jpg" class="img-fluid">
</a>


迭代器对算法的影响
===
```c++
template<class InputIterator>
inline iterator_traits<InputIteartor>::difference_type
__distance(InputIterator first, InputIterator last,
			input_iterator_tag)
{
	iterator_traits<InputIterator>::difference_type n = 0;
	while(fisrt != last)
	{
		++first; ++n; ///数据量一大的话,这样效率会很低.
	}
	return n;
}
template<class RandomAccessIterator>
inline iterator_traits<RandomAccessIterator>::difference_type
__distance(RandomAccessIterator first, RandomAccessIterator last,
			random_access_iterator_tag)
{
	return last - first;
}
template<class InputIterator>
inline iterator_traits<InputIterator>::difference_type
distance(InputIterator first, InputIterator last)
{
	typedef typename 
//取出迭代器的分类
	iterator_traits<InputIterator>;:iterator_category category;
	return __distance(first, last, category());
}
```
注意这里虽然只写了两种，但是由于前面图例的继承关系,所以是可以的


<a href="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe86orfcg2j20kv0c6wli.jpg" data-lightbox="roadtrip">
<img src="http://wx3.sinaimg.cn/mw690/af2d2659gy1fe86orfcg2j20kv0c6wli.jpg" class="img-fluid">
</a>

```c++
temlplate<class FI>
inline void 
destory(FI first, FI last)
{
	__destory(first, last, value_type(first));
}
template<class T>
inline void 
destory(T* pointer)
{ pointer->~T(); }
template<class Itr>
inline typename iterator_traits<Itr>::value_type*
value_type(const Itr&)
{
	return static_cast
	<typename iterator_traits<Itr>::valur_type*>(0);
}
inline void destory(char *,char *){}
inline void destory(wchar *,wchar *){}
template <class FI>
inline void 
__destory_aux(FI, FI,__true_type){}
template <class FI>
inline void 
__destory__aux(FI first,FI last, __false_type)
{
	for(; first <last; ++first)
		destory(&*first);
}
template<class FI,class T>
inline void __destory(FI first, FI last, T*)
{
	typedef typename 
	__type_traits<T>::has_trivial_destructor trivial_destructor;
	__destory_aux(first,last, trivial_destructor());
}
```
算法源码中对于迭代器的分类的暗示，没有强制要求

```c++
template <class InputIterator>
inline iterator_traits<InputIterator>::difference_type
distance (InputIterator first, InputIterator last)
{
	typedef typename
	iterator_traits<InputIterator>::iterator_category category;
	return __distance(first, last, category());
}
template <class RandomAccessIterator>
inline void sort(RandomAccessIterator first,
				RandomAccessIterator last)
{
	if(first != last)
	{
		__introsort_loop(first, last, value_type(first), __lg(last-first) * 2);
		__final_insertion_sort(first, last);
	}
}
```


关于reverse iterator，rbegin()，rend
===

<a href="http://wx2.sinaimg.cn/mw690/af2d2659gy1fe86orzxi6j20hi0gbqay.jpg" data-lightbox="roadtrip">
<img src="http://wx2.sinaimg.cn/mw690/af2d2659gy1fe86orzxi6j20hi0gbqay.jpg" class="img-fluid">
</a>

```c++
reverse_iterator
rbegin()
{ return reverse_iterator(end()); }//用了iterator adapter
reverse_iterator
rend()
{ return reverse_iterator(begin()); }
```
