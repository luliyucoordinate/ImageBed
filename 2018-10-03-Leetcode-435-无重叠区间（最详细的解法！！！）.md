---
layout: post
title: Leetcode 435：无重叠区间（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-10-02 00:00:00
---

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

**注意:**

1. 可以认为区间的终点总是大于它的起点。
2. 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

**示例 1:**

```
输入: [ [1,2], [2,3], [3,4], [1,3] ]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

**示例 2:**

```
输入: [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```

**示例 3:**

```
输入: [ [1,2], [2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```

**解题思路**

我们首先想到的是暴力破解，怎么做呢？我们只需要将所有的子数组的排列都取出来，然后判断每种排列是不是符合条件即可。但是这种想法首先就被`pass`，这样子做太慢了，而且判断每个子排列是不是符合条件是一个很复杂的问题。

实际上这个问题和之前做过的[Leetcode 300：最长上升子序列（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82871892) 很类似，而且上述的思想也是差不多的。所以我们可以尝试通过动态规划的方法解决这个问题。我们定义函数`f(i)`，表示计算`[0,i]`这个区间内的最大不重叠区间数，那么我们的`f(i)`由`i`之前的`max(f(j)) (j < index)`决定，并且对于每个`j`元素都要满足`intervals[i].start >= intervals[j].end`。我们就得到了下面这个方程

- `f(i)=max(f(j) if intervals[i].start >= intervals[j].end) + 1 (j < i)`

我们通过这个方程可以很快写出下面这个代码

```python
class Solution:
    def eraseOverlapIntervals(self, intervals):
        """
        :type intervals: List[Interval]
        :rtype: int
        """
        if not intervals:
            return 0

        intervals.sort(key=lambda x:x.start)
        len_inter = len(intervals)
        mem = [1]*len_inter
        result = 1

        for i in range(1, len_inter):
            for j in range(0, i):
                if intervals[i].start >= intervals[j].end:
                    mem[i] = max(mem[i], 1 + mem[j])

            result = max(result, mem[i])

        return len_inter - result
```

实际上这个问题，我们可以通过贪心算法来解决。我们首先将输入的`intervals`按照`end`排序，然后保证我们每次放入区间的`end`最小，也就是对于后面要加入的区间留有更多的余地。

```python
class Solution:
    def eraseOverlapIntervals(self, intervals):
        """
        :type intervals: List[Interval]
        :rtype: int
        """
        if not intervals:
            return 0

        intervals.sort(key=lambda x:x.end)
        len_inter = len(intervals)
        result, pre = 1, 0
        for i in range(1, len_ter):
            if intervals[i].start >= intervals[pre].end:
                result += 1
                pre = i

        return len_inter - result
```

实际上我们还可以反过来思考这个问题，我们将`intervals`按照`start`排序，然后遍历`intervals`，通过当前遍历的元素`cur.start`和之前遍历的元素`prev.end`比较，如果`prev.end > cur.start`，那么显然`cur`区间不能放入，所以我们将`result++`，并且如果`cur`区间完全被`prev`包住，也就是`cur.end < prev.end`，那么我们希望我们之前的区间中应该包括的是`cur`这个区间而不是`prev`，因为这样做我们可以为后面的区间留有更多的余地。

```python
class Solution:
    def eraseOverlapIntervals(self, intervals):
        """
        :type intervals: List[Interval]
        :rtype: int
        """
        intervals.sort(key=lambda x: x.start) 
        result = 0
        prev = None
        for cur in intervals:
            if not prev and prev.end > cur.start:
                result += 1
                if cur.end < prev.end:
                    prev = cur
            else:
                prev = cur
        return result
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**