---
layout: post
title: Leetcode 941：有效的山脉数组（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-11-19 00:00:00
---

给定一个整数数组 `A`，如果它是有效的山脉数组就返回 `true`，否则返回 `false`。

让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：

- `A.length >= 3`
- 在 `0 < i < A.length - 1`条件下，存在`i`使得：
  - `A[0] < A[1] < ... A[i-1] < A[i]`
  - `A[i] > A[i+1] > ... > A[B.length - 1]`

**示例 1：**

```
输入：[2,1]
输出：false
```

**示例 2：**

```
输入：[3,5,5]
输出：false
```

**示例 3：**

```
输入：[0,3,2,1]
输出：true
```

**提示：**

1. `0 <= A.length <= 10000`
2. `0 <= A[i] <= 10000 `

**解题思路**

这个问题非常简单，我们设置左右两个指针，分别向中间靠拢，靠拢的同时要判断是不是上升过程。最后判断两个指针相会的点是不是有效点即可。

```python
class Solution:
    def validMountainArray(self, A):
        """
        :type A: List[int]
        :rtype: bool
        """
        i, j, A_len = 0, len(A) - 1, len(A)
        if A_len < 3:
            return False
        while i + 1 < A_len and A[i] < A[i + 1]: 
            i += 1
        while j > 0 and A[j - 1] > A[j]: 
            j -= 1
        return 0 < i == j < A_len - 1
```

这个问题使用`c++`需要一定的技巧。

```cpp
class Solution 
{
public:
    bool validMountainArray( vector<int>& A )
    {
        return 1 == distance(
            adjacent_find(A.cbegin(), A.cend(), greater_equal<int>()),
            adjacent_find(A.crbegin(), A.crend(), greater_equal<int>()).base());
    }
};
```

reference:

https://leetcode.com/problems/valid-mountain-array/discuss/195385/Concise-C++	

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**