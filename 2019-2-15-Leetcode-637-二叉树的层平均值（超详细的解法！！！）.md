---
layout: post
title: Leetcode 637：二叉树的层平均值（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-2-15 00:00:00
---

给定一个非空二叉树, 返回一个由每层节点平均值组成的数组.

**示例 1:**

```
输入:
    3
   / \
  9  20
    /  \
   15   7
输出: [3, 14.5, 11]
解释:
第0层的平均值是 3,  第1层是 14.5, 第2层是 11. 因此返回 [3, 14.5, 11].
```

**注意：**

1. 节点值的范围在32位有符号整数范围内。

**解题思路**

这个问题一个很容易想到的办法就是通过[Leetcode 102:二叉树的层次遍历（最详细解决方案！！！）](https://blog.csdn.net/qq_17550379/article/details/80824320)将所有的结果遍历出来，然后在对遍历结果的每一层求平均值。

```python
class Solution:
    def averageOfLevels(self, root: 'TreeNode') -> 'List[float]':
        levels = list()
        self.preOrder(root, 0, levels)
        res = list()
        for l in levels:
            res.append(sum(l)/len(l))
        return res
        
    def preOrder(self, root, level, res):
        if root:
            if len(res) == level:
                res.append([])
            res[level].append(root.val)
            self.preOrder(root.left, level + 1, res)
            self.preOrder(root.right, level + 1, res)
```

我们也可以通过迭代的方式处理这个问题，写法就是常规的`BFS`套路稍加修改。我们现在需要建立两个数组，一个数组用来存放当前要访问的层，另一个数组用来存放下一层的数组。

```python
class Solution:
    def averageOfLevels(self, root: 'TreeNode') -> 'List[float]':
        res = list()
        cur, n = [root], list()
        while cur:
            tmp = 0
            for node in cur:
                tmp += node.val
                if node.left:
                    n.append(node.left)
                if node.right:
                    n.append(node.right)
            res.append(tmp/len(cur))
            cur = n.copy()
            n.clear()
            
        return res
```

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**