---
layout: post
title: Leetcode 76:最小覆盖子串（最详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-06-02 00:00:00
---

给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。

**示例：**

```
输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"
```

**说明：**

- 如果 S 中不存这样的子串，则返回空字符串 `""`。
- 如果 S 中存在这样的子串，我们保证它是唯一的答案。

**解题思路**

对于这个问题我们首先就会相同通过`对撞指针`的方法来解。这里我们有一个比较难解决的问题就是**包含 T 所有字母的最小子串**怎么表示？首先想到的做法时对于输入的`s`子串`sW`和输入的`t`通过`collection.Counter`分别统计字母个数，得到两个字母个数字典`sW_count`和`tW_count`，然后遍历`tW_count`种的每个元素，判断它是不是在`sW_count`中，并且其元素个数不大于`sW_count`中的。于是我们可以写出这样的代码

```python
def _minWindow(self, sW, tW):
    sW_count, tW_count = Counter(sW), Counter(tW)
    for i, val in tW_count.items():
        if i in sW_count and val <= sW_count[i]:
            continue
        return False
    return True
```

但是这种做法我们在解决问题的过程中，出现了超时。很容易理解，对于一个很长的字符串来说，这个字符串包含了很多的子串，而我们对每个子串进行统计，这里面实际上有大量的冗余。所以我们可以通过动态记录一个`dict`来做为我们的子串字典。

接着，我们建立两个指针`l`和`r`分别指向窗口的左右，初始值赋为`0`和`t_len`。

```
A D O B E C O D E B A N C
|   |
l   r
```

然后我们建立一个`dict:sW_count`，存储`[l,r]`这个区间内的元素个数。我们同时建立一个`dict:tW_count`，记录`t`中的元素个数。当`[l,r]`区间内的元素个数不小于`t`中的元素个数时，我们要缩小这个窗口，也就是`l--`，而区间内的元素小于`t`中元素的时候，我们又要将这个窗口放宽，也就是`r++`。

```python
from collections import Counter
class Solution:
    def minWindow(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: str
        """
        if not s or not t:
            return ''

        s_len, t_len = len(s), len(t)
        if t_len > s_len:
            return ''

        l, r, minLength, minL, minR = 0, t_len, s_len+1, 0, 0
        tW_count = Counter(t)
        sW_count = Counter(s[l:r])
        while l < s_len:   
            if self._minWindow(sW_count, tW_count):
                if minLength > r - l:
                    minLength = r - l
                    minL, minR = l, r
                if sW_count[s[l]] == 1:
                    sW_count.pop(s[l])
                else:
                    sW_count[s[l]] -= 1
                l += 1
            else:
                if r == s_len:
                    break
                sW_count[s[r]] = sW_count.get(s[r], 0) + 1
                r +=1 

        return s[minL:minR]

    def _minWindow(self, sW, tW):
        for i, val in tW.items():
            if i in sW and val <= sW[i]:
                continue
            return False
        return True
```

上面这种做法思路很清晰，但是不够优雅。其实这个问题和[Leetcode 3:无重复字符的最长子串（最详细解决方案！！！）](https://blog.csdn.net/qq_17550379/article/details/80547777) 是一类问题，都可以归纳为子串问题，这类问题最优美的解法就是[Leetcode 3:无重复字符的最长子串（最详细解决方案！！！）](https://blog.csdn.net/qq_17550379/article/details/80547777) 中的解法2，通过借助`hash`表来处理。我们首先建立一个可以容纳ASCII的字典`mem`，然后记录`t`中元素出现的次数。接着我们遍历`s`中的元素，我们将字典中对应元素减一，如果`s`中的元素在`t`中出现过，那么我们记录此时的`t_len = len(t)-1`。当`t_len==0`时，说明此时`t`中的元素在`s`中都出现了，我们此时要进入下一步判断。

我们要建立窗口的左右`l`和`r`，我们的`l`初始化为`0`，而`r`对应我们`s`中遍历到元素的`index`。

```
A D O B E C O D E B A N C
|         |
l         r

mem:A0 B1 C1 D0 E1...
```

我们要判断`mem`中`s[l]`是不是小于`0`，如果是的话，说明`[l:r]`这个区间内没有包含`t`中的所有元素，所以我们将`l++`。否则的话，我们记录此时的`l`和`r`。然后我们将`l++`并且`t_len++`，将`s[l]`再加入到`mem`中去，这样我们就将窗口向右滑动一步

```
A D O B E C O D E B A N C
  |       |
  l       r

mem:A1 B1 C1 D0 E1...
```

我们基于此就可以写出下面的代码

```python
from collections import defaultdict
class Solution:
    def minWindow(self, s, t):
        mem = defaultdict(int)
        for c in t:
            mem[c] += 1
        t_len = len(t)
        
        minL, minR = 0, float('inf')
        
        l = 0
        for r, c in enumerate(s):
            if mem[c] > 0:
                t_len -= 1
            mem[c] -= 1
                
            if t_len == 0:
                while mem[s[l]] < 0:
                    mem[s[l]] += 1
                    l += 1
                    
                if r - l < minR - minL:
                    minL, minR = l, r
                
                mem[s[l]] += 1
                t_len += 1
                l += 1
        
        return '' if minR == float('inf') else s[minL:minR+1]
```

这种写法比上面要简洁，速度要快（我们没有对字典进行插入和删除操作）。

该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)

**如有问题，希望大家指出！！！**

