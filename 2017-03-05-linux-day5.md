---
layout: post
title: linux Day5
category : linux
tags : [linux]
stickie: true
---


process
===

PID进程号  PPID父进程号   都为非零整数  
所有的进程追述到init，Init进程是linux内核启动后第一个执行的进程，进程号1  
getpid()获取pid      getppid()获取ppid


getlogin
===

getlogin()获取登陆者信息
getpwnam()返回一个指向passwd结构的指针,返回的是/etc/passwd文件中与该登录名一致的信息
printf(&ldquo;user name = %s\n&rdquo;, ps-&gt;pw_name)

创建进程

```c
int system(const char *string)
```
system函数传递给/bin/sh &ndash;c来执行string所指向的内容
没有找到/bin/sh返回127，出错返回-1，成功返回0，string为NULL返回非零

fork
===

```c
pid_t fork(void);
```
父进程中fork返回子进程的pid，子进程中fork返回0 
fork创建的新进程是父进程的副本，区别在于没有继承父进程的超时设置，文件锁，未决信号  
子进程中调用fork不会产生副本  
注意一点：子进程fork之前的代码不执行，执行两次父进程一次，子进程一次  
fork的主要用处：  
服务端程序，tty 中显示？表示没有控制台程序  
两个独立的进程，用同一个文件描述符

execve
===

```c
int execve(const char *path, const char *argv, char *const envp[]);
```
path 要执行的文件完整路径  
argv传递给程序完整参数列表，包括argv[0]，一般是执行程序的名字  
envp一般指向execed程序的环境指针，可以设为NULL  
fork创建一个新进程，产生一个新的pid  
execve用被执行的程序完全替代调用进程的映像  
execve启动一个新程序，替代原有进程，所有被执行进程的pid不变，只是改变了代码

wait waitpid
===

```c
<sys/wait.h>
pid_t wait(int *status)
pid_t waitpid(pid_t pid, int *status, int options);
```
status保存子进程的退出状态，退出返回的值WEXITSTATUS(status)  
pid为等待进程的pid，接受如下几个值  
-1            等待任何pgid等于pid的绝对子进程  
1             等待任何子进程  
0             等待任何pgid等于调用进程的子进程  
&gt;0            等待pid等于pid的子进程  

进程识别码(PID)：用来唯一标识进程。  
进程组识别码(Process Group ID)：一个进程可以属于某个进程组。  
可以发送信号给一组进程。对于进程组ID，一般来说，一个进程在shell下执行，shell程序就将该进程的PID赋给该进程的进程组ID，从该进程派生的子进程都拥有父进程所属的进程组ID，除非父进程将子进程的所属组ID设置成与该子进程的PID一样。

僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
