---
layout: post
title: Leetcode 987：二叉树的垂序遍历（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-2-8 00:00:00
---

给定二叉树，按*垂序*遍历返回其结点值。

对位于 `(X, Y)` 的每个结点而言，其左右子结点分别位于 `(X-1, Y-1)` 和 `(X+1, Y-1)`。

把一条垂线从 `X = -infinity` 移动到 `X = +infinity` ，每当该垂线与结点接触时，我们按从上到下的顺序报告结点的值（ `Y` 坐标递减）。

如果两个结点位置相同，则首先报告的结点值较小。

按 `X` 坐标顺序返回非空报告的列表。每个报告都有一个结点值列表。

**示例 1：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2019/01/31/1236_example_1.PNG" width=200" >
</center>

```
输入：[3,9,20,null,null,15,7]
输出：[[9],[3,15],[20],[7]]
解释： 
在不丧失其普遍性的情况下，我们可以假设根结点位于 (0, 0)：
然后，值为 9 的结点出现在 (-1, -1)；
值为 3 和 15 的两个结点分别出现在 (0, 0) 和 (0, -2)；
值为 20 的结点出现在 (1, -1)；
值为 7 的结点出现在 (2, -2)。
```

**示例 2：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2019/01/31/tree2.png" width=250" >
</center>


```
输入：[1,2,3,4,5,6,7]
输出：[[4],[2],[1,5,6],[3],[7]]
解释：
根据给定的方案，值为 5 和 6 的两个结点出现在同一位置。
然而，在报告 "[1,5,6]" 中，结点值 5 排在前面，因为 5 小于 6。
```

**提示：**

1. 树的结点数介于 `1` 和 `1000` 之间。
2. 每个结点值介于 `0` 和 `1000` 之间。

**解题思路**

这个问题首先想到的就是暴力破解，将每个节点的对应坐标存储到一个字典中，然后遍历字典将每一列存放到结果中去。

```python
from collections import defaultdict
class Solution:
    def verticalTraversal(self, root: 'TreeNode') -> 'List[List[int]]':
        self.tree = defaultdict(lambda : defaultdict(list))
        self.dfs(root, 0, 0)
        res = list()
        for x in sorted(self.tree.keys()):
            tmp = list()
            for y in sorted(self.tree[x].keys()):
                tmp += sorted(self.tree[x][y])
            res.append(tmp)
            
        return res
    
    def dfs(self, root, x, y):
        if root:
            self.tree[x][y].append(root.val)
            self.dfs(root.left, x-1, y+1)
            self.dfs(root.right, x+1, y+1)
```

在使用`cpp`的时候，我们可以使用`map`这个结构，这样我们就不用排序了。

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**