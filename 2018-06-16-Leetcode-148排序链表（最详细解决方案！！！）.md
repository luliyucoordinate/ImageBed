---
layout: post
title: Leetcode 148:排序链表（最详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-06-16 00:00:00
---

在 *O*(*n* log *n*) 时间复杂度和常数级空间复杂度下，对链表进行排序。

**示例 1:**

```
输入: 4->2->1->3
输出: 1->2->3->4
```

**示例 2:**

```
输入: -1->5->3->4->0
输出: -1->0->3->4->5
```

**解题思路**

根据问题的提示***O*(*n* log *n*)时间复杂度和常数级空间复杂度**

最简单的做法，我们可以使用归并排序（没有链表之间的跳转操作）。

```python
class Solution:
    def _merge(self, head1, head2):
        if head1 == None or head2 == None:
            return head2 or head1

        h = ListNode(-1)
        tmp = h
        while head1 != None and head2 != None:
            if head1.val < head2.val:
                tmp.next = head1
                head1 = head1.next
            else:
                tmp.next = head2
                head2 = head2.next
            tmp = tmp.next
        
        tmp.next = head1 or head2

        return h.next
        

    def sortList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head == None or head.next == None:
            return head
        
        lat = pre = head
        while lat.next != None and lat.next.next != None:
            lat = lat.next.next
            pre = pre.next

        lat = pre.next
        pre.next = None
        return self._merge(self.sortList(head), self.sortList(lat))
```

加入我们这里使用快速排序，我同样给出一个快速排序的版本。



**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**