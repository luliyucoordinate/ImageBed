---
layout: post
title: Leetcode 167:两数之和 II - 输入有序数组（最详细解决方案！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-05-23 00:00:00
---

给定一个已按照**升序排列** 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2*。*

**说明:**

- 返回的下标值（index1 和 index2）不是从零开始的。
- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例:**

```
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

**解题思路**

首先想到的解决思路是通过两次循环，每次循环遍历列表，这种算法的时间复杂度是`O(n^2)`。（这是我们在[Leetcode 1 两数之和]()中提到的解决方案）

```python
class Solution:
    def twoSum(self, numbers, target):
        """
        :type numbers: List[int]
        :type target: int
        :rtype: List[int]
        """
        nums_len = len(numbers)
        for i in range(nums_len):
            for j in range(i + 1, nums_len):
                if numbers[i] + numbers[j] == target:
                    return [i + 1, j + 1]

        return []
```

但是很明显，这种暴力解法在这问题中显得很蠢(⊙﹏⊙)

我们知道这个数据是有序的，那么我们很容易联想到使用二分搜索法是不是可以用于这个问题呢？我们可以每次判断`target-num[i]`对应的值是否在`num[i+1:]`中，这个时候算法的复杂度变成了`O(nlogn)`。

```python
class Solution:
    def _BinarySearch(self, numbers, target):
        l = 0
        r = len(numbers) - 1       
        while l <= r:
            mid = (l + r) // 2
            if target == numbers[mid]:
                return mid
            elif target < numbers[mid]:
                r = mid - 1
            else:
                l = mid + 1
        return -1

    def twoSum(self, numbers, target):
        """
        :type numbers: List[int]
        :type target: int
        :rtype: List[int]
        """
        nums_len = len(numbers)
        for i in range(nums_len):
            dif = target - numbers[i] 
            dif_index = self._BinarySearch(numbers[i + 1:], dif)
            if dif_index != -1:
                return [i + 1, dif_index + i + 2]
        return []
```

那么我们就想有没有`O(n)`级别的做法呢？我们依然可以参考之前[Leetcode 1 两数之和]()中使用`hash`表的方法，但是这种做法的空间复杂度就变成了`O(n)`。我们有没有空间复杂度`O(1)`，时间复杂度`O(n)`的做法呢？我们要充分利用题目给的条件：**有序数组**

```
0  1  2  3  4  5  6  7
l->                <-r
```

我们可以这样想，我们首先判断首尾两项的和是不是`target`，如果比`target`小，那么我们`左边+1`位置的数（比`左边`位置的数大）再和右相相加，继续判断。如果比`target`大，那么我们`右边-1`位置的数（比`右边位置的数小`）再和左相相加，继续判断。我们通过这样不断放缩的过程，就可以在`O(n)`的时间复杂度内找到对应的坐标位置。（这和快速排序的思路很相似）

```python
class Solution:
    def twoSum(self, numbers, target):
        """
        :type numbers: List[int]
        :type target: int
        :rtype: List[int]
        """
        l = 0
        r = len(numbers) - 1
        while l < r:
            if numbers[l] + numbers[r] == target:
                return [l + 1, r + 1]
            elif numbers[l] + numbers[r] < target:
                l += 1
            else:
                r -= 1
        return []
```

这种解法叫做`对撞指针法`，又叫做`双索引法`。

该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)

**如有问题，希望大家指出！！！**