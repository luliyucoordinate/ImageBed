---
layout: post
title: python字符串令牌解析
category : python
tags : [python, 字符串令牌]
stickie: true
---

在分析这个问题之前，我们先看一下什么是分组。在正则表达式中，括号括起来的部分是一个分组。例如

```python
import re
text = 'Today is 11/27/2012. PyCon starts 3/13/2013.'
datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
m = datepat.match('11/27/2012')
print(m.group(0))
print(m.group(1))
print(m.group(2))
print(m.group(3))
print(m.groups())
```

输出结果为

```python
11/27/2012
11
27
2012
('11', '27', '2012')
```

这里面我们使用了`group`函数，我们通过这个函数可以获得对应序号的`group`，`group(0)`表示整个匹配到的整个字符串，`group(1)`对应的是`11`，`group(2)`对应的是`27`，`group(3)`对应的是`2012`。我们可以通过`groups`得到所有`group`组成的元组。

`(?P<name>...)`分组，除了原有的编号外，指定一个额外的别名`name`。例如

```python
import re
text = 'Today is 11/27/2012. PyCon starts 3/13/2013.'
datepat = re.compile(r'(?P<day>\d+)/(?P<month>\d+)/(?P<year>\d+)')
m = datepat.match('11/27/2012')
print(m.group('day'))
print(m.group('month'))
print(m.group('year'))
```

结果是

```python
11
27
2012
```

现在我们继续。我们看这样一个问题，我们有这样一个字符串

```python
text = 'foo = 23 + 42 * 10'
```

我们希望字符串转化为像下面这样的序列对：

```python
tokens = [('NAME', 'foo'), ('EQ','='), ('NUM', '23'), ('PLUS','+'),('NUM', '42'), ('TIMES', '*'), ('NUM', 10')]
```

我们可以通过这样的方法

```python
import re
NAME = r'(?P<NAME>[a-zA-Z_][a-zA-Z_0-9]*)'
NUM = r'(?P<NUM>\d+)'
PLUS = r'(?P<PLUS>\+)'
TIMES = r'(?P<TIMES>\*)'
EQ = r'(?P<EQ>=)'
WS = r'(?P<WS>\s+)'
master_pat = re.compile('|'.join([NAME, NUM, PLUS, TIMES, EQ, WS]))
scanner = master_pat.scanner('foo = 23 + 42 * 10')
first=scanner.match()
print(first.lastgroup,first.group())
first=scanner.match()
print(first.lastgroup,first.group())
first=scanner.match()
print(first.lastgroup,first.group())
first=scanner.match()
print(first.lastgroup,first.group())
```

输出结果为

```python
NAME foo
WS  #匹配空字符
EQ =
WS  
```

为了令牌化，使用模式对象很少被人知道的 `scanner()` 方法。这个方法会创建一个`scanner `对象，在这个对象上不断的调用 `match()` 方法会一步步的扫描目标文本，每步一个匹配。我们通过属性`lastgroup`输出匹配到的字符串别名，通过`group`函数匹配到具体字符。

这个功能一般情况下用不到，我只此记录。