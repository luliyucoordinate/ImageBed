---
layout: post
title: Leetcode 201：数字范围按位与（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-7 00:00:00
---

给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。

**示例 1:** 

```
输入: [5,7]
输出: 4
```

**示例 2:**

```
输入: [0,1]
输出: 0
```

**解题思路**

首先想到的就是暴力破解，遍历范围中的数，然后对所有数进行`and`操作。

```python
from functools import reduce
from operator import __and__
class Solution:
    def rangeBitwiseAnd(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        return reduce(__and__, range(m, n+1))
```

超时了，果然没这么容易。

我们知道当一个奇数和一个偶数进行`and`的话，那么最后一位一定是`0`。如果我们输入的`m!=n`，那么必然`[m,n]`这个区间内至少包含一个奇数和一个偶数，也就是最后一位一定是`0`。通过这种手段我们就可以计算出结果中的右边有几个`0`，那么左边是什么呢？左边就应该是`n`右移`i`位后剩余的部分。

```python
class Solution:
    def rangeBitwiseAnd(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        i = 0
        while m != n:
            m >>= 1
            n >>= 1
            i += 1
        return n << i
```

实际上我们右边有多少个`0`是可以计算出来的。我们只需要计算`m^n`后，然后获取从右往左最后一个`1`的位置`i`，，这个位置就是我们需要左移的位置。我们可以通过$int(log_2^{m\oplus n})+1$计算得到位置，在`python`中，我们直接使用`bit_length`即可。

```python
class Solution:
    def rangeBitwiseAnd(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        i = (m ^ n).bit_length()
        return m >> i << i
```

是不是很酷。

reference:

https://leetcode.com/problems/bitwise-and-of-numbers-range/discuss/56729/Bit-operation-solution(JAVA)

https://leetcode.com/problems/bitwise-and-of-numbers-range/discuss/56863/A-Math-solution.

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**