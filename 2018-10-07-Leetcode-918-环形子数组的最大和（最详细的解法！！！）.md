---
layout: post
title: Leetcode 918：环形子数组的最大和（最详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2018-10-07 00:00:00
---

给定一个由整数数组 `A` 表示的**环形数组 C**，求 **C**的非空子数组的最大可能和。

在此处，*环形数组*意味着数组的末端将会与开头相连呈环状。（形式上，当`0 <= i < A.length` 时 `C[i] = A[i]`，而当 `i >= 0` 时 `C[i+A.length] = C[i]`）

此外，子数组最多只能包含固定缓冲区 `A` 中的每个元素一次。（形式上，对于子数组 `C[i], C[i+1], ..., C[j]`，不存在 `i <= k1, k2 <= j` 其中 `k1 % A.length = k2 % A.length`）

**示例 1：**

```
输入：[1,-2,3,-2]
输出：3
解释：从子数组 [3] 得到最大和 3
```

**示例 2：**

```
输入：[5,-3,5]
输出：10
解释：从子数组 [5,5] 得到最大和 5 + 5 = 10
```

**示例 3：**

```
输入：[3,-1,2,-1]
输出：4
解释：从子数组 [2,-1,3] 得到最大和 2 + (-1) + 3 = 4
```

**示例 4：**

```
输入：[3,-2,2,-3]
输出：3
解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3
```

**示例 5：**

```
输入：[-2,-3,-1]
输出：-1
解释：从子数组 [-1] 得到最大和 -1
```

**提示：**

1. `-30000 <= A[i] <= 30000`
2. `1 <= A.length <= 30000`

**解题思路**

这个问题是之前[Leetcode 53：最大子序和（最详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/82963541)的推广。

对于这个环形数组问题，我们会出现这样的两种情况不包含循环节点的子数组和包含循环节点（首尾节点）的子数组。对于不包含循环节点的子数组，我们直接使用`Kadane`算法即可。而对于包含循环节点的子数组，我们只要将`nums`中的每个元素取相反数，然后对这个相反数数组`-nums`运用`Kandane`算法就可以求解出`Kadane(-nums.subset)`（一定不包含循环节点，为什么？原来的最大变为了现在的最小，此时求解出来的实际上是原来最小值的相反数），然后我们将`sum(nums)+Kadane(-nums.subset)`就可以得到有循环节点的最大值。图示

<center class="half">
    <img src="http://wx2.sinaimg.cn/mw690/af2d2659ly1fvzv2dbajhj20hq099wew.jpg" width="600" hegiht="400">
</center>

但是这个思想有一个小`bug`，当我们最后求得的最大值是由整个数组构成的话，那么这个问题就回到了第一个问题（不包含循环节点）。举这样的例子

```
-1, -2, -3
```

验算一下就会发现不合理的地方。这种情况也很好剔除，只要在程序的初始阶段检查一下`max(nums)`是不是小于零即可。

```python
class Solution:
    def maxSubarraySumCircular(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        def kadane(nums):
            result = cur = float('-inf')
            for num in nums:
                cur = max(cur, 0) + num
                result = max(result, cur)
            return result

        max_A = max(A)
        if max_A < 0:
            return max_A

        result1 = kadane(A)
        result2 = sum(A) + kadane([-num for num in A])
        return max(result1, result2)
```

非常简洁，非常优雅！！！

实际上我们可以将`kadane`算法嵌入到现在的算法中，而不是单独处理，这样我们又得到了一个更加简洁的代码。

```python
class Solution:
    def maxSubarraySumCircular(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        total, maxSum, curMax, minSum, curMin = 0, float('-inf'), 0, float('inf'), 0
        for a in A:
            curMax = max(curMax + a, a)
            maxSum = max(maxSum, curMax)
            curMin = min(curMin + a, a)
            minSum = min(minSum, curMin)
            total += a
        return max(maxSum, total - minSum) if maxSum > 0 else maxSum
```

真的是非常棒！！！

reference:

https://leetcode.com/articles/maximum-sub-circular-subarray/

https://leetcode.com/problems/maximum-sum-circular-subarray/discuss/178422/C++JavaPython-One-Pass

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**