---
layout: post
title: STL容器（8）无序容器
category : cpp
tags : [cpp, notes, cpp标准库]
stickie: true
---


定义于头文件\<unordered_set\>  

```c++
template<
    class Key,
    class Hash = std::hash<Key>,
    class KeyEqual = std::equal_to<Key>,
    class Allocator = std::allocator<Key>
> class unordered_set;
```
(C++11 起)  
无序集合是一个关联容器，包含一些类型为Key的唯一对象。搜索，插入和删除具有平摊的常数时间复杂度。  
定义于头文件\<unordered_set\>  

```c++
template<
    class Key,
    class Hash = std::hash<Key>,
    class KeyEqual = std::equal_to<Key>,
    class Allocator = std::allocator<Key>
> class unordered_multiset;
```
(C++11 起)  
无序多重集合是一个关联容器，含有一些类型为Key的，可能不是唯一的对象。搜索，插入和删除具有平摊的常数时间复杂度。  
定义于头文件 \<unordered_map\>  

```c++
template<
    class Key,
    class T,
    class Hash = std::hash<Key>,
    class KeyEqual = std::equal_to<Key>,
    class Allocator = std::allocator< std::pair<const Key, T> >
> class unordered_map;
```
(C++11 起)  
无序映射是一个关联容器，包含带有唯一键的键值对。搜索，插入和去除具有平摊的常数时间复杂度。  
定义于头文件 \<unordered_map\>  

```c++
template<
    class Key,
    class T,
    class Hash = std::hash<Key>,
    class KeyEqual = std::equal_to<Key>,
    class Allocator = std::allocator< std::pair<const Key, T> >
> class unordered_multimap;
```
(C++11 起)  
无序多重映射是一个无序关联容器，支持多个相等的键（unordered_multimap中，每个键对应的值可能不唯一）以及相关联的另一种类型的值。unordered_multimap类支持前向迭代器。搜索，插入和去除具有平摊的常数时间复杂度。  

Unordered容器能力
---

Unordered容器比起寻常的associative容器，要的优点是：在安插、删除、查找元素时获得amortized常量时间，因为偶尔发生的rehashing可能是个大型操作。主要缺点是：Unordered容器不提供operator<、>、<=和>=这些容器的多重实例。不提供lower_bound和upper_bound。由于iterator只保证至少是个forward iterator，所以别的迭代器的算法都是用不了。  
由于元素的(key)value关系到元素的位置，所以不可以直接修改(key)value，通过iterator访问时，元素的(key)value是常量。  
Erase函数不会造成指向元素的iterator、reference和pointer失效。在调用insert、reserve和clear、rehash时会rehashing。  

创建和控制Unordered容器
---

欲定义最大负载系数，你必须在构建后立刻调用一个成员函数：  

```c++
std::unordered_set<std::string> coll;
coll.max_load_factor(0.7);
```
通常0.7~0.8是速度和内存消耗量之间一个不错的折中。默认的最大负载系数时1.0，意思是通常碰撞会发生在rehash之前。  
reverse与rehash的区别在于：如果在大负载系数时0.7而你打算准备100个元素，你必须将100初一0.7。也就是你必须传入143给rehash以避免在最高达到100个元素的情况下出现进一步rehash。如果使用reverse，这一计算是内部进行的额，所以你可以仅仅传递hashtable应该筹备的元素个数：  
rehash：Sets the number of buckets to count and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. If the new number of buckets makes load factor more than maximum load factor (count < size() / max_load_factor()), then the new number of buckets is at least size() / max_load_factor().  
reverse：Sets the number of buckets to the number needed to accomodate at least count elements without exceeding maximum load factor and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. Effectively calls rehash(std::ceil(count / max_load_factor())).  

Unordered容器的其他操作
---

Unordered左右两端容器必须有相同类型，更明确地说是其hash function的类型以及equivalence criterion(等价标准)必须相同，即使hash函数本身可能不同。
与map/multimap对应的是unordered map/multimap的元素类型是pair<const key, T>，意味着你需要first和second才能范文一个元素的key和value。  

```c++
for(auto elem& : coll)
{
	std::cout << "key：" << elem.first << "\t" << std::endl;
}
```
改变key的值会导致错误，改变元素的value就没问题，只要elem是个non-const reference且value的类型不是const：  

```c++
elem.second = 13.5;
```
如果你是用算法和lambda来操作map内的元素，你必须明确元素类型，可以查看[map的例子](http://www.coordinate.wang/cpp/2017/04/29/STL%E5%AE%B9%E5%99%A87Map%E5%92%8CMutimap.html)  
一般而言，erasing函数并不会令“指向至其他元素”的iterator和reference失效。然而成员函数insert和emplace有可能令所有iterator失效，当rehashing发生，尽管指向元素的reference将总是保持有效。rehashing之所以发生，是由于一次安插动作造成最终元素的个数大于等于bucket数量乘以最大负载系数。insert和emplace成员函数不会影响指向容器元素的reference的有效性。  
