---
layout: post
title: 变位词问题
category : 算法
tags : [cpp, 算法]
---

如果能够通过改变一个单词的字母顺序，来得到另一个单词。我们称这两个单词是变位词。例如单词tea和eat是变位词。

一个简单的处理思路是，通过判断一个单词中的各字母数量与另一个单词中的是不是一样。如果你对于c++标准库很熟悉的话，这个问题很快就解决了（使用*is_permutation*）

```c++
/**********************************************************
*2017_10_3 by coordinte
*变位词问题
*win10 vs2015 x86 debug 
*www.coordinate.wang
************************************************************/
#include <iostream>
#include <set>
#include <string>
#include <iterator>
#include <algorithm>
using std::string;

int main()
{
	string first, second;
	std::multiset<char> word_f, word_s;

	std::cout << "Enter first word: \n";
	std::cin >> first;
	std::cout << "Enter second word: \n";
	std::cin >> second;
	std::for_each(std::begin(first), std::end(first), 
		[&word_f](const char& c) {
		word_f.emplace(c);
	});
	std::for_each(std::begin(second), std::end(second),
		[&word_s](const char& c) {
		word_s.emplace(c);
	});
	if (first.length() == second.length())
	{
		for (auto iter = std::begin(first); iter != std::end(first); ++iter)
		{
			if (word_f.count(*iter) != word_s.count(*iter))
			{
				std::cout << "The words are not anagrams.";
				return 0;
			}
		}
		std::cout << "The words are anagrams.";
	}
	else
		std::cout << "The words are not anagrams.";
	system("pause");
}
```



```c++
/**********************************************************
*2017_10_3 by coordinte
*变位词问题
*win10 vs2015 x86 debug 
*www.coordinate.wang
************************************************************/
#include <iostream>
#include <string>
#include <iterator>
#include <algorithm>
using std::string;

int main()
{
	string first, second;	
	std::cout << "Enter first word: \n";
	std::cin >> first;
	std::cout << "Enter second word: \n";
	std::cin >> second;
	if (std::is_permutation(std::begin(first), std::end(first), std::begin(second), std::end(second)))
		std::cout << "The words are anagrams.";
	else
		std::cout << "The words are not anagrams.";
	system("pause");
}
```

我在这里都没有考虑字符的大小写问题，这些都是要做预处理的，我在这就不赘述了。

关于*is_permutation*的一个可能的实现

```c++
template<class ForwardIt1, class ForwardIt2>
bool is_permutation(ForwardIt1 first, ForwardIt1 last,
                    ForwardIt2 d_first)
{
   // skip common prefix
   std::tie(first, d_first) = std::mismatch(first, last, d_first);
   // iterate over the rest, counting how many times each element
   // from [first, last) appears in [d_first, d_last)
   if (first != last) {
       ForwardIt2 d_last = d_first;
       std::advance(d_last, std::distance(first, last));
       for (ForwardIt1 i = first; i != last; ++i) {
            if (i != std::find(first, i, *i)) continue; // already counted this *i
 
            auto m = std::count(d_first, d_last, *i);
            if (m==0 || std::count(i, last, *i) != m) {
                return false;
            }
        }
    }
    return true;
}
```

