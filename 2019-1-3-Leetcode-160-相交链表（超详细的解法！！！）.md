---
layout: post
title: Leetcode 160：相交链表（超详细的解法！！！）
category : 算法
tags : [python, c, c++]
stickie: true
date: 2019-1-3 00:00:00
---

编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表**：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png" width="350">
</center>

在节点 c1 开始相交。

**示例 1：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" width="350">
</center>

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**示例 2：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" width="300">
</center>

```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

<center class="half">
    <img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" width="200">
</center>

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
```

**注意：**

- 如果两个链表没有交点，返回 `null`.
- 在返回结果后，两个链表仍须保持原有的结构。
- 可假定整个链表结构中没有循环。
- 程序尽量满足 O(*n*) 时间复杂度，且仅用 O(*1*) 内存。

**解题思路**

最简单的做法就是先将`A`中的节点添加到`set`中，然后遍历`B`中的节点，判断遍历到的节点是不是在`set`中已经存在了，如果存在的话，那么这个就是交点。

```python
class Solution(object):
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        nodes = set()
        while headA:
            nodes.add(headA)
            headA = headA.next
            
        while headB:
            if headB in nodes:
                return headB
            
            headB = headB.next
            
        return None
```

但是这种做法我们的空间复杂度就是`O(n)`。如果使用`O(1)`的空间复杂度该怎么做呢？

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/160/2019_1_3_1.png" width="250">
</center>

如果我们将链表拉直，然后按照`A+B`和`B+A`拼在一起。

<center class="half">
    <img src="https://raw.githubusercontent.com/wiki/luliyucoordinate/ImageBed/160/2019_1_3_1.png" width="300">
</center>

规律已经很明显了，我们只需要将`A`和`B`中节点比较，如果为空，我们就将`A`或`B`接到对应的节点后继续遍历，最后一定会出现相同节点的情况（如果相交的话）。

```python
class Solution(object):
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        n1, n2 = headA, headB
        while n1 != n2:
            n1 = n1.next if n1 else headB
            n2 = n2.next if n2 else headA
            
        return n1
```

reference:

https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49785/Java-solution-without-knowing-the-difference-in-len!

**我将该问题的其他语言版本添加到了我的[GitHub Leetcode](https://github.com/luliyucoordinate/Leetcode)**

**如有问题，希望大家指出！！！**